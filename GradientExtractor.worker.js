/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./node_modules/@capture/gradient-core/src/GradientExtractor.worker.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@capture/gradient-core/src/GradientCaptureCore.wasm":
/*!**************************************************************************!*\
  !*** ./node_modules/@capture/gradient-core/src/GradientCaptureCore.wasm ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"resources/GradientCaptureCore.wasm\";\n\n//# sourceURL=webpack:///./node_modules/@capture/gradient-core/src/GradientCaptureCore.wasm?");

/***/ }),

/***/ "./node_modules/@capture/gradient-core/src/GradientCaptureCoreScript.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@capture/gradient-core/src/GradientCaptureCoreScript.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process, __dirname) {var require;\n\n/* eslint-disable */\nvar GradientCaptureCoreScript = function () {\n  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;\n\n  return function (GradientCaptureCore) {\n    GradientCaptureCore = GradientCaptureCore || {};\n\n    if (typeof window === 'undefined') {\n      var window = self;\n    }\n\n    require = window.nodeRequire; // Copyright 2010 The Emscripten Authors.  All rights reserved.\n    // Emscripten is available under two separate licenses, the MIT license and the\n    // University of Illinois/NCSA Open Source License.  Both these licenses can be\n    // found in the LICENSE file.\n    // The Module object: Our interface to the outside world. We import\n    // and export values on it. There are various ways Module can be used:\n    // 1. Not defined. We create it here\n    // 2. A function parameter, function(Module) { ..generated code.. }\n    // 3. pre-run appended it, var Module = {}; ..generated code..\n    // 4. External script tag defines var Module.\n    // We need to check if Module already exists (e.g. case 3 above).\n    // Substitution will be replaced with actual code on later stage of the build,\n    // this way Closure Compiler will not mangle it (e.g. case 4. above).\n    // Note that if you want to run closure, and also to use Module\n    // after the generated code, you will need to define   var Module = {};\n    // before the code. Then that object will be used in the code, and you\n    // can continue to use Module afterwards as well.\n\n    var Module = typeof GradientCaptureCore !== 'undefined' ? GradientCaptureCore : {}; // --pre-jses are emitted after the Module integration code, so that they can\n    // refer to Module (if they choose; they can also define Module)\n    // {{PRE_JSES}}\n    // Sometimes an existing Module object exists with properties\n    // meant to overwrite the default module functionality. Here\n    // we collect those properties and reapply _after_ we configure\n    // the current environment's defaults to avoid having to be so\n    // defensive during initialization.\n\n    var moduleOverrides = {};\n    var key;\n\n    for (key in Module) {\n      if (Module.hasOwnProperty(key)) {\n        moduleOverrides[key] = Module[key];\n      }\n    }\n\n    Module['arguments'] = [];\n    Module['thisProgram'] = './this.program';\n\n    Module['quit'] = function (status, toThrow) {\n      throw toThrow;\n    };\n\n    Module['preRun'] = [];\n    Module['postRun'] = []; // Determine the runtime environment we are in. You can customize this by\n    // setting the ENVIRONMENT setting at compile time (see settings.js).\n\n    var ENVIRONMENT_IS_WEB = false;\n    var ENVIRONMENT_IS_WORKER = false;\n    var ENVIRONMENT_IS_NODE = false;\n    var ENVIRONMENT_HAS_NODE = false;\n    var ENVIRONMENT_IS_SHELL = false;\n    ENVIRONMENT_IS_WEB = typeof window === 'object';\n    ENVIRONMENT_IS_WORKER = typeof importScripts === 'function'; // A web environment like Electron.js can have Node enabled, so we must\n    // distinguish between Node-enabled environments and Node environments per se.\n    // This will allow the former to do things like mount NODEFS.\n    // Extended check using process.versions fixes issue #8816.\n    // (Also makes redundant the original check that 'require' is a function.)\n\n    ENVIRONMENT_HAS_NODE = typeof process === 'object' && typeof process.versions === 'object' && typeof process.versions.node === 'string';\n    ENVIRONMENT_IS_NODE = ENVIRONMENT_HAS_NODE && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;\n    ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\n\n    if (Module['ENVIRONMENT']) {\n      throw new Error('Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -s ENVIRONMENT=web or -s ENVIRONMENT=node)');\n    } // Three configurations we can be running in:\n    // 1) We could be the application main() thread running in the main JS UI thread. (ENVIRONMENT_IS_WORKER == false and ENVIRONMENT_IS_PTHREAD == false)\n    // 2) We could be the application main() thread proxied to worker. (with Emscripten -s PROXY_TO_WORKER=1) (ENVIRONMENT_IS_WORKER == true, ENVIRONMENT_IS_PTHREAD == false)\n    // 3) We could be an application pthread running in a worker. (ENVIRONMENT_IS_WORKER == true and ENVIRONMENT_IS_PTHREAD == true)\n    // `/` should be present at the end if `scriptDirectory` is not empty\n\n\n    var scriptDirectory = '';\n\n    function locateFile(path) {\n      if (Module['locateFile']) {\n        return Module['locateFile'](path, scriptDirectory);\n      } else {\n        return scriptDirectory + path;\n      }\n    }\n\n    if (ENVIRONMENT_IS_NODE) {\n      scriptDirectory = __dirname + '/'; // Expose functionality in the same simple way that the shells work\n      // Note that we pollute the global namespace here, otherwise we break in node\n\n      var nodeFS;\n      var nodePath;\n\n      Module['read'] = function shell_read(filename, binary) {\n        var ret;\n        if (!nodeFS) nodeFS = require('fs');\n        if (!nodePath) nodePath = require('path');\n        filename = nodePath['normalize'](filename);\n        ret = nodeFS['readFileSync'](filename);\n        return binary ? ret : ret.toString();\n      };\n\n      Module['readBinary'] = function readBinary(filename) {\n        var ret = Module['read'](filename, true);\n\n        if (!ret.buffer) {\n          ret = new Uint8Array(ret);\n        }\n\n        assert(ret.buffer);\n        return ret;\n      };\n\n      if (process['argv'].length > 1) {\n        Module['thisProgram'] = process['argv'][1].replace(/\\\\/g, '/');\n      }\n\n      Module['arguments'] = process['argv'].slice(2); // MODULARIZE will export the module in the proper place outside, we don't need to export here\n\n      process['on']('uncaughtException', function (ex) {\n        // suppress ExitStatus exceptions from showing an error\n        if (!(ex instanceof ExitStatus)) {\n          throw ex;\n        }\n      }); // Currently node will swallow unhandled rejections, but this behavior is\n      // deprecated, and in the future it will exit with error status.\n\n      process['on']('unhandledRejection', abort);\n\n      Module['quit'] = function (status) {\n        process['exit'](status);\n      };\n\n      Module['inspect'] = function () {\n        return '[Emscripten Module object]';\n      };\n    } else if (ENVIRONMENT_IS_SHELL) {\n      if (typeof read != 'undefined') {\n        Module['read'] = function shell_read(f) {\n          return read(f);\n        };\n      }\n\n      Module['readBinary'] = function readBinary(f) {\n        var data;\n\n        if (typeof readbuffer === 'function') {\n          return new Uint8Array(readbuffer(f));\n        }\n\n        data = read(f, 'binary');\n        assert(typeof data === 'object');\n        return data;\n      };\n\n      if (typeof scriptArgs != 'undefined') {\n        Module['arguments'] = scriptArgs;\n      } else if (typeof arguments != 'undefined') {\n        Module['arguments'] = arguments;\n      }\n\n      if (typeof quit === 'function') {\n        Module['quit'] = function (status) {\n          quit(status);\n        };\n      }\n    } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n      if (ENVIRONMENT_IS_WORKER) {\n        // Check worker, not web, since window could be polyfilled\n        scriptDirectory = self.location.href;\n      } else if (document.currentScript) {\n        // web\n        scriptDirectory = document.currentScript.src;\n      } // When MODULARIZE (and not _INSTANCE), this JS may be executed later, after document.currentScript\n      // is gone, so we saved it, and we use it here instead of any other info.\n\n\n      if (_scriptDir) {\n        scriptDirectory = _scriptDir;\n      } // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.\n      // otherwise, slice off the final part of the url to find the script directory.\n      // if scriptDirectory does not contain a slash, lastIndexOf will return -1,\n      // and scriptDirectory will correctly be replaced with an empty string.\n\n\n      if (scriptDirectory.indexOf('blob:') !== 0) {\n        scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf('/') + 1);\n      } else {\n        scriptDirectory = '';\n      }\n\n      Module['read'] = function shell_read(url) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', url, false);\n        xhr.send(null);\n        return xhr.responseText;\n      };\n\n      if (ENVIRONMENT_IS_WORKER) {\n        Module['readBinary'] = function readBinary(url) {\n          var xhr = new XMLHttpRequest();\n          xhr.open('GET', url, false);\n          xhr.responseType = 'arraybuffer';\n          xhr.send(null);\n          return new Uint8Array(xhr.response);\n        };\n      }\n\n      Module['readAsync'] = function readAsync(url, onload, onerror) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', url, true);\n        xhr.responseType = 'arraybuffer';\n\n        xhr.onload = function xhr_onload() {\n          if (xhr.status == 200 || xhr.status == 0 && xhr.response) {\n            // file URLs can return 0\n            onload(xhr.response);\n            return;\n          }\n\n          onerror();\n        };\n\n        xhr.onerror = onerror;\n        xhr.send(null);\n      };\n\n      Module['setWindowTitle'] = function (title) {\n        document.title = title;\n      };\n    } else {\n      throw new Error('environment detection error');\n    } // Set up the out() and err() hooks, which are how we can print to stdout or\n    // stderr, respectively.\n    // If the user provided Module.print or printErr, use that. Otherwise,\n    // console.log is checked first, as 'print' on the web will open a print dialogue\n    // printErr is preferable to console.warn (works better in shells)\n    // bind(console) is necessary to fix IE/Edge closed dev tools panel behavior.\n\n\n    var out = Module['print'] || (typeof console !== 'undefined' ? console.log.bind(console) : typeof print !== 'undefined' ? print : null);\n    var err = Module['printErr'] || (typeof printErr !== 'undefined' ? printErr : typeof console !== 'undefined' && console.warn.bind(console) || out); // Merge back in the overrides\n\n    for (key in moduleOverrides) {\n      if (moduleOverrides.hasOwnProperty(key)) {\n        Module[key] = moduleOverrides[key];\n      }\n    } // Free the object hierarchy contained in the overrides, this lets the GC\n    // reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.\n\n\n    moduleOverrides = undefined; // perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message\n\n    assert(typeof Module['memoryInitializerPrefixURL'] === 'undefined', 'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead');\n    assert(typeof Module['pthreadMainPrefixURL'] === 'undefined', 'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead');\n    assert(typeof Module['cdInitializerPrefixURL'] === 'undefined', 'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead');\n    assert(typeof Module['filePackagePrefixURL'] === 'undefined', 'Module.filePackagePrefixURL option was removed, use Module.locateFile instead'); // Copyright 2017 The Emscripten Authors.  All rights reserved.\n    // Emscripten is available under two separate licenses, the MIT license and the\n    // University of Illinois/NCSA Open Source License.  Both these licenses can be\n    // found in the LICENSE file.\n    // {{PREAMBLE_ADDITIONS}}\n\n    var STACK_ALIGN = 16; // stack management, and other functionality that is provided by the compiled code,\n    // should not be used before it is ready\n\n    stackSave = stackRestore = stackAlloc = function () {\n      abort('cannot use the stack before compiled code is ready to run, and has provided stack access');\n    };\n\n    function staticAlloc(size) {\n      abort('staticAlloc is no longer available at runtime; instead, perform static allocations at compile time (using makeStaticAlloc)');\n    }\n\n    function dynamicAlloc(size) {\n      assert(DYNAMICTOP_PTR);\n      var ret = HEAP32[DYNAMICTOP_PTR >> 2];\n      var end = ret + size + 15 & -16;\n\n      if (end > _emscripten_get_heap_size()) {\n        abort('failure to dynamicAlloc - memory growth etc. is not supported there, call malloc/sbrk directly');\n      }\n\n      HEAP32[DYNAMICTOP_PTR >> 2] = end;\n      return ret;\n    }\n\n    function alignMemory(size, factor) {\n      if (!factor) factor = STACK_ALIGN; // stack alignment (16-byte) by default\n\n      return Math.ceil(size / factor) * factor;\n    }\n\n    function getNativeTypeSize(type) {\n      switch (type) {\n        case 'i1':\n        case 'i8':\n          return 1;\n\n        case 'i16':\n          return 2;\n\n        case 'i32':\n          return 4;\n\n        case 'i64':\n          return 8;\n\n        case 'float':\n          return 4;\n\n        case 'double':\n          return 8;\n\n        default:\n          {\n            if (type[type.length - 1] === '*') {\n              return 4; // A pointer\n            } else if (type[0] === 'i') {\n              var bits = parseInt(type.substr(1));\n              assert(bits % 8 === 0, 'getNativeTypeSize invalid bits ' + bits + ', type ' + type);\n              return bits / 8;\n            } else {\n              return 0;\n            }\n          }\n      }\n    }\n\n    function warnOnce(text) {\n      if (!warnOnce.shown) warnOnce.shown = {};\n\n      if (!warnOnce.shown[text]) {\n        warnOnce.shown[text] = 1;\n        err(text);\n      }\n    }\n\n    var asm2wasmImports = {\n      // special asm2wasm imports\n      \"f64-rem\": function (x, y) {\n        return x % y;\n      },\n      \"debugger\": function () {\n        debugger;\n      }\n    };\n    var jsCallStartIndex = 1;\n    var functionPointers = new Array(0); // Wraps a JS function as a wasm function with a given signature.\n    // In the future, we may get a WebAssembly.Function constructor. Until then,\n    // we create a wasm module that takes the JS function as an import with a given\n    // signature, and re-exports that as a wasm function.\n\n    function convertJsFunctionToWasm(func, sig) {\n      // The module is static, with the exception of the type section, which is\n      // generated based on the signature passed in.\n      var typeSection = [0x01, // id: section,\n      0x00, // length: 0 (placeholder)\n      0x01, // count: 1\n      0x60 // form: func\n      ];\n      var sigRet = sig.slice(0, 1);\n      var sigParam = sig.slice(1);\n      var typeCodes = {\n        'i': 0x7f,\n        // i32\n        'j': 0x7e,\n        // i64\n        'f': 0x7d,\n        // f32\n        'd': 0x7c // f64\n\n      }; // Parameters, length + signatures\n\n      typeSection.push(sigParam.length);\n\n      for (var i = 0; i < sigParam.length; ++i) {\n        typeSection.push(typeCodes[sigParam[i]]);\n      } // Return values, length + signatures\n      // With no multi-return in MVP, either 0 (void) or 1 (anything else)\n\n\n      if (sigRet == 'v') {\n        typeSection.push(0x00);\n      } else {\n        typeSection = typeSection.concat([0x01, typeCodes[sigRet]]);\n      } // Write the overall length of the type section back into the section header\n      // (excepting the 2 bytes for the section id and length)\n\n\n      typeSection[1] = typeSection.length - 2; // Rest of the module is static\n\n      var bytes = new Uint8Array([0x00, 0x61, 0x73, 0x6d, // magic (\"\\0asm\")\n      0x01, 0x00, 0x00, 0x00 // version: 1\n      ].concat(typeSection, [0x02, 0x07, // import section\n      // (import \"e\" \"f\" (func 0 (type 0)))\n      0x01, 0x01, 0x65, 0x01, 0x66, 0x00, 0x00, 0x07, 0x05, // export section\n      // (export \"f\" (func 0 (type 0)))\n      0x01, 0x01, 0x66, 0x00, 0x00])); // We can compile this wasm module synchronously because it is very small.\n      // This accepts an import (at \"e.f\"), that it reroutes to an export (at \"f\")\n\n      var module = new WebAssembly.Module(bytes);\n      var instance = new WebAssembly.Instance(module, {\n        e: {\n          f: func\n        }\n      });\n      var wrappedFunc = instance.exports.f;\n      return wrappedFunc;\n    } // Add a wasm function to the table.\n\n\n    function addFunctionWasm(func, sig) {\n      var table = wasmTable;\n      var ret = table.length; // Grow the table\n\n      try {\n        table.grow(1);\n      } catch (err) {\n        if (!err instanceof RangeError) {\n          throw err;\n        }\n\n        throw 'Unable to grow wasm table. Use a higher value for RESERVED_FUNCTION_POINTERS or set ALLOW_TABLE_GROWTH.';\n      } // Insert new element\n\n\n      try {\n        // Attempting to call this with JS function will cause of table.set() to fail\n        table.set(ret, func);\n      } catch (err) {\n        if (!err instanceof TypeError) {\n          throw err;\n        }\n\n        assert(typeof sig !== 'undefined', 'Missing signature argument to addFunction');\n        var wrapped = convertJsFunctionToWasm(func, sig);\n        table.set(ret, wrapped);\n      }\n\n      return ret;\n    }\n\n    function removeFunctionWasm(index) {} // TODO(sbc): Look into implementing this to allow re-using of table slots\n    // 'sig' parameter is required for the llvm backend but only when func is not\n    // already a WebAssembly function.\n\n\n    function addFunction(func, sig) {\n      var base = 0;\n\n      for (var i = base; i < base + 0; i++) {\n        if (!functionPointers[i]) {\n          functionPointers[i] = func;\n          return jsCallStartIndex + i;\n        }\n      }\n\n      throw 'Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS.';\n    }\n\n    function removeFunction(index) {\n      functionPointers[index - jsCallStartIndex] = null;\n    }\n\n    var funcWrappers = {};\n\n    function getFuncWrapper(func, sig) {\n      if (!func) return; // on null pointer, return undefined\n\n      assert(sig);\n\n      if (!funcWrappers[sig]) {\n        funcWrappers[sig] = {};\n      }\n\n      var sigCache = funcWrappers[sig];\n\n      if (!sigCache[func]) {\n        // optimize away arguments usage in common cases\n        if (sig.length === 1) {\n          sigCache[func] = function dynCall_wrapper() {\n            return dynCall(sig, func);\n          };\n        } else if (sig.length === 2) {\n          sigCache[func] = function dynCall_wrapper(arg) {\n            return dynCall(sig, func, [arg]);\n          };\n        } else {\n          // general case\n          sigCache[func] = function dynCall_wrapper() {\n            return dynCall(sig, func, Array.prototype.slice.call(arguments));\n          };\n        }\n      }\n\n      return sigCache[func];\n    }\n\n    function makeBigInt(low, high, unsigned) {\n      return unsigned ? +(low >>> 0) + +(high >>> 0) * 4294967296.0 : +(low >>> 0) + +(high | 0) * 4294967296.0;\n    }\n\n    function dynCall(sig, ptr, args) {\n      if (args && args.length) {\n        assert(args.length == sig.length - 1);\n        assert('dynCall_' + sig in Module, 'bad function pointer type - no table for sig \\'' + sig + '\\'');\n        return Module['dynCall_' + sig].apply(null, [ptr].concat(args));\n      } else {\n        assert(sig.length == 1);\n        assert('dynCall_' + sig in Module, 'bad function pointer type - no table for sig \\'' + sig + '\\'');\n        return Module['dynCall_' + sig].call(null, ptr);\n      }\n    }\n\n    var tempRet0 = 0;\n\n    var setTempRet0 = function (value) {\n      tempRet0 = value;\n    };\n\n    var getTempRet0 = function () {\n      return tempRet0;\n    };\n\n    function getCompilerSetting(name) {\n      throw 'You must build with -s RETAIN_COMPILER_SETTINGS=1 for getCompilerSetting or emscripten_get_compiler_setting to work';\n    }\n\n    var Runtime = {\n      // helpful errors\n      getTempRet0: function () {\n        abort('getTempRet0() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"');\n      },\n      staticAlloc: function () {\n        abort('staticAlloc() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"');\n      },\n      stackAlloc: function () {\n        abort('stackAlloc() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"');\n      }\n    }; // The address globals begin at. Very low in memory, for code size and optimization opportunities.\n    // Above 0 is static memory, starting with globals.\n    // Then the stack.\n    // Then 'dynamic' memory for sbrk.\n\n    var GLOBAL_BASE = 1024; // === Preamble library stuff ===\n    // Documentation for the public APIs defined in this file must be updated in:\n    //    site/source/docs/api_reference/preamble.js.rst\n    // A prebuilt local version of the documentation is available at:\n    //    site/build/text/docs/api_reference/preamble.js.txt\n    // You can also build docs locally as HTML or other formats in site/\n    // An online HTML version (which may be of a different version of Emscripten)\n    //    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\n\n    if (typeof WebAssembly !== 'object') {\n      abort('No WebAssembly support found. Build with -s WASM=0 to target JavaScript instead.');\n    } // In MINIMAL_RUNTIME, setValue() and getValue() are only available when building with safe heap enabled, for heap safety checking.\n    // In traditional runtime, setValue() and getValue() are always available (although their use is highly discouraged due to perf penalties)\n\n    /** @type {function(number, number, string, boolean=)} */\n\n\n    function setValue(ptr, value, type, noSafe) {\n      type = type || 'i8';\n      if (type.charAt(type.length - 1) === '*') type = 'i32'; // pointers are 32-bit\n\n      switch (type) {\n        case 'i1':\n          HEAP8[ptr >> 0] = value;\n          break;\n\n        case 'i8':\n          HEAP8[ptr >> 0] = value;\n          break;\n\n        case 'i16':\n          HEAP16[ptr >> 1] = value;\n          break;\n\n        case 'i32':\n          HEAP32[ptr >> 2] = value;\n          break;\n\n        case 'i64':\n          tempI64 = [value >>> 0, (tempDouble = value, +Math_abs(tempDouble) >= 1.0 ? tempDouble > 0.0 ? (Math_min(+Math_floor(tempDouble / 4294967296.0), 4294967295.0) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0) >>> 0 : 0)], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];\n          break;\n\n        case 'float':\n          HEAPF32[ptr >> 2] = value;\n          break;\n\n        case 'double':\n          HEAPF64[ptr >> 3] = value;\n          break;\n\n        default:\n          abort('invalid type for setValue: ' + type);\n      }\n    }\n    /** @type {function(number, string, boolean=)} */\n\n\n    function getValue(ptr, type, noSafe) {\n      type = type || 'i8';\n      if (type.charAt(type.length - 1) === '*') type = 'i32'; // pointers are 32-bit\n\n      switch (type) {\n        case 'i1':\n          return HEAP8[ptr >> 0];\n\n        case 'i8':\n          return HEAP8[ptr >> 0];\n\n        case 'i16':\n          return HEAP16[ptr >> 1];\n\n        case 'i32':\n          return HEAP32[ptr >> 2];\n\n        case 'i64':\n          return HEAP32[ptr >> 2];\n\n        case 'float':\n          return HEAPF32[ptr >> 2];\n\n        case 'double':\n          return HEAPF64[ptr >> 3];\n\n        default:\n          abort('invalid type for getValue: ' + type);\n      }\n\n      return null;\n    } // Wasm globals\n\n\n    var wasmMemory; // Potentially used for direct table calls.\n\n    var wasmTable; //========================================\n    // Runtime essentials\n    //========================================\n    // whether we are quitting the application. no code should run after this.\n    // set in exit() and abort()\n\n    var ABORT = false; // set by exit() and abort().  Passed to 'onExit' handler.\n    // NOTE: This is also used as the process return code code in shell environments\n    // but only when noExitRuntime is false.\n\n    var EXITSTATUS = 0;\n    /** @type {function(*, string=)} */\n\n    function assert(condition, text) {\n      if (!condition) {\n        abort('Assertion failed: ' + text);\n      }\n    } // Returns the C function with a specified identifier (for C++, you need to do manual name mangling)\n\n\n    function getCFunc(ident) {\n      var func = Module['_' + ident]; // closure exported function\n\n      assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');\n      return func;\n    } // C calling interface.\n\n\n    function ccall(ident, returnType, argTypes, args, opts) {\n      // For fast lookup of conversion functions\n      var toC = {\n        'string': function (str) {\n          var ret = 0;\n\n          if (str !== null && str !== undefined && str !== 0) {\n            // null string\n            // at most 4 bytes per UTF-8 code point, +1 for the trailing '\\0'\n            var len = (str.length << 2) + 1;\n            ret = stackAlloc(len);\n            stringToUTF8(str, ret, len);\n          }\n\n          return ret;\n        },\n        'array': function (arr) {\n          var ret = stackAlloc(arr.length);\n          writeArrayToMemory(arr, ret);\n          return ret;\n        }\n      };\n\n      function convertReturnValue(ret) {\n        if (returnType === 'string') return UTF8ToString(ret);\n        if (returnType === 'boolean') return Boolean(ret);\n        return ret;\n      }\n\n      var func = getCFunc(ident);\n      var cArgs = [];\n      var stack = 0;\n      assert(returnType !== 'array', 'Return type should not be \"array\".');\n\n      if (args) {\n        for (var i = 0; i < args.length; i++) {\n          var converter = toC[argTypes[i]];\n\n          if (converter) {\n            if (stack === 0) stack = stackSave();\n            cArgs[i] = converter(args[i]);\n          } else {\n            cArgs[i] = args[i];\n          }\n        }\n      }\n\n      var ret = func.apply(null, cArgs);\n      ret = convertReturnValue(ret);\n      if (stack !== 0) stackRestore(stack);\n      return ret;\n    }\n\n    function cwrap(ident, returnType, argTypes, opts) {\n      return function () {\n        return ccall(ident, returnType, argTypes, arguments, opts);\n      };\n    }\n\n    var ALLOC_NORMAL = 0; // Tries to use _malloc()\n\n    var ALLOC_STACK = 1; // Lives for the duration of the current function call\n\n    var ALLOC_DYNAMIC = 2; // Cannot be freed except through sbrk\n\n    var ALLOC_NONE = 3; // Do not allocate\n    // allocate(): This is for internal use. You can use it yourself as well, but the interface\n    //             is a little tricky (see docs right below). The reason is that it is optimized\n    //             for multiple syntaxes to save space in generated code. So you should\n    //             normally not use allocate(), and instead allocate memory using _malloc(),\n    //             initialize it with setValue(), and so forth.\n    // @slab: An array of data, or a number. If a number, then the size of the block to allocate,\n    //        in *bytes* (note that this is sometimes confusing: the next parameter does not\n    //        affect this!)\n    // @types: Either an array of types, one for each byte (or 0 if no type at that position),\n    //         or a single type which is used for the entire block. This only matters if there\n    //         is initial data - if @slab is a number, then this does not matter at all and is\n    //         ignored.\n    // @allocator: How to allocate memory, see ALLOC_*\n\n    /** @type {function((TypedArray|Array<number>|number), string, number, number=)} */\n\n    function allocate(slab, types, allocator, ptr) {\n      var zeroinit, size;\n\n      if (typeof slab === 'number') {\n        zeroinit = true;\n        size = slab;\n      } else {\n        zeroinit = false;\n        size = slab.length;\n      }\n\n      var singleType = typeof types === 'string' ? types : null;\n      var ret;\n\n      if (allocator == ALLOC_NONE) {\n        ret = ptr;\n      } else {\n        ret = [_malloc, stackAlloc, dynamicAlloc][allocator](Math.max(size, singleType ? 1 : types.length));\n      }\n\n      if (zeroinit) {\n        var stop;\n        ptr = ret;\n        assert((ret & 3) == 0);\n        stop = ret + (size & ~3);\n\n        for (; ptr < stop; ptr += 4) {\n          HEAP32[ptr >> 2] = 0;\n        }\n\n        stop = ret + size;\n\n        while (ptr < stop) {\n          HEAP8[ptr++ >> 0] = 0;\n        }\n\n        return ret;\n      }\n\n      if (singleType === 'i8') {\n        if (slab.subarray || slab.slice) {\n          HEAPU8.set(\n          /** @type {!Uint8Array} */\n          slab, ret);\n        } else {\n          HEAPU8.set(new Uint8Array(slab), ret);\n        }\n\n        return ret;\n      }\n\n      var i = 0,\n          type,\n          typeSize,\n          previousType;\n\n      while (i < size) {\n        var curr = slab[i];\n        type = singleType || types[i];\n\n        if (type === 0) {\n          i++;\n          continue;\n        }\n\n        assert(type, 'Must know what type to store in allocate!');\n        if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later\n\n        setValue(ret + i, curr, type); // no need to look up size unless type changes, so cache it\n\n        if (previousType !== type) {\n          typeSize = getNativeTypeSize(type);\n          previousType = type;\n        }\n\n        i += typeSize;\n      }\n\n      return ret;\n    } // Allocate memory during any stage of startup - static memory early on, dynamic memory later, malloc when ready\n\n\n    function getMemory(size) {\n      if (!runtimeInitialized) return dynamicAlloc(size);\n      return _malloc(size);\n    }\n    /** @type {function(number, number=)} */\n\n\n    function Pointer_stringify(ptr, length) {\n      abort(\"this function has been removed - you should use UTF8ToString(ptr, maxBytesToRead) instead!\");\n    } // Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns\n    // a copy of that string as a Javascript String object.\n\n\n    function AsciiToString(ptr) {\n      var str = '';\n\n      while (1) {\n        var ch = HEAPU8[ptr++ >> 0];\n        if (!ch) return str;\n        str += String.fromCharCode(ch);\n      }\n    } // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n    // null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.\n\n\n    function stringToAscii(str, outPtr) {\n      return writeAsciiToMemory(str, outPtr, false);\n    } // Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns\n    // a copy of that string as a Javascript String object.\n\n\n    var UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;\n    /**\n     * @param {number} idx\n     * @param {number=} maxBytesToRead\n     * @return {string}\n     */\n\n    function UTF8ArrayToString(u8Array, idx, maxBytesToRead) {\n      var endIdx = idx + maxBytesToRead;\n      var endPtr = idx; // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\n      // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\n      // (As a tiny code save trick, compare endPtr against endIdx using a negation, so that undefined means Infinity)\n\n      while (u8Array[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n\n      if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {\n        return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));\n      } else {\n        var str = ''; // If building with TextDecoder, we have already computed the string length above, so test loop end condition against that\n\n        while (idx < endPtr) {\n          // For UTF8 byte structure, see:\n          // http://en.wikipedia.org/wiki/UTF-8#Description\n          // https://www.ietf.org/rfc/rfc2279.txt\n          // https://tools.ietf.org/html/rfc3629\n          var u0 = u8Array[idx++];\n\n          if (!(u0 & 0x80)) {\n            str += String.fromCharCode(u0);\n            continue;\n          }\n\n          var u1 = u8Array[idx++] & 63;\n\n          if ((u0 & 0xE0) == 0xC0) {\n            str += String.fromCharCode((u0 & 31) << 6 | u1);\n            continue;\n          }\n\n          var u2 = u8Array[idx++] & 63;\n\n          if ((u0 & 0xF0) == 0xE0) {\n            u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n          } else {\n            if ((u0 & 0xF8) != 0xF0) warnOnce('Invalid UTF-8 leading byte 0x' + u0.toString(16) + ' encountered when deserializing a UTF-8 string on the asm.js/wasm heap to a JS string!');\n            u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | u8Array[idx++] & 63;\n          }\n\n          if (u0 < 0x10000) {\n            str += String.fromCharCode(u0);\n          } else {\n            var ch = u0 - 0x10000;\n            str += String.fromCharCode(0xD800 | ch >> 10, 0xDC00 | ch & 0x3FF);\n          }\n        }\n      }\n\n      return str;\n    } // Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns a\n    // copy of that string as a Javascript String object.\n    // maxBytesToRead: an optional length that specifies the maximum number of bytes to read. You can omit\n    //                 this parameter to scan the string until the first \\0 byte. If maxBytesToRead is\n    //                 passed, and the string at [ptr, ptr+maxBytesToReadr[ contains a null byte in the\n    //                 middle, then the string will cut short at that byte index (i.e. maxBytesToRead will\n    //                 not produce a string of exact length [ptr, ptr+maxBytesToRead[)\n    //                 N.B. mixing frequent uses of UTF8ToString() with and without maxBytesToRead may\n    //                 throw JS JIT optimizations off, so it is worth to consider consistently using one\n    //                 style or the other.\n\n    /**\n     * @param {number} ptr\n     * @param {number=} maxBytesToRead\n     * @return {string}\n     */\n\n\n    function UTF8ToString(ptr, maxBytesToRead) {\n      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';\n    } // Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',\n    // encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n    // Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n    // Parameters:\n    //   str: the Javascript string to copy.\n    //   outU8Array: the array to copy to. Each index in this array is assumed to be one 8-byte element.\n    //   outIdx: The starting offset in the array to begin the copying.\n    //   maxBytesToWrite: The maximum number of bytes this function can write to the array.\n    //                    This count should include the null terminator,\n    //                    i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.\n    //                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.\n    // Returns the number of bytes written, EXCLUDING the null terminator.\n\n\n    function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {\n      if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.\n        return 0;\n      var startIdx = outIdx;\n      var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\n\n      for (var i = 0; i < str.length; ++i) {\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n        // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629\n        var u = str.charCodeAt(i); // possibly a lead surrogate\n\n        if (u >= 0xD800 && u <= 0xDFFF) {\n          var u1 = str.charCodeAt(++i);\n          u = 0x10000 + ((u & 0x3FF) << 10) | u1 & 0x3FF;\n        }\n\n        if (u <= 0x7F) {\n          if (outIdx >= endIdx) break;\n          outU8Array[outIdx++] = u;\n        } else if (u <= 0x7FF) {\n          if (outIdx + 1 >= endIdx) break;\n          outU8Array[outIdx++] = 0xC0 | u >> 6;\n          outU8Array[outIdx++] = 0x80 | u & 63;\n        } else if (u <= 0xFFFF) {\n          if (outIdx + 2 >= endIdx) break;\n          outU8Array[outIdx++] = 0xE0 | u >> 12;\n          outU8Array[outIdx++] = 0x80 | u >> 6 & 63;\n          outU8Array[outIdx++] = 0x80 | u & 63;\n        } else {\n          if (outIdx + 3 >= endIdx) break;\n          if (u >= 0x200000) warnOnce('Invalid Unicode code point 0x' + u.toString(16) + ' encountered when serializing a JS string to an UTF-8 string on the asm.js/wasm heap! (Valid unicode code points should be in range 0-0x1FFFFF).');\n          outU8Array[outIdx++] = 0xF0 | u >> 18;\n          outU8Array[outIdx++] = 0x80 | u >> 12 & 63;\n          outU8Array[outIdx++] = 0x80 | u >> 6 & 63;\n          outU8Array[outIdx++] = 0x80 | u & 63;\n        }\n      } // Null-terminate the pointer to the buffer.\n\n\n      outU8Array[outIdx] = 0;\n      return outIdx - startIdx;\n    } // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n    // null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n    // Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n    // Returns the number of bytes written, EXCLUDING the null terminator.\n\n\n    function stringToUTF8(str, outPtr, maxBytesToWrite) {\n      assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\n      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n    } // Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.\n\n\n    function lengthBytesUTF8(str) {\n      var len = 0;\n\n      for (var i = 0; i < str.length; ++i) {\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n        var u = str.charCodeAt(i); // possibly a lead surrogate\n\n        if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | str.charCodeAt(++i) & 0x3FF;\n        if (u <= 0x7F) ++len;else if (u <= 0x7FF) len += 2;else if (u <= 0xFFFF) len += 3;else len += 4;\n      }\n\n      return len;\n    } // Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns\n    // a copy of that string as a Javascript String object.\n\n\n    var UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined;\n\n    function UTF16ToString(ptr) {\n      assert(ptr % 2 == 0, 'Pointer passed to UTF16ToString must be aligned to two bytes!');\n      var endPtr = ptr; // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\n      // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\n\n      var idx = endPtr >> 1;\n\n      while (HEAP16[idx]) ++idx;\n\n      endPtr = idx << 1;\n\n      if (endPtr - ptr > 32 && UTF16Decoder) {\n        return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\n      } else {\n        var i = 0;\n        var str = '';\n\n        while (1) {\n          var codeUnit = HEAP16[ptr + i * 2 >> 1];\n          if (codeUnit == 0) return str;\n          ++i; // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.\n\n          str += String.fromCharCode(codeUnit);\n        }\n      }\n    } // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n    // null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.\n    // Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.\n    // Parameters:\n    //   str: the Javascript string to copy.\n    //   outPtr: Byte address in Emscripten HEAP where to write the string to.\n    //   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n    //                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.\n    //                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.\n    // Returns the number of bytes written, EXCLUDING the null terminator.\n\n\n    function stringToUTF16(str, outPtr, maxBytesToWrite) {\n      assert(outPtr % 2 == 0, 'Pointer passed to stringToUTF16 must be aligned to two bytes!');\n      assert(typeof maxBytesToWrite == 'number', 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!'); // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n\n      if (maxBytesToWrite === undefined) {\n        maxBytesToWrite = 0x7FFFFFFF;\n      }\n\n      if (maxBytesToWrite < 2) return 0;\n      maxBytesToWrite -= 2; // Null terminator.\n\n      var startPtr = outPtr;\n      var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\n\n      for (var i = 0; i < numCharsToWrite; ++i) {\n        // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.\n        var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n\n        HEAP16[outPtr >> 1] = codeUnit;\n        outPtr += 2;\n      } // Null-terminate the pointer to the HEAP.\n\n\n      HEAP16[outPtr >> 1] = 0;\n      return outPtr - startPtr;\n    } // Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\n\n\n    function lengthBytesUTF16(str) {\n      return str.length * 2;\n    }\n\n    function UTF32ToString(ptr) {\n      assert(ptr % 4 == 0, 'Pointer passed to UTF32ToString must be aligned to four bytes!');\n      var i = 0;\n      var str = '';\n\n      while (1) {\n        var utf32 = HEAP32[ptr + i * 4 >> 2];\n        if (utf32 == 0) return str;\n        ++i; // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n\n        if (utf32 >= 0x10000) {\n          var ch = utf32 - 0x10000;\n          str += String.fromCharCode(0xD800 | ch >> 10, 0xDC00 | ch & 0x3FF);\n        } else {\n          str += String.fromCharCode(utf32);\n        }\n      }\n    } // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n    // null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.\n    // Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.\n    // Parameters:\n    //   str: the Javascript string to copy.\n    //   outPtr: Byte address in Emscripten HEAP where to write the string to.\n    //   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n    //                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.\n    //                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.\n    // Returns the number of bytes written, EXCLUDING the null terminator.\n\n\n    function stringToUTF32(str, outPtr, maxBytesToWrite) {\n      assert(outPtr % 4 == 0, 'Pointer passed to stringToUTF32 must be aligned to four bytes!');\n      assert(typeof maxBytesToWrite == 'number', 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!'); // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n\n      if (maxBytesToWrite === undefined) {\n        maxBytesToWrite = 0x7FFFFFFF;\n      }\n\n      if (maxBytesToWrite < 4) return 0;\n      var startPtr = outPtr;\n      var endPtr = startPtr + maxBytesToWrite - 4;\n\n      for (var i = 0; i < str.length; ++i) {\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n        var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n\n        if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {\n          var trailSurrogate = str.charCodeAt(++i);\n          codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | trailSurrogate & 0x3FF;\n        }\n\n        HEAP32[outPtr >> 2] = codeUnit;\n        outPtr += 4;\n        if (outPtr + 4 > endPtr) break;\n      } // Null-terminate the pointer to the HEAP.\n\n\n      HEAP32[outPtr >> 2] = 0;\n      return outPtr - startPtr;\n    } // Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\n\n\n    function lengthBytesUTF32(str) {\n      var len = 0;\n\n      for (var i = 0; i < str.length; ++i) {\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n        var codeUnit = str.charCodeAt(i);\n        if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.\n\n        len += 4;\n      }\n\n      return len;\n    } // Allocate heap space for a JS string, and write it there.\n    // It is the responsibility of the caller to free() that memory.\n\n\n    function allocateUTF8(str) {\n      var size = lengthBytesUTF8(str) + 1;\n\n      var ret = _malloc(size);\n\n      if (ret) stringToUTF8Array(str, HEAP8, ret, size);\n      return ret;\n    } // Allocate stack space for a JS string, and write it there.\n\n\n    function allocateUTF8OnStack(str) {\n      var size = lengthBytesUTF8(str) + 1;\n      var ret = stackAlloc(size);\n      stringToUTF8Array(str, HEAP8, ret, size);\n      return ret;\n    } // Deprecated: This function should not be called because it is unsafe and does not provide\n    // a maximum length limit of how many bytes it is allowed to write. Prefer calling the\n    // function stringToUTF8Array() instead, which takes in a maximum length that can be used\n    // to be secure from out of bounds writes.\n\n    /** @deprecated */\n\n\n    function writeStringToMemory(string, buffer, dontAddNull) {\n      warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');\n      var\n      /** @type {number} */\n      lastChar,\n      /** @type {number} */\n      end;\n\n      if (dontAddNull) {\n        // stringToUTF8Array always appends null. If we don't want to do that, remember the\n        // character that existed at the location where the null will be placed, and restore\n        // that after the write (below).\n        end = buffer + lengthBytesUTF8(string);\n        lastChar = HEAP8[end];\n      }\n\n      stringToUTF8(string, buffer, Infinity);\n      if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.\n    }\n\n    function writeArrayToMemory(array, buffer) {\n      assert(array.length >= 0, 'writeArrayToMemory array must have a length (should be an array or typed array)');\n      HEAP8.set(array, buffer);\n    }\n\n    function writeAsciiToMemory(str, buffer, dontAddNull) {\n      for (var i = 0; i < str.length; ++i) {\n        assert(str.charCodeAt(i) === str.charCodeAt(i) & 0xff);\n        HEAP8[buffer++ >> 0] = str.charCodeAt(i);\n      } // Null-terminate the pointer to the HEAP.\n\n\n      if (!dontAddNull) HEAP8[buffer >> 0] = 0;\n    }\n\n    function demangle(func) {\n      return func;\n    }\n\n    function demangleAll(text) {\n      var regex = /__Z[\\w\\d_]+/g;\n      return text.replace(regex, function (x) {\n        var y = demangle(x);\n        return x === y ? x : y + ' [' + x + ']';\n      });\n    }\n\n    function jsStackTrace() {\n      var err = new Error();\n\n      if (!err.stack) {\n        // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,\n        // so try that as a special-case.\n        try {\n          throw new Error(0);\n        } catch (e) {\n          err = e;\n        }\n\n        if (!err.stack) {\n          return '(no stack trace available)';\n        }\n      }\n\n      return err.stack.toString();\n    }\n\n    function stackTrace() {\n      var js = jsStackTrace();\n      if (Module['extraStackTrace']) js += '\\n' + Module['extraStackTrace']();\n      return demangleAll(js);\n    } // Memory management\n\n\n    var PAGE_SIZE = 16384;\n    var WASM_PAGE_SIZE = 65536;\n    var ASMJS_PAGE_SIZE = 16777216;\n\n    function alignUp(x, multiple) {\n      if (x % multiple > 0) {\n        x += multiple - x % multiple;\n      }\n\n      return x;\n    }\n\n    var HEAP,\n    /** @type {ArrayBuffer} */\n    buffer,\n    /** @type {Int8Array} */\n    HEAP8,\n    /** @type {Uint8Array} */\n    HEAPU8,\n    /** @type {Int16Array} */\n    HEAP16,\n    /** @type {Uint16Array} */\n    HEAPU16,\n    /** @type {Int32Array} */\n    HEAP32,\n    /** @type {Uint32Array} */\n    HEAPU32,\n    /** @type {Float32Array} */\n    HEAPF32,\n    /** @type {Float64Array} */\n    HEAPF64;\n\n    function updateGlobalBufferViews() {\n      Module['HEAP8'] = HEAP8 = new Int8Array(buffer);\n      Module['HEAP16'] = HEAP16 = new Int16Array(buffer);\n      Module['HEAP32'] = HEAP32 = new Int32Array(buffer);\n      Module['HEAPU8'] = HEAPU8 = new Uint8Array(buffer);\n      Module['HEAPU16'] = HEAPU16 = new Uint16Array(buffer);\n      Module['HEAPU32'] = HEAPU32 = new Uint32Array(buffer);\n      Module['HEAPF32'] = HEAPF32 = new Float32Array(buffer);\n      Module['HEAPF64'] = HEAPF64 = new Float64Array(buffer);\n    }\n\n    var STATIC_BASE = 1024,\n        STACK_BASE = 12528,\n        STACKTOP = STACK_BASE,\n        STACK_MAX = 5255408,\n        DYNAMIC_BASE = 5255408,\n        DYNAMICTOP_PTR = 12496;\n    assert(STACK_BASE % 16 === 0, 'stack must start aligned');\n    assert(DYNAMIC_BASE % 16 === 0, 'heap must start aligned');\n    var TOTAL_STACK = 5242880;\n    if (Module['TOTAL_STACK']) assert(TOTAL_STACK === Module['TOTAL_STACK'], 'the stack size can no longer be determined at runtime');\n    var INITIAL_TOTAL_MEMORY = Module['TOTAL_MEMORY'] || 16777216;\n    if (INITIAL_TOTAL_MEMORY < TOTAL_STACK) err('TOTAL_MEMORY should be larger than TOTAL_STACK, was ' + INITIAL_TOTAL_MEMORY + '! (TOTAL_STACK=' + TOTAL_STACK + ')'); // Initialize the runtime's memory\n    // check for full engine support (use string 'subarray' to avoid closure compiler confusion)\n\n    assert(typeof Int32Array !== 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray !== undefined && Int32Array.prototype.set !== undefined, 'JS engine does not provide full typed array support');\n\n    if (Module['wasmMemory']) {\n      wasmMemory = Module['wasmMemory'];\n    } else {\n      wasmMemory = new WebAssembly.Memory({\n        'initial': INITIAL_TOTAL_MEMORY / WASM_PAGE_SIZE\n      });\n    }\n\n    if (wasmMemory) {\n      buffer = wasmMemory.buffer;\n    } // If the user provides an incorrect length, just use that length instead rather than providing the user to\n    // specifically provide the memory length with Module['TOTAL_MEMORY'].\n\n\n    INITIAL_TOTAL_MEMORY = buffer.byteLength;\n    assert(INITIAL_TOTAL_MEMORY % WASM_PAGE_SIZE === 0);\n    updateGlobalBufferViews();\n    HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE; // Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.\n\n    function writeStackCookie() {\n      assert((STACK_MAX & 3) == 0);\n      HEAPU32[(STACK_MAX >> 2) - 1] = 0x02135467;\n      HEAPU32[(STACK_MAX >> 2) - 2] = 0x89BACDFE;\n    }\n\n    function checkStackCookie() {\n      var cookie1 = HEAPU32[(STACK_MAX >> 2) - 1];\n      var cookie2 = HEAPU32[(STACK_MAX >> 2) - 2];\n\n      if (cookie1 != 0x02135467 || cookie2 != 0x89BACDFE) {\n        abort('Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x02135467, but received 0x' + cookie2.toString(16) + ' ' + cookie1.toString(16));\n      } // Also test the global address 0 for integrity.\n      // We don't do this with ASan because ASan does its own checks for this.\n\n\n      if (HEAP32[0] !== 0x63736d65\n      /* 'emsc' */\n      ) abort('Runtime error: The application has corrupted its heap memory area (address zero)!');\n    }\n\n    function abortStackOverflow(allocSize) {\n      abort('Stack overflow! Attempted to allocate ' + allocSize + ' bytes on the stack, but stack has only ' + (STACK_MAX - stackSave() + allocSize) + ' bytes available!');\n    }\n\n    HEAP32[0] = 0x63736d65;\n    /* 'emsc' */\n    // Endianness check (note: assumes compiler arch was little-endian)\n\n    HEAP16[1] = 0x6373;\n    if (HEAPU8[2] !== 0x73 || HEAPU8[3] !== 0x63) throw 'Runtime error: expected the system to be little-endian!';\n\n    function callRuntimeCallbacks(callbacks) {\n      while (callbacks.length > 0) {\n        var callback = callbacks.shift();\n\n        if (typeof callback == 'function') {\n          callback();\n          continue;\n        }\n\n        var func = callback.func;\n\n        if (typeof func === 'number') {\n          if (callback.arg === undefined) {\n            Module['dynCall_v'](func);\n          } else {\n            Module['dynCall_vi'](func, callback.arg);\n          }\n        } else {\n          func(callback.arg === undefined ? null : callback.arg);\n        }\n      }\n    }\n\n    var __ATPRERUN__ = []; // functions called before the runtime is initialized\n\n    var __ATINIT__ = []; // functions called during startup\n\n    var __ATMAIN__ = []; // functions called when main() is to be run\n\n    var __ATEXIT__ = []; // functions called during shutdown\n\n    var __ATPOSTRUN__ = []; // functions called after the main() is called\n\n    var runtimeInitialized = false;\n    var runtimeExited = false;\n\n    function preRun() {\n      // compatibility - merge in anything from Module['preRun'] at this time\n      if (Module['preRun']) {\n        if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];\n\n        while (Module['preRun'].length) {\n          addOnPreRun(Module['preRun'].shift());\n        }\n      }\n\n      callRuntimeCallbacks(__ATPRERUN__);\n    }\n\n    function initRuntime() {\n      checkStackCookie();\n      assert(!runtimeInitialized);\n      runtimeInitialized = true;\n      callRuntimeCallbacks(__ATINIT__);\n    }\n\n    function preMain() {\n      checkStackCookie();\n      callRuntimeCallbacks(__ATMAIN__);\n    }\n\n    function exitRuntime() {\n      checkStackCookie();\n      runtimeExited = true;\n    }\n\n    function postRun() {\n      checkStackCookie(); // compatibility - merge in anything from Module['postRun'] at this time\n\n      if (Module['postRun']) {\n        if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];\n\n        while (Module['postRun'].length) {\n          addOnPostRun(Module['postRun'].shift());\n        }\n      }\n\n      callRuntimeCallbacks(__ATPOSTRUN__);\n    }\n\n    function addOnPreRun(cb) {\n      __ATPRERUN__.unshift(cb);\n    }\n\n    function addOnInit(cb) {\n      __ATINIT__.unshift(cb);\n    }\n\n    function addOnPreMain(cb) {\n      __ATMAIN__.unshift(cb);\n    }\n\n    function addOnExit(cb) {}\n\n    function addOnPostRun(cb) {\n      __ATPOSTRUN__.unshift(cb);\n    }\n\n    function unSign(value, bits, ignore) {\n      if (value >= 0) {\n        return value;\n      }\n\n      return bits <= 32 ? 2 * Math.abs(1 << bits - 1) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts\n      : Math.pow(2, bits) + value;\n    }\n\n    function reSign(value, bits, ignore) {\n      if (value <= 0) {\n        return value;\n      }\n\n      var half = bits <= 32 ? Math.abs(1 << bits - 1) // abs is needed if bits == 32\n      : Math.pow(2, bits - 1);\n\n      if (value >= half && (bits <= 32 || value > half)) {\n        // for huge values, we can hit the precision limit and always get true here. so don't do that\n        // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors\n        // TODO: In i64 mode 1, resign the two parts separately and safely\n        value = -2 * half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts\n      }\n\n      return value;\n    }\n\n    assert(Math.imul, 'This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\n    assert(Math.fround, 'This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\n    assert(Math.clz32, 'This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\n    assert(Math.trunc, 'This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\n    var Math_abs = Math.abs;\n    var Math_cos = Math.cos;\n    var Math_sin = Math.sin;\n    var Math_tan = Math.tan;\n    var Math_acos = Math.acos;\n    var Math_asin = Math.asin;\n    var Math_atan = Math.atan;\n    var Math_atan2 = Math.atan2;\n    var Math_exp = Math.exp;\n    var Math_log = Math.log;\n    var Math_sqrt = Math.sqrt;\n    var Math_ceil = Math.ceil;\n    var Math_floor = Math.floor;\n    var Math_pow = Math.pow;\n    var Math_imul = Math.imul;\n    var Math_fround = Math.fround;\n    var Math_round = Math.round;\n    var Math_min = Math.min;\n    var Math_max = Math.max;\n    var Math_clz32 = Math.clz32;\n    var Math_trunc = Math.trunc; // A counter of dependencies for calling run(). If we need to\n    // do asynchronous work before running, increment this and\n    // decrement it. Incrementing must happen in a place like\n    // Module.preRun (used by emcc to add file preloading).\n    // Note that you can add dependencies in preRun, even though\n    // it happens right before run - run will be postponed until\n    // the dependencies are met.\n\n    var runDependencies = 0;\n    var runDependencyWatcher = null;\n    var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\n\n    var runDependencyTracking = {};\n\n    function getUniqueRunDependency(id) {\n      var orig = id;\n\n      while (1) {\n        if (!runDependencyTracking[id]) return id;\n        id = orig + Math.random();\n      }\n\n      return id;\n    }\n\n    function addRunDependency(id) {\n      runDependencies++;\n\n      if (Module['monitorRunDependencies']) {\n        Module['monitorRunDependencies'](runDependencies);\n      }\n\n      if (id) {\n        assert(!runDependencyTracking[id]);\n        runDependencyTracking[id] = 1;\n\n        if (runDependencyWatcher === null && typeof setInterval !== 'undefined') {\n          // Check for missing dependencies every few seconds\n          runDependencyWatcher = setInterval(function () {\n            if (ABORT) {\n              clearInterval(runDependencyWatcher);\n              runDependencyWatcher = null;\n              return;\n            }\n\n            var shown = false;\n\n            for (var dep in runDependencyTracking) {\n              if (!shown) {\n                shown = true;\n                err('still waiting on run dependencies:');\n              }\n\n              err('dependency: ' + dep);\n            }\n\n            if (shown) {\n              err('(end of list)');\n            }\n          }, 10000);\n        }\n      } else {\n        err('warning: run dependency added without ID');\n      }\n    }\n\n    function removeRunDependency(id) {\n      runDependencies--;\n\n      if (Module['monitorRunDependencies']) {\n        Module['monitorRunDependencies'](runDependencies);\n      }\n\n      if (id) {\n        assert(runDependencyTracking[id]);\n        delete runDependencyTracking[id];\n      } else {\n        err('warning: run dependency removed without ID');\n      }\n\n      if (runDependencies == 0) {\n        if (runDependencyWatcher !== null) {\n          clearInterval(runDependencyWatcher);\n          runDependencyWatcher = null;\n        }\n\n        if (dependenciesFulfilled) {\n          var callback = dependenciesFulfilled;\n          dependenciesFulfilled = null;\n          callback(); // can add another dependenciesFulfilled\n        }\n      }\n    }\n\n    Module[\"preloadedImages\"] = {}; // maps url to image data\n\n    Module[\"preloadedAudios\"] = {}; // maps url to audio data\n\n    var memoryInitializer = null; // show errors on likely calls to FS when it was not included\n\n    var FS = {\n      error: function () {\n        abort('Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with  -s FORCE_FILESYSTEM=1');\n      },\n      init: function () {\n        FS.error();\n      },\n      createDataFile: function () {\n        FS.error();\n      },\n      createPreloadedFile: function () {\n        FS.error();\n      },\n      createLazyFile: function () {\n        FS.error();\n      },\n      open: function () {\n        FS.error();\n      },\n      mkdev: function () {\n        FS.error();\n      },\n      registerDevice: function () {\n        FS.error();\n      },\n      analyzePath: function () {\n        FS.error();\n      },\n      loadFilesFromDB: function () {\n        FS.error();\n      },\n      ErrnoError: function ErrnoError() {\n        FS.error();\n      }\n    };\n    Module['FS_createDataFile'] = FS.createDataFile;\n    Module['FS_createPreloadedFile'] = FS.createPreloadedFile; // Copyright 2017 The Emscripten Authors.  All rights reserved.\n    // Emscripten is available under two separate licenses, the MIT license and the\n    // University of Illinois/NCSA Open Source License.  Both these licenses can be\n    // found in the LICENSE file.\n    // Prefix of data URIs emitted by SINGLE_FILE and related options.\n\n    var dataURIPrefix = 'data:application/octet-stream;base64,'; // Indicates whether filename is a base64 data URI.\n\n    function isDataURI(filename) {\n      return String.prototype.startsWith ? filename.startsWith(dataURIPrefix) : filename.indexOf(dataURIPrefix) === 0;\n    }\n\n    var wasmBinaryFile = 'GradientCaptureCore.wasm';\n\n    if (!isDataURI(wasmBinaryFile)) {\n      wasmBinaryFile = locateFile(wasmBinaryFile);\n    }\n\n    function getBinary() {\n      try {\n        if (Module['wasmBinary']) {\n          return new Uint8Array(Module['wasmBinary']);\n        }\n\n        if (Module['readBinary']) {\n          return Module['readBinary'](wasmBinaryFile);\n        } else {\n          throw \"both async and sync fetching of the wasm failed\";\n        }\n      } catch (err) {\n        abort(err);\n      }\n    }\n\n    function getBinaryPromise() {\n      // if we don't have the binary yet, and have the Fetch api, use that\n      // in some environments, like Electron's render process, Fetch api may be present, but have a different context than expected, let's only use it on the Web\n      if (!Module['wasmBinary'] && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === 'function') {\n        if (window.location.protocol !== 'file:') {\n          return fetch(wasmBinaryFile, {\n            credentials: 'same-origin'\n          }).then(function (response) {\n            if (!response['ok']) {\n              throw \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\";\n            }\n\n            return response['arrayBuffer']();\n          }).catch(function () {\n            return getBinary();\n          });\n        } else {\n          return new Promise(resolve => {\n            Module['readAsync'](wasmBinaryFile, src => {\n              resolve(src);\n            });\n          });\n        }\n      } // Otherwise, getBinary should be able to get it synchronously\n\n\n      return new Promise(function (resolve, reject) {\n        resolve(getBinary());\n      });\n    } // Create the wasm instance.\n    // Receives the wasm imports, returns the exports.\n\n\n    function createWasm(env) {\n      // prepare imports\n      var info = {\n        'env': env,\n        'global': {\n          'NaN': NaN,\n          'Infinity': Infinity\n        },\n        'global.Math': Math,\n        'asm2wasm': asm2wasmImports\n      }; // Load the wasm module and create an instance of using native support in the JS engine.\n      // handle a generated wasm instance, receiving its exports and\n      // performing other necessary setup\n\n      function receiveInstance(instance, module) {\n        var exports = instance.exports;\n        Module['asm'] = exports;\n        removeRunDependency('wasm-instantiate');\n      }\n\n      addRunDependency('wasm-instantiate'); // Async compilation can be confusing when an error on the page overwrites Module\n      // (for example, if the order of elements is wrong, and the one defining Module is\n      // later), so we save Module and check it later.\n\n      var trueModule = Module;\n\n      function receiveInstantiatedSource(output) {\n        // 'output' is a WebAssemblyInstantiatedSource object which has both the module and instance.\n        // receiveInstance() will swap in the exports (to Module.asm) so they can be called\n        assert(Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');\n        trueModule = null; // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.\n        // When the regression is fixed, can restore the above USE_PTHREADS-enabled path.\n\n        receiveInstance(output['instance']);\n      }\n\n      function instantiateArrayBuffer(receiver) {\n        return getBinaryPromise().then(function (binary) {\n          return WebAssembly.instantiate(binary, info);\n        }).then(receiver, function (reason) {\n          err('failed to asynchronously prepare wasm: ' + reason);\n          abort(reason);\n        });\n      } // Prefer streaming instantiation if available.\n\n\n      function instantiateAsync() {\n        if (!Module['wasmBinary'] && typeof WebAssembly.instantiateStreaming === 'function' && !isDataURI(wasmBinaryFile) && typeof fetch === 'function' && window.location.protocol !== 'file:') {\n          fetch(wasmBinaryFile, {\n            credentials: 'same-origin'\n          }).then(function (response) {\n            return WebAssembly.instantiateStreaming(response, info).then(receiveInstantiatedSource, function (reason) {\n              // We expect the most common failure cause to be a bad MIME type for the binary,\n              // in which case falling back to ArrayBuffer instantiation should work.\n              err('wasm streaming compile failed: ' + reason);\n              err('falling back to ArrayBuffer instantiation');\n              instantiateArrayBuffer(receiveInstantiatedSource);\n            });\n          });\n        } else {\n          return instantiateArrayBuffer(receiveInstantiatedSource);\n        }\n      } // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\n      // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel\n      // to any other async startup actions they are performing.\n\n\n      if (Module['instantiateWasm']) {\n        try {\n          var exports = Module['instantiateWasm'](info, receiveInstance);\n          return exports;\n        } catch (e) {\n          err('Module.instantiateWasm callback failed with error: ' + e);\n          return false;\n        }\n      }\n\n      instantiateAsync();\n      return {}; // no exports yet; we'll fill them in later\n    } // Provide an \"asm.js function\" for the application, called to \"link\" the asm.js module. We instantiate\n    // the wasm module at that time, and it receives imports and provides exports and so forth, the app\n    // doesn't need to care that it is wasm or asm.js.\n\n\n    Module['asm'] = function (global, env, providedBuffer) {\n      // memory was already allocated (so js could use the buffer)\n      env['memory'] = wasmMemory; // import table\n\n      env['table'] = wasmTable = new WebAssembly.Table({\n        'initial': 3520,\n        'maximum': 3520,\n        'element': 'anyfunc'\n      }); // With the wasm backend __memory_base and __table_base and only needed for\n      // relocatable output.\n\n      env['__memory_base'] = 1024; // tell the memory segments where to place themselves\n      // table starts at 0 by default (even in dynamic linking, for the main module)\n\n      env['__table_base'] = 0;\n      var exports = createWasm(env);\n      assert(exports, 'binaryen setup failed (no wasm support?)');\n      return exports;\n    }; // Globals used by JS i64 conversions\n\n\n    var tempDouble;\n    var tempI64; // === Body ===\n\n    var ASM_CONSTS = []; // STATICTOP = STATIC_BASE + 11504;\n\n    /* global initializers */\n\n    __ATINIT__.push({\n      func: function () {\n        globalCtors();\n      }\n    });\n    /* no memory initializer */\n\n\n    var tempDoublePtr = 12512;\n    assert(tempDoublePtr % 8 == 0);\n\n    function copyTempFloat(ptr) {\n      // functions, because inlining this code increases code size too much\n      HEAP8[tempDoublePtr] = HEAP8[ptr];\n      HEAP8[tempDoublePtr + 1] = HEAP8[ptr + 1];\n      HEAP8[tempDoublePtr + 2] = HEAP8[ptr + 2];\n      HEAP8[tempDoublePtr + 3] = HEAP8[ptr + 3];\n    }\n\n    function copyTempDouble(ptr) {\n      HEAP8[tempDoublePtr] = HEAP8[ptr];\n      HEAP8[tempDoublePtr + 1] = HEAP8[ptr + 1];\n      HEAP8[tempDoublePtr + 2] = HEAP8[ptr + 2];\n      HEAP8[tempDoublePtr + 3] = HEAP8[ptr + 3];\n      HEAP8[tempDoublePtr + 4] = HEAP8[ptr + 4];\n      HEAP8[tempDoublePtr + 5] = HEAP8[ptr + 5];\n      HEAP8[tempDoublePtr + 6] = HEAP8[ptr + 6];\n      HEAP8[tempDoublePtr + 7] = HEAP8[ptr + 7];\n    } // {{PRE_LIBRARY}}\n\n\n    function ___cxa_allocate_exception(size) {\n      return _malloc(size);\n    }\n\n    var ___exception_infos = {};\n    var ___exception_caught = [];\n\n    function ___exception_addRef(ptr) {\n      if (!ptr) return;\n      var info = ___exception_infos[ptr];\n      info.refcount++;\n    }\n\n    function ___exception_deAdjust(adjusted) {\n      if (!adjusted || ___exception_infos[adjusted]) return adjusted;\n\n      for (var key in ___exception_infos) {\n        var ptr = +key; // the iteration key is a string, and if we throw this, it must be an integer as that is what we look for\n\n        var adj = ___exception_infos[ptr].adjusted;\n        var len = adj.length;\n\n        for (var i = 0; i < len; i++) {\n          if (adj[i] === adjusted) {\n            return ptr;\n          }\n        }\n      }\n\n      return adjusted;\n    }\n\n    function ___cxa_begin_catch(ptr) {\n      var info = ___exception_infos[ptr];\n\n      if (info && !info.caught) {\n        info.caught = true;\n        __ZSt18uncaught_exceptionv.uncaught_exception--;\n      }\n\n      if (info) info.rethrown = false;\n\n      ___exception_caught.push(ptr);\n\n      ___exception_addRef(___exception_deAdjust(ptr));\n\n      return ptr;\n    }\n\n    function ___cxa_pure_virtual() {\n      ABORT = true;\n      throw 'Pure virtual function called!';\n    }\n\n    var ___exception_last = 0;\n\n    function ___cxa_throw(ptr, type, destructor) {\n      ___exception_infos[ptr] = {\n        ptr: ptr,\n        adjusted: [ptr],\n        type: type,\n        destructor: destructor,\n        refcount: 0,\n        caught: false,\n        rethrown: false\n      };\n      ___exception_last = ptr;\n\n      if (!(\"uncaught_exception\" in __ZSt18uncaught_exceptionv)) {\n        __ZSt18uncaught_exceptionv.uncaught_exception = 1;\n      } else {\n        __ZSt18uncaught_exceptionv.uncaught_exception++;\n      }\n\n      throw ptr + \" - Exception catching is disabled, this exception cannot be caught. Compile with -s DISABLE_EXCEPTION_CATCHING=0 or DISABLE_EXCEPTION_CATCHING=2 to catch.\";\n    }\n\n    function ___cxa_uncaught_exception() {\n      return !!__ZSt18uncaught_exceptionv.uncaught_exception;\n    }\n\n    function ___gxx_personality_v0() {}\n\n    function ___lock() {}\n\n    var PATH = {\n      splitPath: function (filename) {\n        var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n        return splitPathRe.exec(filename).slice(1);\n      },\n      normalizeArray: function (parts, allowAboveRoot) {\n        // if the path tries to go above the root, `up` ends up > 0\n        var up = 0;\n\n        for (var i = parts.length - 1; i >= 0; i--) {\n          var last = parts[i];\n\n          if (last === '.') {\n            parts.splice(i, 1);\n          } else if (last === '..') {\n            parts.splice(i, 1);\n            up++;\n          } else if (up) {\n            parts.splice(i, 1);\n            up--;\n          }\n        } // if the path is allowed to go above the root, restore leading ..s\n\n\n        if (allowAboveRoot) {\n          for (; up; up--) {\n            parts.unshift('..');\n          }\n        }\n\n        return parts;\n      },\n      normalize: function (path) {\n        var isAbsolute = path.charAt(0) === '/',\n            trailingSlash = path.substr(-1) === '/'; // Normalize the path\n\n        path = PATH.normalizeArray(path.split('/').filter(function (p) {\n          return !!p;\n        }), !isAbsolute).join('/');\n\n        if (!path && !isAbsolute) {\n          path = '.';\n        }\n\n        if (path && trailingSlash) {\n          path += '/';\n        }\n\n        return (isAbsolute ? '/' : '') + path;\n      },\n      dirname: function (path) {\n        var result = PATH.splitPath(path),\n            root = result[0],\n            dir = result[1];\n\n        if (!root && !dir) {\n          // No dirname whatsoever\n          return '.';\n        }\n\n        if (dir) {\n          // It has a dirname, strip trailing slash\n          dir = dir.substr(0, dir.length - 1);\n        }\n\n        return root + dir;\n      },\n      basename: function (path) {\n        // EMSCRIPTEN return '/'' for '/', not an empty string\n        if (path === '/') return '/';\n        var lastSlash = path.lastIndexOf('/');\n        if (lastSlash === -1) return path;\n        return path.substr(lastSlash + 1);\n      },\n      extname: function (path) {\n        return PATH.splitPath(path)[3];\n      },\n      join: function () {\n        var paths = Array.prototype.slice.call(arguments, 0);\n        return PATH.normalize(paths.join('/'));\n      },\n      join2: function (l, r) {\n        return PATH.normalize(l + '/' + r);\n      }\n    };\n    var SYSCALLS = {\n      buffers: [null, [], []],\n      printChar: function (stream, curr) {\n        var buffer = SYSCALLS.buffers[stream];\n        assert(buffer);\n\n        if (curr === 0 || curr === 10) {\n          (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));\n          buffer.length = 0;\n        } else {\n          buffer.push(curr);\n        }\n      },\n      varargs: 0,\n      get: function (varargs) {\n        SYSCALLS.varargs += 4;\n        var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];\n        return ret;\n      },\n      getStr: function () {\n        var ret = UTF8ToString(SYSCALLS.get());\n        return ret;\n      },\n      get64: function () {\n        var low = SYSCALLS.get(),\n            high = SYSCALLS.get();\n        if (low >= 0) assert(high === 0);else assert(high === -1);\n        return low;\n      },\n      getZero: function () {\n        assert(SYSCALLS.get() === 0);\n      }\n    };\n\n    function ___syscall140(which, varargs) {\n      SYSCALLS.varargs = varargs;\n\n      try {\n        // llseek\n        var stream = SYSCALLS.getStreamFromFD(),\n            offset_high = SYSCALLS.get(),\n            offset_low = SYSCALLS.get(),\n            result = SYSCALLS.get(),\n            whence = SYSCALLS.get();\n        abort('it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM');\n        return 0;\n      } catch (e) {\n        if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n        return -e.errno;\n      }\n    }\n\n    function flush_NO_FILESYSTEM() {\n      // flush anything remaining in the buffers during shutdown\n      var fflush = Module[\"_fflush\"];\n      if (fflush) fflush(0);\n      var buffers = SYSCALLS.buffers;\n      if (buffers[1].length) SYSCALLS.printChar(1, 10);\n      if (buffers[2].length) SYSCALLS.printChar(2, 10);\n    }\n\n    function ___syscall146(which, varargs) {\n      SYSCALLS.varargs = varargs;\n\n      try {\n        // writev\n        // hack to support printf in SYSCALLS_REQUIRE_FILESYSTEM=0\n        var stream = SYSCALLS.get(),\n            iov = SYSCALLS.get(),\n            iovcnt = SYSCALLS.get();\n        var ret = 0;\n\n        for (var i = 0; i < iovcnt; i++) {\n          var ptr = HEAP32[iov + i * 8 >> 2];\n          var len = HEAP32[iov + (i * 8 + 4) >> 2];\n\n          for (var j = 0; j < len; j++) {\n            SYSCALLS.printChar(stream, HEAPU8[ptr + j]);\n          }\n\n          ret += len;\n        }\n\n        return ret;\n      } catch (e) {\n        if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n        return -e.errno;\n      }\n    }\n\n    function ___syscall54(which, varargs) {\n      SYSCALLS.varargs = varargs;\n\n      try {\n        // ioctl\n        return 0;\n      } catch (e) {\n        if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n        return -e.errno;\n      }\n    }\n\n    function ___syscall6(which, varargs) {\n      SYSCALLS.varargs = varargs;\n\n      try {\n        // close\n        var stream = SYSCALLS.getStreamFromFD();\n        abort('it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM');\n        return 0;\n      } catch (e) {\n        if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n        return -e.errno;\n      }\n    }\n\n    function ___unlock() {}\n\n    function getShiftFromSize(size) {\n      switch (size) {\n        case 1:\n          return 0;\n\n        case 2:\n          return 1;\n\n        case 4:\n          return 2;\n\n        case 8:\n          return 3;\n\n        default:\n          throw new TypeError('Unknown type size: ' + size);\n      }\n    }\n\n    function embind_init_charCodes() {\n      var codes = new Array(256);\n\n      for (var i = 0; i < 256; ++i) {\n        codes[i] = String.fromCharCode(i);\n      }\n\n      embind_charCodes = codes;\n    }\n\n    var embind_charCodes = undefined;\n\n    function readLatin1String(ptr) {\n      var ret = \"\";\n      var c = ptr;\n\n      while (HEAPU8[c]) {\n        ret += embind_charCodes[HEAPU8[c++]];\n      }\n\n      return ret;\n    }\n\n    var awaitingDependencies = {};\n    var registeredTypes = {};\n    var typeDependencies = {};\n    var char_0 = 48;\n    var char_9 = 57;\n\n    function makeLegalFunctionName(name) {\n      if (undefined === name) {\n        return '_unknown';\n      }\n\n      name = name.replace(/[^a-zA-Z0-9_]/g, '$');\n      var f = name.charCodeAt(0);\n\n      if (f >= char_0 && f <= char_9) {\n        return '_' + name;\n      } else {\n        return name;\n      }\n    }\n\n    function createNamedFunction(name, body) {\n      name = makeLegalFunctionName(name);\n      return function () {\n        \"use strict\";\n\n        return body.apply(this, arguments);\n      };\n    }\n\n    function extendError(baseErrorType, errorName) {\n      var errorClass = createNamedFunction(errorName, function (message) {\n        this.name = errorName;\n        this.message = message;\n        var stack = new Error(message).stack;\n\n        if (stack !== undefined) {\n          this.stack = this.toString() + '\\n' + stack.replace(/^Error(:[^\\n]*)?\\n/, '');\n        }\n      });\n      errorClass.prototype = Object.create(baseErrorType.prototype);\n      errorClass.prototype.constructor = errorClass;\n\n      errorClass.prototype.toString = function () {\n        if (this.message === undefined) {\n          return this.name;\n        } else {\n          return this.name + ': ' + this.message;\n        }\n      };\n\n      return errorClass;\n    }\n\n    var BindingError = undefined;\n\n    function throwBindingError(message) {\n      throw new BindingError(message);\n    }\n\n    var InternalError = undefined;\n\n    function throwInternalError(message) {\n      throw new InternalError(message);\n    }\n\n    function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {\n      myTypes.forEach(function (type) {\n        typeDependencies[type] = dependentTypes;\n      });\n\n      function onComplete(typeConverters) {\n        var myTypeConverters = getTypeConverters(typeConverters);\n\n        if (myTypeConverters.length !== myTypes.length) {\n          throwInternalError('Mismatched type converter count');\n        }\n\n        for (var i = 0; i < myTypes.length; ++i) {\n          registerType(myTypes[i], myTypeConverters[i]);\n        }\n      }\n\n      var typeConverters = new Array(dependentTypes.length);\n      var unregisteredTypes = [];\n      var registered = 0;\n      dependentTypes.forEach(function (dt, i) {\n        if (registeredTypes.hasOwnProperty(dt)) {\n          typeConverters[i] = registeredTypes[dt];\n        } else {\n          unregisteredTypes.push(dt);\n\n          if (!awaitingDependencies.hasOwnProperty(dt)) {\n            awaitingDependencies[dt] = [];\n          }\n\n          awaitingDependencies[dt].push(function () {\n            typeConverters[i] = registeredTypes[dt];\n            ++registered;\n\n            if (registered === unregisteredTypes.length) {\n              onComplete(typeConverters);\n            }\n          });\n        }\n      });\n\n      if (0 === unregisteredTypes.length) {\n        onComplete(typeConverters);\n      }\n    }\n\n    function registerType(rawType, registeredInstance, options) {\n      options = options || {};\n\n      if (!('argPackAdvance' in registeredInstance)) {\n        throw new TypeError('registerType registeredInstance requires argPackAdvance');\n      }\n\n      var name = registeredInstance.name;\n\n      if (!rawType) {\n        throwBindingError('type \"' + name + '\" must have a positive integer typeid pointer');\n      }\n\n      if (registeredTypes.hasOwnProperty(rawType)) {\n        if (options.ignoreDuplicateRegistrations) {\n          return;\n        } else {\n          throwBindingError(\"Cannot register type '\" + name + \"' twice\");\n        }\n      }\n\n      registeredTypes[rawType] = registeredInstance;\n      delete typeDependencies[rawType];\n\n      if (awaitingDependencies.hasOwnProperty(rawType)) {\n        var callbacks = awaitingDependencies[rawType];\n        delete awaitingDependencies[rawType];\n        callbacks.forEach(function (cb) {\n          cb();\n        });\n      }\n    }\n\n    function __embind_register_bool(rawType, name, size, trueValue, falseValue) {\n      var shift = getShiftFromSize(size);\n      name = readLatin1String(name);\n      registerType(rawType, {\n        name: name,\n        'fromWireType': function (wt) {\n          // ambiguous emscripten ABI: sometimes return values are\n          // true or false, and sometimes integers (0 or 1)\n          return !!wt;\n        },\n        'toWireType': function (destructors, o) {\n          return o ? trueValue : falseValue;\n        },\n        'argPackAdvance': 8,\n        'readValueFromPointer': function (pointer) {\n          // TODO: if heap is fixed (like in asm.js) this could be executed outside\n          var heap;\n\n          if (size === 1) {\n            heap = HEAP8;\n          } else if (size === 2) {\n            heap = HEAP16;\n          } else if (size === 4) {\n            heap = HEAP32;\n          } else {\n            throw new TypeError(\"Unknown boolean type size: \" + name);\n          }\n\n          return this['fromWireType'](heap[pointer >> shift]);\n        },\n        destructorFunction: null // This type does not need a destructor\n\n      });\n    }\n\n    function ClassHandle_isAliasOf(other) {\n      if (!(this instanceof ClassHandle)) {\n        return false;\n      }\n\n      if (!(other instanceof ClassHandle)) {\n        return false;\n      }\n\n      var leftClass = this.$$.ptrType.registeredClass;\n      var left = this.$$.ptr;\n      var rightClass = other.$$.ptrType.registeredClass;\n      var right = other.$$.ptr;\n\n      while (leftClass.baseClass) {\n        left = leftClass.upcast(left);\n        leftClass = leftClass.baseClass;\n      }\n\n      while (rightClass.baseClass) {\n        right = rightClass.upcast(right);\n        rightClass = rightClass.baseClass;\n      }\n\n      return leftClass === rightClass && left === right;\n    }\n\n    function shallowCopyInternalPointer(o) {\n      return {\n        count: o.count,\n        deleteScheduled: o.deleteScheduled,\n        preservePointerOnDelete: o.preservePointerOnDelete,\n        ptr: o.ptr,\n        ptrType: o.ptrType,\n        smartPtr: o.smartPtr,\n        smartPtrType: o.smartPtrType\n      };\n    }\n\n    function throwInstanceAlreadyDeleted(obj) {\n      function getInstanceTypeName(handle) {\n        return handle.$$.ptrType.registeredClass.name;\n      }\n\n      throwBindingError(getInstanceTypeName(obj) + ' instance already deleted');\n    }\n\n    var finalizationGroup = false;\n\n    function detachFinalizer(handle) {}\n\n    function runDestructor($$) {\n      if ($$.smartPtr) {\n        $$.smartPtrType.rawDestructor($$.smartPtr);\n      } else {\n        $$.ptrType.registeredClass.rawDestructor($$.ptr);\n      }\n    }\n\n    function releaseClassHandle($$) {\n      $$.count.value -= 1;\n      var toDelete = 0 === $$.count.value;\n\n      if (toDelete) {\n        runDestructor($$);\n      }\n    }\n\n    function attachFinalizer(handle) {\n      if ('undefined' === typeof FinalizationGroup) {\n        attachFinalizer = function (handle) {\n          return handle;\n        };\n\n        return handle;\n      } // If the running environment has a FinalizationGroup (see\n      // https://github.com/tc39/proposal-weakrefs), then attach finalizers\n      // for class handles.  We check for the presence of FinalizationGroup\n      // at run-time, not build-time.\n\n\n      finalizationGroup = new FinalizationGroup(function (iter) {\n        for (var result = iter.next(); !result.done; result = iter.next()) {\n          var $$ = result.value;\n\n          if (!$$.ptr) {\n            console.warn('object already deleted: ' + $$.ptr);\n          } else {\n            releaseClassHandle($$);\n          }\n        }\n      });\n\n      attachFinalizer = function (handle) {\n        finalizationGroup.register(handle, handle.$$, handle.$$);\n        return handle;\n      };\n\n      detachFinalizer = function (handle) {\n        finalizationGroup.unregister(handle.$$);\n      };\n\n      return attachFinalizer(handle);\n    }\n\n    function ClassHandle_clone() {\n      if (!this.$$.ptr) {\n        throwInstanceAlreadyDeleted(this);\n      }\n\n      if (this.$$.preservePointerOnDelete) {\n        this.$$.count.value += 1;\n        return this;\n      } else {\n        var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {\n          $$: {\n            value: shallowCopyInternalPointer(this.$$)\n          }\n        }));\n        clone.$$.count.value += 1;\n        clone.$$.deleteScheduled = false;\n        return clone;\n      }\n    }\n\n    function ClassHandle_delete() {\n      if (!this.$$.ptr) {\n        throwInstanceAlreadyDeleted(this);\n      }\n\n      if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\n        throwBindingError('Object already scheduled for deletion');\n      }\n\n      detachFinalizer(this);\n      releaseClassHandle(this.$$);\n\n      if (!this.$$.preservePointerOnDelete) {\n        this.$$.smartPtr = undefined;\n        this.$$.ptr = undefined;\n      }\n    }\n\n    function ClassHandle_isDeleted() {\n      return !this.$$.ptr;\n    }\n\n    var delayFunction = undefined;\n    var deletionQueue = [];\n\n    function flushPendingDeletes() {\n      while (deletionQueue.length) {\n        var obj = deletionQueue.pop();\n        obj.$$.deleteScheduled = false;\n        obj['delete']();\n      }\n    }\n\n    function ClassHandle_deleteLater() {\n      if (!this.$$.ptr) {\n        throwInstanceAlreadyDeleted(this);\n      }\n\n      if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\n        throwBindingError('Object already scheduled for deletion');\n      }\n\n      deletionQueue.push(this);\n\n      if (deletionQueue.length === 1 && delayFunction) {\n        delayFunction(flushPendingDeletes);\n      }\n\n      this.$$.deleteScheduled = true;\n      return this;\n    }\n\n    function init_ClassHandle() {\n      ClassHandle.prototype['isAliasOf'] = ClassHandle_isAliasOf;\n      ClassHandle.prototype['clone'] = ClassHandle_clone;\n      ClassHandle.prototype['delete'] = ClassHandle_delete;\n      ClassHandle.prototype['isDeleted'] = ClassHandle_isDeleted;\n      ClassHandle.prototype['deleteLater'] = ClassHandle_deleteLater;\n    }\n\n    function ClassHandle() {}\n\n    var registeredPointers = {};\n\n    function ensureOverloadTable(proto, methodName, humanName) {\n      if (undefined === proto[methodName].overloadTable) {\n        var prevFunc = proto[methodName]; // Inject an overload resolver function that routes to the appropriate overload based on the number of arguments.\n\n        proto[methodName] = function () {\n          // TODO This check can be removed in -O3 level \"unsafe\" optimizations.\n          if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {\n            throwBindingError(\"Function '\" + humanName + \"' called with an invalid number of arguments (\" + arguments.length + \") - expects one of (\" + proto[methodName].overloadTable + \")!\");\n          }\n\n          return proto[methodName].overloadTable[arguments.length].apply(this, arguments);\n        }; // Move the previous function into the overload table.\n\n\n        proto[methodName].overloadTable = [];\n        proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;\n      }\n    }\n\n    function exposePublicSymbol(name, value, numArguments) {\n      if (Module.hasOwnProperty(name)) {\n        if (undefined === numArguments || undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments]) {\n          throwBindingError(\"Cannot register public name '\" + name + \"' twice\");\n        } // We are exposing a function with the same name as an existing function. Create an overload table and a function selector\n        // that routes between the two.\n\n\n        ensureOverloadTable(Module, name, name);\n\n        if (Module.hasOwnProperty(numArguments)) {\n          throwBindingError(\"Cannot register multiple overloads of a function with the same number of arguments (\" + numArguments + \")!\");\n        } // Add the new function into the overload table.\n\n\n        Module[name].overloadTable[numArguments] = value;\n      } else {\n        Module[name] = value;\n\n        if (undefined !== numArguments) {\n          Module[name].numArguments = numArguments;\n        }\n      }\n    }\n\n    function RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {\n      this.name = name;\n      this.constructor = constructor;\n      this.instancePrototype = instancePrototype;\n      this.rawDestructor = rawDestructor;\n      this.baseClass = baseClass;\n      this.getActualType = getActualType;\n      this.upcast = upcast;\n      this.downcast = downcast;\n      this.pureVirtualFunctions = [];\n    }\n\n    function upcastPointer(ptr, ptrClass, desiredClass) {\n      while (ptrClass !== desiredClass) {\n        if (!ptrClass.upcast) {\n          throwBindingError(\"Expected null or instance of \" + desiredClass.name + \", got an instance of \" + ptrClass.name);\n        }\n\n        ptr = ptrClass.upcast(ptr);\n        ptrClass = ptrClass.baseClass;\n      }\n\n      return ptr;\n    }\n\n    function constNoSmartPtrRawPointerToWireType(destructors, handle) {\n      if (handle === null) {\n        if (this.isReference) {\n          throwBindingError('null is not a valid ' + this.name);\n        }\n\n        return 0;\n      }\n\n      if (!handle.$$) {\n        throwBindingError('Cannot pass \"' + _embind_repr(handle) + '\" as a ' + this.name);\n      }\n\n      if (!handle.$$.ptr) {\n        throwBindingError('Cannot pass deleted object as a pointer of type ' + this.name);\n      }\n\n      var handleClass = handle.$$.ptrType.registeredClass;\n      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n      return ptr;\n    }\n\n    function genericPointerToWireType(destructors, handle) {\n      var ptr;\n\n      if (handle === null) {\n        if (this.isReference) {\n          throwBindingError('null is not a valid ' + this.name);\n        }\n\n        if (this.isSmartPointer) {\n          ptr = this.rawConstructor();\n\n          if (destructors !== null) {\n            destructors.push(this.rawDestructor, ptr);\n          }\n\n          return ptr;\n        } else {\n          return 0;\n        }\n      }\n\n      if (!handle.$$) {\n        throwBindingError('Cannot pass \"' + _embind_repr(handle) + '\" as a ' + this.name);\n      }\n\n      if (!handle.$$.ptr) {\n        throwBindingError('Cannot pass deleted object as a pointer of type ' + this.name);\n      }\n\n      if (!this.isConst && handle.$$.ptrType.isConst) {\n        throwBindingError('Cannot convert argument of type ' + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + ' to parameter type ' + this.name);\n      }\n\n      var handleClass = handle.$$.ptrType.registeredClass;\n      ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n\n      if (this.isSmartPointer) {\n        // TODO: this is not strictly true\n        // We could support BY_EMVAL conversions from raw pointers to smart pointers\n        // because the smart pointer can hold a reference to the handle\n        if (undefined === handle.$$.smartPtr) {\n          throwBindingError('Passing raw pointer to smart pointer is illegal');\n        }\n\n        switch (this.sharingPolicy) {\n          case 0:\n            // NONE\n            // no upcasting\n            if (handle.$$.smartPtrType === this) {\n              ptr = handle.$$.smartPtr;\n            } else {\n              throwBindingError('Cannot convert argument of type ' + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + ' to parameter type ' + this.name);\n            }\n\n            break;\n\n          case 1:\n            // INTRUSIVE\n            ptr = handle.$$.smartPtr;\n            break;\n\n          case 2:\n            // BY_EMVAL\n            if (handle.$$.smartPtrType === this) {\n              ptr = handle.$$.smartPtr;\n            } else {\n              var clonedHandle = handle['clone']();\n              ptr = this.rawShare(ptr, __emval_register(function () {\n                clonedHandle['delete']();\n              }));\n\n              if (destructors !== null) {\n                destructors.push(this.rawDestructor, ptr);\n              }\n            }\n\n            break;\n\n          default:\n            throwBindingError('Unsupporting sharing policy');\n        }\n      }\n\n      return ptr;\n    }\n\n    function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {\n      if (handle === null) {\n        if (this.isReference) {\n          throwBindingError('null is not a valid ' + this.name);\n        }\n\n        return 0;\n      }\n\n      if (!handle.$$) {\n        throwBindingError('Cannot pass \"' + _embind_repr(handle) + '\" as a ' + this.name);\n      }\n\n      if (!handle.$$.ptr) {\n        throwBindingError('Cannot pass deleted object as a pointer of type ' + this.name);\n      }\n\n      if (handle.$$.ptrType.isConst) {\n        throwBindingError('Cannot convert argument of type ' + handle.$$.ptrType.name + ' to parameter type ' + this.name);\n      }\n\n      var handleClass = handle.$$.ptrType.registeredClass;\n      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n      return ptr;\n    }\n\n    function simpleReadValueFromPointer(pointer) {\n      return this['fromWireType'](HEAPU32[pointer >> 2]);\n    }\n\n    function RegisteredPointer_getPointee(ptr) {\n      if (this.rawGetPointee) {\n        ptr = this.rawGetPointee(ptr);\n      }\n\n      return ptr;\n    }\n\n    function RegisteredPointer_destructor(ptr) {\n      if (this.rawDestructor) {\n        this.rawDestructor(ptr);\n      }\n    }\n\n    function RegisteredPointer_deleteObject(handle) {\n      if (handle !== null) {\n        handle['delete']();\n      }\n    }\n\n    function downcastPointer(ptr, ptrClass, desiredClass) {\n      if (ptrClass === desiredClass) {\n        return ptr;\n      }\n\n      if (undefined === desiredClass.baseClass) {\n        return null; // no conversion\n      }\n\n      var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);\n\n      if (rv === null) {\n        return null;\n      }\n\n      return desiredClass.downcast(rv);\n    }\n\n    function getInheritedInstanceCount() {\n      return Object.keys(registeredInstances).length;\n    }\n\n    function getLiveInheritedInstances() {\n      var rv = [];\n\n      for (var k in registeredInstances) {\n        if (registeredInstances.hasOwnProperty(k)) {\n          rv.push(registeredInstances[k]);\n        }\n      }\n\n      return rv;\n    }\n\n    function setDelayFunction(fn) {\n      delayFunction = fn;\n\n      if (deletionQueue.length && delayFunction) {\n        delayFunction(flushPendingDeletes);\n      }\n    }\n\n    function init_embind() {\n      Module['getInheritedInstanceCount'] = getInheritedInstanceCount;\n      Module['getLiveInheritedInstances'] = getLiveInheritedInstances;\n      Module['flushPendingDeletes'] = flushPendingDeletes;\n      Module['setDelayFunction'] = setDelayFunction;\n    }\n\n    var registeredInstances = {};\n\n    function getBasestPointer(class_, ptr) {\n      if (ptr === undefined) {\n        throwBindingError('ptr should not be undefined');\n      }\n\n      while (class_.baseClass) {\n        ptr = class_.upcast(ptr);\n        class_ = class_.baseClass;\n      }\n\n      return ptr;\n    }\n\n    function getInheritedInstance(class_, ptr) {\n      ptr = getBasestPointer(class_, ptr);\n      return registeredInstances[ptr];\n    }\n\n    function makeClassHandle(prototype, record) {\n      if (!record.ptrType || !record.ptr) {\n        throwInternalError('makeClassHandle requires ptr and ptrType');\n      }\n\n      var hasSmartPtrType = !!record.smartPtrType;\n      var hasSmartPtr = !!record.smartPtr;\n\n      if (hasSmartPtrType !== hasSmartPtr) {\n        throwInternalError('Both smartPtrType and smartPtr must be specified');\n      }\n\n      record.count = {\n        value: 1\n      };\n      return attachFinalizer(Object.create(prototype, {\n        $$: {\n          value: record\n        }\n      }));\n    }\n\n    function RegisteredPointer_fromWireType(ptr) {\n      // ptr is a raw pointer (or a raw smartpointer)\n      // rawPointer is a maybe-null raw pointer\n      var rawPointer = this.getPointee(ptr);\n\n      if (!rawPointer) {\n        this.destructor(ptr);\n        return null;\n      }\n\n      var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);\n\n      if (undefined !== registeredInstance) {\n        // JS object has been neutered, time to repopulate it\n        if (0 === registeredInstance.$$.count.value) {\n          registeredInstance.$$.ptr = rawPointer;\n          registeredInstance.$$.smartPtr = ptr;\n          return registeredInstance['clone']();\n        } else {\n          // else, just increment reference count on existing object\n          // it already has a reference to the smart pointer\n          var rv = registeredInstance['clone']();\n          this.destructor(ptr);\n          return rv;\n        }\n      }\n\n      function makeDefaultHandle() {\n        if (this.isSmartPointer) {\n          return makeClassHandle(this.registeredClass.instancePrototype, {\n            ptrType: this.pointeeType,\n            ptr: rawPointer,\n            smartPtrType: this,\n            smartPtr: ptr\n          });\n        } else {\n          return makeClassHandle(this.registeredClass.instancePrototype, {\n            ptrType: this,\n            ptr: ptr\n          });\n        }\n      }\n\n      var actualType = this.registeredClass.getActualType(rawPointer);\n      var registeredPointerRecord = registeredPointers[actualType];\n\n      if (!registeredPointerRecord) {\n        return makeDefaultHandle.call(this);\n      }\n\n      var toType;\n\n      if (this.isConst) {\n        toType = registeredPointerRecord.constPointerType;\n      } else {\n        toType = registeredPointerRecord.pointerType;\n      }\n\n      var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);\n\n      if (dp === null) {\n        return makeDefaultHandle.call(this);\n      }\n\n      if (this.isSmartPointer) {\n        return makeClassHandle(toType.registeredClass.instancePrototype, {\n          ptrType: toType,\n          ptr: dp,\n          smartPtrType: this,\n          smartPtr: ptr\n        });\n      } else {\n        return makeClassHandle(toType.registeredClass.instancePrototype, {\n          ptrType: toType,\n          ptr: dp\n        });\n      }\n    }\n\n    function init_RegisteredPointer() {\n      RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;\n      RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;\n      RegisteredPointer.prototype['argPackAdvance'] = 8;\n      RegisteredPointer.prototype['readValueFromPointer'] = simpleReadValueFromPointer;\n      RegisteredPointer.prototype['deleteObject'] = RegisteredPointer_deleteObject;\n      RegisteredPointer.prototype['fromWireType'] = RegisteredPointer_fromWireType;\n    }\n\n    function RegisteredPointer(name, registeredClass, isReference, isConst, // smart pointer properties\n    isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {\n      this.name = name;\n      this.registeredClass = registeredClass;\n      this.isReference = isReference;\n      this.isConst = isConst; // smart pointer properties\n\n      this.isSmartPointer = isSmartPointer;\n      this.pointeeType = pointeeType;\n      this.sharingPolicy = sharingPolicy;\n      this.rawGetPointee = rawGetPointee;\n      this.rawConstructor = rawConstructor;\n      this.rawShare = rawShare;\n      this.rawDestructor = rawDestructor;\n\n      if (!isSmartPointer && registeredClass.baseClass === undefined) {\n        if (isConst) {\n          this['toWireType'] = constNoSmartPtrRawPointerToWireType;\n          this.destructorFunction = null;\n        } else {\n          this['toWireType'] = nonConstNoSmartPtrRawPointerToWireType;\n          this.destructorFunction = null;\n        }\n      } else {\n        this['toWireType'] = genericPointerToWireType; // Here we must leave this.destructorFunction undefined, since whether genericPointerToWireType returns\n        // a pointer that needs to be freed up is runtime-dependent, and cannot be evaluated at registration time.\n        // TODO: Create an alternative mechanism that allows removing the use of var destructors = []; array in\n        //       craftInvokerFunction altogether.\n      }\n    }\n\n    function replacePublicSymbol(name, value, numArguments) {\n      if (!Module.hasOwnProperty(name)) {\n        throwInternalError('Replacing nonexistant public symbol');\n      } // If there's an overload table for this symbol, replace the symbol in the overload table instead.\n\n\n      if (undefined !== Module[name].overloadTable && undefined !== numArguments) {\n        Module[name].overloadTable[numArguments] = value;\n      } else {\n        Module[name] = value;\n        Module[name].argCount = numArguments;\n      }\n    }\n\n    function embind__requireFunction(signature, rawFunction) {\n      signature = readLatin1String(signature);\n\n      function makeDynCaller(dynCall) {\n        return function () {\n          var args = new Array(arguments.length + 1);\n          args[0] = rawFunction;\n\n          for (var i = 0; i < arguments.length; i++) {\n            args[i + 1] = arguments[i];\n          }\n\n          return dynCall.apply(null, args);\n        };\n      }\n\n      var fp;\n\n      if (Module['FUNCTION_TABLE_' + signature] !== undefined) {\n        fp = Module['FUNCTION_TABLE_' + signature][rawFunction];\n      } else if (typeof FUNCTION_TABLE !== \"undefined\") {\n        fp = FUNCTION_TABLE[rawFunction];\n      } else {\n        // asm.js does not give direct access to the function tables,\n        // and thus we must go through the dynCall interface which allows\n        // calling into a signature's function table by pointer value.\n        //\n        // https://github.com/dherman/asm.js/issues/83\n        //\n        // This has three main penalties:\n        // - dynCall is another function call in the path from JavaScript to C++.\n        // - JITs may not predict through the function table indirection at runtime.\n        var dc = Module['dynCall_' + signature];\n\n        if (dc === undefined) {\n          // We will always enter this branch if the signature\n          // contains 'f' and PRECISE_F32 is not enabled.\n          //\n          // Try again, replacing 'f' with 'd'.\n          dc = Module['dynCall_' + signature.replace(/f/g, 'd')];\n\n          if (dc === undefined) {\n            throwBindingError(\"No dynCall invoker for signature: \" + signature);\n          }\n        }\n\n        fp = makeDynCaller(dc);\n      }\n\n      if (typeof fp !== \"function\") {\n        throwBindingError(\"unknown function pointer with signature \" + signature + \": \" + rawFunction);\n      }\n\n      return fp;\n    }\n\n    var UnboundTypeError = undefined;\n\n    function getTypeName(type) {\n      var ptr = ___getTypeName(type);\n\n      var rv = readLatin1String(ptr);\n\n      _free(ptr);\n\n      return rv;\n    }\n\n    function throwUnboundTypeError(message, types) {\n      var unboundTypes = [];\n      var seen = {};\n\n      function visit(type) {\n        if (seen[type]) {\n          return;\n        }\n\n        if (registeredTypes[type]) {\n          return;\n        }\n\n        if (typeDependencies[type]) {\n          typeDependencies[type].forEach(visit);\n          return;\n        }\n\n        unboundTypes.push(type);\n        seen[type] = true;\n      }\n\n      types.forEach(visit);\n      throw new UnboundTypeError(message + ': ' + unboundTypes.map(getTypeName).join([', ']));\n    }\n\n    function __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name, destructorSignature, rawDestructor) {\n      name = readLatin1String(name);\n      getActualType = embind__requireFunction(getActualTypeSignature, getActualType);\n\n      if (upcast) {\n        upcast = embind__requireFunction(upcastSignature, upcast);\n      }\n\n      if (downcast) {\n        downcast = embind__requireFunction(downcastSignature, downcast);\n      }\n\n      rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);\n      var legalFunctionName = makeLegalFunctionName(name);\n      exposePublicSymbol(legalFunctionName, function () {\n        // this code cannot run if baseClassRawType is zero\n        throwUnboundTypeError('Cannot construct ' + name + ' due to unbound types', [baseClassRawType]);\n      });\n      whenDependentTypesAreResolved([rawType, rawPointerType, rawConstPointerType], baseClassRawType ? [baseClassRawType] : [], function (base) {\n        base = base[0];\n        var baseClass;\n        var basePrototype;\n\n        if (baseClassRawType) {\n          baseClass = base.registeredClass;\n          basePrototype = baseClass.instancePrototype;\n        } else {\n          basePrototype = ClassHandle.prototype;\n        }\n\n        var constructor = createNamedFunction(legalFunctionName, function () {\n          if (Object.getPrototypeOf(this) !== instancePrototype) {\n            throw new BindingError(\"Use 'new' to construct \" + name);\n          }\n\n          if (undefined === registeredClass.constructor_body) {\n            throw new BindingError(name + \" has no accessible constructor\");\n          }\n\n          var body = registeredClass.constructor_body[arguments.length];\n\n          if (undefined === body) {\n            throw new BindingError(\"Tried to invoke ctor of \" + name + \" with invalid number of parameters (\" + arguments.length + \") - expected (\" + Object.keys(registeredClass.constructor_body).toString() + \") parameters instead!\");\n          }\n\n          return body.apply(this, arguments);\n        });\n        var instancePrototype = Object.create(basePrototype, {\n          constructor: {\n            value: constructor\n          }\n        });\n        constructor.prototype = instancePrototype;\n        var registeredClass = new RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);\n        var referenceConverter = new RegisteredPointer(name, registeredClass, true, false, false);\n        var pointerConverter = new RegisteredPointer(name + '*', registeredClass, false, false, false);\n        var constPointerConverter = new RegisteredPointer(name + ' const*', registeredClass, false, true, false);\n        registeredPointers[rawType] = {\n          pointerType: pointerConverter,\n          constPointerType: constPointerConverter\n        };\n        replacePublicSymbol(legalFunctionName, constructor);\n        return [referenceConverter, pointerConverter, constPointerConverter];\n      });\n    }\n\n    function heap32VectorToArray(count, firstElement) {\n      var array = [];\n\n      for (var i = 0; i < count; i++) {\n        array.push(HEAP32[(firstElement >> 2) + i]);\n      }\n\n      return array;\n    }\n\n    function runDestructors(destructors) {\n      while (destructors.length) {\n        var ptr = destructors.pop();\n        var del = destructors.pop();\n        del(ptr);\n      }\n    }\n\n    function __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {\n      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n      invoker = embind__requireFunction(invokerSignature, invoker);\n      whenDependentTypesAreResolved([], [rawClassType], function (classType) {\n        classType = classType[0];\n        var humanName = 'constructor ' + classType.name;\n\n        if (undefined === classType.registeredClass.constructor_body) {\n          classType.registeredClass.constructor_body = [];\n        }\n\n        if (undefined !== classType.registeredClass.constructor_body[argCount - 1]) {\n          throw new BindingError(\"Cannot register multiple constructors with identical number of parameters (\" + (argCount - 1) + \") for class '\" + classType.name + \"'! Overload resolution is currently only performed using the parameter count, not actual type info!\");\n        }\n\n        classType.registeredClass.constructor_body[argCount - 1] = function unboundTypeHandler() {\n          throwUnboundTypeError('Cannot construct ' + classType.name + ' due to unbound types', rawArgTypes);\n        };\n\n        whenDependentTypesAreResolved([], rawArgTypes, function (argTypes) {\n          classType.registeredClass.constructor_body[argCount - 1] = function constructor_body() {\n            if (arguments.length !== argCount - 1) {\n              throwBindingError(humanName + ' called with ' + arguments.length + ' arguments, expected ' + (argCount - 1));\n            }\n\n            var destructors = [];\n            var args = new Array(argCount);\n            args[0] = rawConstructor;\n\n            for (var i = 1; i < argCount; ++i) {\n              args[i] = argTypes[i]['toWireType'](destructors, arguments[i - 1]);\n            }\n\n            var ptr = invoker.apply(null, args);\n            runDestructors(destructors);\n            return argTypes[0]['fromWireType'](ptr);\n          };\n\n          return [];\n        });\n        return [];\n      });\n    }\n\n    function new_(constructor, argumentList) {\n      if (!(constructor instanceof Function)) {\n        throw new TypeError('new_ called with constructor type ' + typeof constructor + \" which is not a function\");\n      }\n\n      if (constructor === Function) {\n        throw new Error('new_ cannot create a new Function with DYNAMIC_EXECUTION == 0.');\n      }\n      /*\n      * Previously, the following line was just:\n      function dummy() {};\n      * Unfortunately, Chrome was preserving 'dummy' as the object's name, even though at creation, the 'dummy' has the\n      * correct constructor name.  Thus, objects created with IMVU.new would show up in the debugger as 'dummy', which\n      * isn't very helpful.  Using IMVU.createNamedFunction addresses the issue.  Doublely-unfortunately, there's no way\n      * to write a test for this behavior.  -NRD 2013.02.22\n      */\n\n\n      var dummy = createNamedFunction(constructor.name || 'unknownFunctionName', function () {});\n      dummy.prototype = constructor.prototype;\n      var obj = new dummy();\n      var r = constructor.apply(obj, argumentList);\n      return r instanceof Object ? r : obj;\n    }\n\n    function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {\n      // humanName: a human-readable string name for the function to be generated.\n      // argTypes: An array that contains the embind type objects for all types in the function signature.\n      //    argTypes[0] is the type object for the function return value.\n      //    argTypes[1] is the type object for function this object/class type, or null if not crafting an invoker for a class method.\n      //    argTypes[2...] are the actual function parameters.\n      // classType: The embind type object for the class to be bound, or null if this is not a method of a class.\n      // cppInvokerFunc: JS Function object to the C++-side function that interops into C++ code.\n      // cppTargetFunc: Function pointer (an integer to FUNCTION_TABLE) to the target C++ function the cppInvokerFunc will end up calling.\n      var argCount = argTypes.length;\n\n      if (argCount < 2) {\n        throwBindingError(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");\n      }\n\n      var isClassMethodFunc = argTypes[1] !== null && classType !== null; // Free functions with signature \"void function()\" do not need an invoker that marshalls between wire types.\n      // TODO: This omits argument count check - enable only at -O3 or similar.\n      //    if (ENABLE_UNSAFE_OPTS && argCount == 2 && argTypes[0].name == \"void\" && !isClassMethodFunc) {\n      //       return FUNCTION_TABLE[fn];\n      //    }\n      // Determine if we need to use a dynamic stack to store the destructors for the function parameters.\n      // TODO: Remove this completely once all function invokers are being dynamically generated.\n\n      var needsDestructorStack = false;\n\n      for (var i = 1; i < argTypes.length; ++i) {\n        // Skip return value at index 0 - it's not deleted here.\n        if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) {\n          // The type does not define a destructor function - must use dynamic stack\n          needsDestructorStack = true;\n          break;\n        }\n      }\n\n      var returns = argTypes[0].name !== \"void\";\n      var argsWired = new Array(argCount - 2);\n      return function () {\n        if (arguments.length !== argCount - 2) {\n          throwBindingError('function ' + humanName + ' called with ' + arguments.length + ' arguments, expected ' + (argCount - 2) + ' args!');\n        }\n\n        var destructors = needsDestructorStack ? [] : null;\n        var thisWired;\n\n        if (isClassMethodFunc) {\n          thisWired = argTypes[1].toWireType(destructors, this);\n        }\n\n        for (var i = 0; i < argCount - 2; ++i) {\n          argsWired[i] = argTypes[i + 2].toWireType(destructors, arguments[i]);\n        }\n\n        var invokerFuncArgs = isClassMethodFunc ? [cppTargetFunc, thisWired] : [cppTargetFunc];\n        var rv = cppInvokerFunc.apply(null, invokerFuncArgs.concat(argsWired));\n\n        if (needsDestructorStack) {\n          runDestructors(destructors);\n        } else {\n          for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; i++) {\n            var param = i === 1 ? thisWired : argsWired[i - 2];\n\n            if (argTypes[i].destructorFunction !== null) {\n              argTypes[i].destructorFunction(param);\n            }\n          }\n        }\n\n        if (returns) {\n          return argTypes[0].fromWireType(rv);\n        }\n      };\n    }\n\n    function __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, // [ReturnType, ThisType, Args...]\n    invokerSignature, rawInvoker, context, isPureVirtual) {\n      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n      methodName = readLatin1String(methodName);\n      rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);\n      whenDependentTypesAreResolved([], [rawClassType], function (classType) {\n        classType = classType[0];\n        var humanName = classType.name + '.' + methodName;\n\n        if (isPureVirtual) {\n          classType.registeredClass.pureVirtualFunctions.push(methodName);\n        }\n\n        function unboundTypesHandler() {\n          throwUnboundTypeError('Cannot call ' + humanName + ' due to unbound types', rawArgTypes);\n        }\n\n        var proto = classType.registeredClass.instancePrototype;\n        var method = proto[methodName];\n\n        if (undefined === method || undefined === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2) {\n          // This is the first overload to be registered, OR we are replacing a function in the base class with a function in the derived class.\n          unboundTypesHandler.argCount = argCount - 2;\n          unboundTypesHandler.className = classType.name;\n          proto[methodName] = unboundTypesHandler;\n        } else {\n          // There was an existing function with the same name registered. Set up a function overload routing table.\n          ensureOverloadTable(proto, methodName, humanName);\n          proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;\n        }\n\n        whenDependentTypesAreResolved([], rawArgTypes, function (argTypes) {\n          var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context); // Replace the initial unbound-handler-stub function with the appropriate member function, now that all types\n          // are resolved. If multiple overloads are registered for this function, the function goes into an overload table.\n\n          if (undefined === proto[methodName].overloadTable) {\n            // Set argCount in case an overload is registered later\n            memberFunction.argCount = argCount - 2;\n            proto[methodName] = memberFunction;\n          } else {\n            proto[methodName].overloadTable[argCount - 2] = memberFunction;\n          }\n\n          return [];\n        });\n        return [];\n      });\n    }\n\n    function validateThis(this_, classType, humanName) {\n      if (!(this_ instanceof Object)) {\n        throwBindingError(humanName + ' with invalid \"this\": ' + this_);\n      }\n\n      if (!(this_ instanceof classType.registeredClass.constructor)) {\n        throwBindingError(humanName + ' incompatible with \"this\" of type ' + this_.constructor.name);\n      }\n\n      if (!this_.$$.ptr) {\n        throwBindingError('cannot call emscripten binding method ' + humanName + ' on deleted object');\n      } // todo: kill this\n\n\n      return upcastPointer(this_.$$.ptr, this_.$$.ptrType.registeredClass, classType.registeredClass);\n    }\n\n    function __embind_register_class_property(classType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {\n      fieldName = readLatin1String(fieldName);\n      getter = embind__requireFunction(getterSignature, getter);\n      whenDependentTypesAreResolved([], [classType], function (classType) {\n        classType = classType[0];\n        var humanName = classType.name + '.' + fieldName;\n        var desc = {\n          get: function () {\n            throwUnboundTypeError('Cannot access ' + humanName + ' due to unbound types', [getterReturnType, setterArgumentType]);\n          },\n          enumerable: true,\n          configurable: true\n        };\n\n        if (setter) {\n          desc.set = function () {\n            throwUnboundTypeError('Cannot access ' + humanName + ' due to unbound types', [getterReturnType, setterArgumentType]);\n          };\n        } else {\n          desc.set = function (v) {\n            throwBindingError(humanName + ' is a read-only property');\n          };\n        }\n\n        Object.defineProperty(classType.registeredClass.instancePrototype, fieldName, desc);\n        whenDependentTypesAreResolved([], setter ? [getterReturnType, setterArgumentType] : [getterReturnType], function (types) {\n          var getterReturnType = types[0];\n          var desc = {\n            get: function () {\n              var ptr = validateThis(this, classType, humanName + ' getter');\n              return getterReturnType['fromWireType'](getter(getterContext, ptr));\n            },\n            enumerable: true\n          };\n\n          if (setter) {\n            setter = embind__requireFunction(setterSignature, setter);\n            var setterArgumentType = types[1];\n\n            desc.set = function (v) {\n              var ptr = validateThis(this, classType, humanName + ' setter');\n              var destructors = [];\n              setter(setterContext, ptr, setterArgumentType['toWireType'](destructors, v));\n              runDestructors(destructors);\n            };\n          }\n\n          Object.defineProperty(classType.registeredClass.instancePrototype, fieldName, desc);\n          return [];\n        });\n        return [];\n      });\n    }\n\n    var emval_free_list = [];\n    var emval_handle_array = [{}, {\n      value: undefined\n    }, {\n      value: null\n    }, {\n      value: true\n    }, {\n      value: false\n    }];\n\n    function __emval_decref(handle) {\n      if (handle > 4 && 0 === --emval_handle_array[handle].refcount) {\n        emval_handle_array[handle] = undefined;\n        emval_free_list.push(handle);\n      }\n    }\n\n    function count_emval_handles() {\n      var count = 0;\n\n      for (var i = 5; i < emval_handle_array.length; ++i) {\n        if (emval_handle_array[i] !== undefined) {\n          ++count;\n        }\n      }\n\n      return count;\n    }\n\n    function get_first_emval() {\n      for (var i = 5; i < emval_handle_array.length; ++i) {\n        if (emval_handle_array[i] !== undefined) {\n          return emval_handle_array[i];\n        }\n      }\n\n      return null;\n    }\n\n    function init_emval() {\n      Module['count_emval_handles'] = count_emval_handles;\n      Module['get_first_emval'] = get_first_emval;\n    }\n\n    function __emval_register(value) {\n      switch (value) {\n        case undefined:\n          {\n            return 1;\n          }\n\n        case null:\n          {\n            return 2;\n          }\n\n        case true:\n          {\n            return 3;\n          }\n\n        case false:\n          {\n            return 4;\n          }\n\n        default:\n          {\n            var handle = emval_free_list.length ? emval_free_list.pop() : emval_handle_array.length;\n            emval_handle_array[handle] = {\n              refcount: 1,\n              value: value\n            };\n            return handle;\n          }\n      }\n    }\n\n    function __embind_register_emval(rawType, name) {\n      name = readLatin1String(name);\n      registerType(rawType, {\n        name: name,\n        'fromWireType': function (handle) {\n          var rv = emval_handle_array[handle].value;\n\n          __emval_decref(handle);\n\n          return rv;\n        },\n        'toWireType': function (destructors, value) {\n          return __emval_register(value);\n        },\n        'argPackAdvance': 8,\n        'readValueFromPointer': simpleReadValueFromPointer,\n        destructorFunction: null // This type does not need a destructor\n        // TODO: do we need a deleteObject here?  write a test where\n        // emval is passed into JS via an interface\n\n      });\n    }\n\n    function enumReadValueFromPointer(name, shift, signed) {\n      switch (shift) {\n        case 0:\n          return function (pointer) {\n            var heap = signed ? HEAP8 : HEAPU8;\n            return this['fromWireType'](heap[pointer]);\n          };\n\n        case 1:\n          return function (pointer) {\n            var heap = signed ? HEAP16 : HEAPU16;\n            return this['fromWireType'](heap[pointer >> 1]);\n          };\n\n        case 2:\n          return function (pointer) {\n            var heap = signed ? HEAP32 : HEAPU32;\n            return this['fromWireType'](heap[pointer >> 2]);\n          };\n\n        default:\n          throw new TypeError(\"Unknown integer type: \" + name);\n      }\n    }\n\n    function __embind_register_enum(rawType, name, size, isSigned) {\n      var shift = getShiftFromSize(size);\n      name = readLatin1String(name);\n\n      function ctor() {}\n\n      ctor.values = {};\n      registerType(rawType, {\n        name: name,\n        constructor: ctor,\n        'fromWireType': function (c) {\n          return this.constructor.values[c];\n        },\n        'toWireType': function (destructors, c) {\n          return c.value;\n        },\n        'argPackAdvance': 8,\n        'readValueFromPointer': enumReadValueFromPointer(name, shift, isSigned),\n        destructorFunction: null\n      });\n      exposePublicSymbol(name, ctor);\n    }\n\n    function requireRegisteredType(rawType, humanName) {\n      var impl = registeredTypes[rawType];\n\n      if (undefined === impl) {\n        throwBindingError(humanName + \" has unknown type \" + getTypeName(rawType));\n      }\n\n      return impl;\n    }\n\n    function __embind_register_enum_value(rawEnumType, name, enumValue) {\n      var enumType = requireRegisteredType(rawEnumType, 'enum');\n      name = readLatin1String(name);\n      var Enum = enumType.constructor;\n      var Value = Object.create(enumType.constructor.prototype, {\n        value: {\n          value: enumValue\n        },\n        constructor: {\n          value: createNamedFunction(enumType.name + '_' + name, function () {})\n        }\n      });\n      Enum.values[enumValue] = Value;\n      Enum[name] = Value;\n    }\n\n    function _embind_repr(v) {\n      if (v === null) {\n        return 'null';\n      }\n\n      var t = typeof v;\n\n      if (t === 'object' || t === 'array' || t === 'function') {\n        return v.toString();\n      } else {\n        return '' + v;\n      }\n    }\n\n    function floatReadValueFromPointer(name, shift) {\n      switch (shift) {\n        case 2:\n          return function (pointer) {\n            return this['fromWireType'](HEAPF32[pointer >> 2]);\n          };\n\n        case 3:\n          return function (pointer) {\n            return this['fromWireType'](HEAPF64[pointer >> 3]);\n          };\n\n        default:\n          throw new TypeError(\"Unknown float type: \" + name);\n      }\n    }\n\n    function __embind_register_float(rawType, name, size) {\n      var shift = getShiftFromSize(size);\n      name = readLatin1String(name);\n      registerType(rawType, {\n        name: name,\n        'fromWireType': function (value) {\n          return value;\n        },\n        'toWireType': function (destructors, value) {\n          // todo: Here we have an opportunity for -O3 level \"unsafe\" optimizations: we could\n          // avoid the following if() and assume value is of proper type.\n          if (typeof value !== \"number\" && typeof value !== \"boolean\") {\n            throw new TypeError('Cannot convert \"' + _embind_repr(value) + '\" to ' + this.name);\n          }\n\n          return value;\n        },\n        'argPackAdvance': 8,\n        'readValueFromPointer': floatReadValueFromPointer(name, shift),\n        destructorFunction: null // This type does not need a destructor\n\n      });\n    }\n\n    function __embind_register_function(name, argCount, rawArgTypesAddr, signature, rawInvoker, fn) {\n      var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n      name = readLatin1String(name);\n      rawInvoker = embind__requireFunction(signature, rawInvoker);\n      exposePublicSymbol(name, function () {\n        throwUnboundTypeError('Cannot call ' + name + ' due to unbound types', argTypes);\n      }, argCount - 1);\n      whenDependentTypesAreResolved([], argTypes, function (argTypes) {\n        var invokerArgsArray = [argTypes[0]\n        /* return value */\n        , null\n        /* no class 'this'*/\n        ].concat(argTypes.slice(1)\n        /* actual params */\n        );\n        replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null\n        /* no class 'this'*/\n        , rawInvoker, fn), argCount - 1);\n        return [];\n      });\n    }\n\n    function integerReadValueFromPointer(name, shift, signed) {\n      // integers are quite common, so generate very specialized functions\n      switch (shift) {\n        case 0:\n          return signed ? function readS8FromPointer(pointer) {\n            return HEAP8[pointer];\n          } : function readU8FromPointer(pointer) {\n            return HEAPU8[pointer];\n          };\n\n        case 1:\n          return signed ? function readS16FromPointer(pointer) {\n            return HEAP16[pointer >> 1];\n          } : function readU16FromPointer(pointer) {\n            return HEAPU16[pointer >> 1];\n          };\n\n        case 2:\n          return signed ? function readS32FromPointer(pointer) {\n            return HEAP32[pointer >> 2];\n          } : function readU32FromPointer(pointer) {\n            return HEAPU32[pointer >> 2];\n          };\n\n        default:\n          throw new TypeError(\"Unknown integer type: \" + name);\n      }\n    }\n\n    function __embind_register_integer(primitiveType, name, size, minRange, maxRange) {\n      name = readLatin1String(name);\n\n      if (maxRange === -1) {\n        // LLVM doesn't have signed and unsigned 32-bit types, so u32 literals come out as 'i32 -1'. Always treat those as max u32.\n        maxRange = 4294967295;\n      }\n\n      var shift = getShiftFromSize(size);\n\n      var fromWireType = function (value) {\n        return value;\n      };\n\n      if (minRange === 0) {\n        var bitshift = 32 - 8 * size;\n\n        fromWireType = function (value) {\n          return value << bitshift >>> bitshift;\n        };\n      }\n\n      var isUnsignedType = name.indexOf('unsigned') != -1;\n      registerType(primitiveType, {\n        name: name,\n        'fromWireType': fromWireType,\n        'toWireType': function (destructors, value) {\n          // todo: Here we have an opportunity for -O3 level \"unsafe\" optimizations: we could\n          // avoid the following two if()s and assume value is of proper type.\n          if (typeof value !== \"number\" && typeof value !== \"boolean\") {\n            throw new TypeError('Cannot convert \"' + _embind_repr(value) + '\" to ' + this.name);\n          }\n\n          if (value < minRange || value > maxRange) {\n            throw new TypeError('Passing a number \"' + _embind_repr(value) + '\" from JS side to C/C++ side to an argument of type \"' + name + '\", which is outside the valid range [' + minRange + ', ' + maxRange + ']!');\n          }\n\n          return isUnsignedType ? value >>> 0 : value | 0;\n        },\n        'argPackAdvance': 8,\n        'readValueFromPointer': integerReadValueFromPointer(name, shift, minRange !== 0),\n        destructorFunction: null // This type does not need a destructor\n\n      });\n    }\n\n    function __embind_register_memory_view(rawType, dataTypeIndex, name) {\n      var typeMapping = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];\n      var TA = typeMapping[dataTypeIndex];\n\n      function decodeMemoryView(handle) {\n        handle = handle >> 2;\n        var heap = HEAPU32;\n        var size = heap[handle]; // in elements\n\n        var data = heap[handle + 1]; // byte offset into emscripten heap\n\n        return new TA(heap['buffer'], data, size);\n      }\n\n      name = readLatin1String(name);\n      registerType(rawType, {\n        name: name,\n        'fromWireType': decodeMemoryView,\n        'argPackAdvance': 8,\n        'readValueFromPointer': decodeMemoryView\n      }, {\n        ignoreDuplicateRegistrations: true\n      });\n    }\n\n    function __embind_register_std_string(rawType, name) {\n      name = readLatin1String(name);\n      var stdStringIsUTF8 //process only std::string bindings with UTF8 support, in contrast to e.g. std::basic_string<unsigned char>\n      = name === \"std::string\";\n      registerType(rawType, {\n        name: name,\n        'fromWireType': function (value) {\n          var length = HEAPU32[value >> 2];\n          var str;\n\n          if (stdStringIsUTF8) {\n            //ensure null termination at one-past-end byte if not present yet\n            var endChar = HEAPU8[value + 4 + length];\n            var endCharSwap = 0;\n\n            if (endChar != 0) {\n              endCharSwap = endChar;\n              HEAPU8[value + 4 + length] = 0;\n            }\n\n            var decodeStartPtr = value + 4; //looping here to support possible embedded '0' bytes\n\n            for (var i = 0; i <= length; ++i) {\n              var currentBytePtr = value + 4 + i;\n\n              if (HEAPU8[currentBytePtr] == 0) {\n                var stringSegment = UTF8ToString(decodeStartPtr);\n                if (str === undefined) str = stringSegment;else {\n                  str += String.fromCharCode(0);\n                  str += stringSegment;\n                }\n                decodeStartPtr = currentBytePtr + 1;\n              }\n            }\n\n            if (endCharSwap != 0) HEAPU8[value + 4 + length] = endCharSwap;\n          } else {\n            var a = new Array(length);\n\n            for (var i = 0; i < length; ++i) {\n              a[i] = String.fromCharCode(HEAPU8[value + 4 + i]);\n            }\n\n            str = a.join('');\n          }\n\n          _free(value);\n\n          return str;\n        },\n        'toWireType': function (destructors, value) {\n          if (value instanceof ArrayBuffer) {\n            value = new Uint8Array(value);\n          }\n\n          var getLength;\n          var valueIsOfTypeString = typeof value === 'string';\n\n          if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {\n            throwBindingError('Cannot pass non-string to std::string');\n          }\n\n          if (stdStringIsUTF8 && valueIsOfTypeString) {\n            getLength = function () {\n              return lengthBytesUTF8(value);\n            };\n          } else {\n            getLength = function () {\n              return value.length;\n            };\n          } // assumes 4-byte alignment\n\n\n          var length = getLength();\n\n          var ptr = _malloc(4 + length + 1);\n\n          HEAPU32[ptr >> 2] = length;\n\n          if (stdStringIsUTF8 && valueIsOfTypeString) {\n            stringToUTF8(value, ptr + 4, length + 1);\n          } else {\n            if (valueIsOfTypeString) {\n              for (var i = 0; i < length; ++i) {\n                var charCode = value.charCodeAt(i);\n\n                if (charCode > 255) {\n                  _free(ptr);\n\n                  throwBindingError('String has UTF-16 code units that do not fit in 8 bits');\n                }\n\n                HEAPU8[ptr + 4 + i] = charCode;\n              }\n            } else {\n              for (var i = 0; i < length; ++i) {\n                HEAPU8[ptr + 4 + i] = value[i];\n              }\n            }\n          }\n\n          if (destructors !== null) {\n            destructors.push(_free, ptr);\n          }\n\n          return ptr;\n        },\n        'argPackAdvance': 8,\n        'readValueFromPointer': simpleReadValueFromPointer,\n        destructorFunction: function (ptr) {\n          _free(ptr);\n        }\n      });\n    }\n\n    function __embind_register_std_wstring(rawType, charSize, name) {\n      // nb. do not cache HEAPU16 and HEAPU32, they may be destroyed by emscripten_resize_heap().\n      name = readLatin1String(name);\n      var getHeap, shift;\n\n      if (charSize === 2) {\n        getHeap = function () {\n          return HEAPU16;\n        };\n\n        shift = 1;\n      } else if (charSize === 4) {\n        getHeap = function () {\n          return HEAPU32;\n        };\n\n        shift = 2;\n      }\n\n      registerType(rawType, {\n        name: name,\n        'fromWireType': function (value) {\n          var HEAP = getHeap();\n          var length = HEAPU32[value >> 2];\n          var a = new Array(length);\n          var start = value + 4 >> shift;\n\n          for (var i = 0; i < length; ++i) {\n            a[i] = String.fromCharCode(HEAP[start + i]);\n          }\n\n          _free(value);\n\n          return a.join('');\n        },\n        'toWireType': function (destructors, value) {\n          // assumes 4-byte alignment\n          var HEAP = getHeap();\n          var length = value.length;\n\n          var ptr = _malloc(4 + length * charSize);\n\n          HEAPU32[ptr >> 2] = length;\n          var start = ptr + 4 >> shift;\n\n          for (var i = 0; i < length; ++i) {\n            HEAP[start + i] = value.charCodeAt(i);\n          }\n\n          if (destructors !== null) {\n            destructors.push(_free, ptr);\n          }\n\n          return ptr;\n        },\n        'argPackAdvance': 8,\n        'readValueFromPointer': simpleReadValueFromPointer,\n        destructorFunction: function (ptr) {\n          _free(ptr);\n        }\n      });\n    }\n\n    function __embind_register_void(rawType, name) {\n      name = readLatin1String(name);\n      registerType(rawType, {\n        isVoid: true,\n        // void return values can be optimized out sometimes\n        name: name,\n        'argPackAdvance': 0,\n        'fromWireType': function () {\n          return undefined;\n        },\n        'toWireType': function (destructors, o) {\n          // TODO: assert if anything else is given?\n          return undefined;\n        }\n      });\n    }\n\n    function __emval_incref(handle) {\n      if (handle > 4) {\n        emval_handle_array[handle].refcount += 1;\n      }\n    }\n\n    function __emval_take_value(type, argv) {\n      type = requireRegisteredType(type, '_emval_take_value');\n      var v = type['readValueFromPointer'](argv);\n      return __emval_register(v);\n    }\n\n    function _abort() {\n      Module['abort']();\n    }\n\n    function _emscripten_get_heap_size() {\n      return HEAP8.length;\n    }\n\n    function _llvm_trap() {\n      abort('trap!');\n    }\n\n    function _emscripten_memcpy_big(dest, src, num) {\n      HEAPU8.set(HEAPU8.subarray(src, src + num), dest);\n    }\n\n    function ___setErrNo(value) {\n      if (Module['___errno_location']) HEAP32[Module['___errno_location']() >> 2] = value;else err('failed to set errno from JS');\n      return value;\n    }\n\n    function abortOnCannotGrowMemory(requestedSize) {\n      abort('Cannot enlarge memory arrays to size ' + requestedSize + ' bytes (OOM). Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value ' + HEAP8.length + ', (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ');\n    }\n\n    function emscripten_realloc_buffer(size) {\n      var PAGE_MULTIPLE = 65536;\n      size = alignUp(size, PAGE_MULTIPLE); // round up to wasm page size\n\n      var oldSize = buffer.byteLength; // native wasm support\n      // note that this is *not* threadsafe. multiple threads can call .grow(), and each\n      // presents a delta, so in theory we may over-allocate here (e.g. if two threads\n      // ask to grow from 256MB to 512MB, we get 2 requests to add +256MB, and may end\n      // up growing to 768MB (even though we may have been able to make do with 512MB).\n      // TODO: consider decreasing the step sizes in emscripten_resize_heap\n\n      try {\n        var result = wasmMemory.grow((size - oldSize) / 65536); // .grow() takes a delta compared to the previous size\n\n        if (result !== (-1 | 0)) {\n          // success in native wasm memory growth, get the buffer from the memory\n          buffer = wasmMemory.buffer;\n          return true;\n        } else {\n          return false;\n        }\n      } catch (e) {\n        console.error('emscripten_realloc_buffer: Attempted to grow from ' + oldSize + ' bytes to ' + size + ' bytes, but got error: ' + e);\n        return false;\n      }\n    }\n\n    function _emscripten_resize_heap(requestedSize) {\n      var oldSize = _emscripten_get_heap_size(); // With pthreads, races can happen (another thread might increase the size in between), so return a failure, and let the caller retry.\n\n\n      assert(requestedSize > oldSize);\n      var PAGE_MULTIPLE = 65536;\n      var LIMIT = 2147483648 - PAGE_MULTIPLE; // We can do one page short of 2GB as theoretical maximum.\n\n      if (requestedSize > LIMIT) {\n        err('Cannot enlarge memory, asked to go up to ' + requestedSize + ' bytes, but the limit is ' + LIMIT + ' bytes!');\n        return false;\n      }\n\n      var MIN_TOTAL_MEMORY = 16777216;\n      var newSize = Math.max(oldSize, MIN_TOTAL_MEMORY); // So the loop below will not be infinite, and minimum asm.js memory size is 16MB.\n      // TODO: see realloc_buffer - for PTHREADS we may want to decrease these jumps\n\n      while (newSize < requestedSize) {\n        // Keep incrementing the heap size as long as it's less than what is requested.\n        if (newSize <= 536870912) {\n          newSize = alignUp(2 * newSize, PAGE_MULTIPLE); // Simple heuristic: double until 1GB...\n        } else {\n          // ..., but after that, add smaller increments towards 2GB, which we cannot reach\n          newSize = Math.min(alignUp((3 * newSize + 2147483648) / 4, PAGE_MULTIPLE), LIMIT);\n        }\n\n        if (newSize === oldSize) {\n          warnOnce('Cannot ask for more memory since we reached the practical limit in browsers (which is just below 2GB), so the request would have failed. Requesting only ' + HEAP8.length);\n        }\n      }\n\n      var start = Date.now();\n\n      if (!emscripten_realloc_buffer(newSize)) {\n        err('Failed to grow the heap from ' + oldSize + ' bytes to ' + newSize + ' bytes, not enough memory!');\n        return false;\n      }\n\n      updateGlobalBufferViews();\n      return true;\n    }\n\n    embind_init_charCodes();\n    BindingError = Module['BindingError'] = extendError(Error, 'BindingError');\n    ;\n    InternalError = Module['InternalError'] = extendError(Error, 'InternalError');\n    ;\n    init_ClassHandle();\n    init_RegisteredPointer();\n    init_embind();\n    ;\n    UnboundTypeError = Module['UnboundTypeError'] = extendError(Error, 'UnboundTypeError');\n    ;\n    init_emval();\n    ;\n    var ASSERTIONS = true; // Copyright 2017 The Emscripten Authors.  All rights reserved.\n    // Emscripten is available under two separate licenses, the MIT license and the\n    // University of Illinois/NCSA Open Source License.  Both these licenses can be\n    // found in the LICENSE file.\n\n    /** @type {function(string, boolean=, number=)} */\n\n    function intArrayFromString(stringy, dontAddNull, length) {\n      var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\n      var u8array = new Array(len);\n      var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n      if (dontAddNull) u8array.length = numBytesWritten;\n      return u8array;\n    }\n\n    function intArrayToString(array) {\n      var ret = [];\n\n      for (var i = 0; i < array.length; i++) {\n        var chr = array[i];\n\n        if (chr > 0xFF) {\n          if (ASSERTIONS) {\n            assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');\n          }\n\n          chr &= 0xFF;\n        }\n\n        ret.push(String.fromCharCode(chr));\n      }\n\n      return ret.join('');\n    } // ASM_LIBRARY EXTERN PRIMITIVES: Math_floor,Math_ceil,Int8Array,Int32Array\n\n\n    function nullFunc_fii(x) {\n      err(\"Invalid function pointer called with signature 'fii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    function nullFunc_i(x) {\n      err(\"Invalid function pointer called with signature 'i'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    function nullFunc_ii(x) {\n      err(\"Invalid function pointer called with signature 'ii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    function nullFunc_iidiiii(x) {\n      err(\"Invalid function pointer called with signature 'iidiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    function nullFunc_iii(x) {\n      err(\"Invalid function pointer called with signature 'iii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    function nullFunc_iiii(x) {\n      err(\"Invalid function pointer called with signature 'iiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    function nullFunc_iiiii(x) {\n      err(\"Invalid function pointer called with signature 'iiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    function nullFunc_iiiiii(x) {\n      err(\"Invalid function pointer called with signature 'iiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    function nullFunc_jiji(x) {\n      err(\"Invalid function pointer called with signature 'jiji'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    function nullFunc_v(x) {\n      err(\"Invalid function pointer called with signature 'v'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    function nullFunc_vi(x) {\n      err(\"Invalid function pointer called with signature 'vi'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    function nullFunc_vii(x) {\n      err(\"Invalid function pointer called with signature 'vii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    function nullFunc_viif(x) {\n      err(\"Invalid function pointer called with signature 'viif'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    function nullFunc_viii(x) {\n      err(\"Invalid function pointer called with signature 'viii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    function nullFunc_viiii(x) {\n      err(\"Invalid function pointer called with signature 'viiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    function nullFunc_viiiii(x) {\n      err(\"Invalid function pointer called with signature 'viiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    function nullFunc_viiiiii(x) {\n      err(\"Invalid function pointer called with signature 'viiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    var asmGlobalArg = {};\n    var asmLibraryArg = {\n      \"abort\": abort,\n      \"setTempRet0\": setTempRet0,\n      \"getTempRet0\": getTempRet0,\n      \"abortStackOverflow\": abortStackOverflow,\n      \"nullFunc_fii\": nullFunc_fii,\n      \"nullFunc_i\": nullFunc_i,\n      \"nullFunc_ii\": nullFunc_ii,\n      \"nullFunc_iidiiii\": nullFunc_iidiiii,\n      \"nullFunc_iii\": nullFunc_iii,\n      \"nullFunc_iiii\": nullFunc_iiii,\n      \"nullFunc_iiiii\": nullFunc_iiiii,\n      \"nullFunc_iiiiii\": nullFunc_iiiiii,\n      \"nullFunc_jiji\": nullFunc_jiji,\n      \"nullFunc_v\": nullFunc_v,\n      \"nullFunc_vi\": nullFunc_vi,\n      \"nullFunc_vii\": nullFunc_vii,\n      \"nullFunc_viif\": nullFunc_viif,\n      \"nullFunc_viii\": nullFunc_viii,\n      \"nullFunc_viiii\": nullFunc_viiii,\n      \"nullFunc_viiiii\": nullFunc_viiiii,\n      \"nullFunc_viiiiii\": nullFunc_viiiiii,\n      \"ClassHandle\": ClassHandle,\n      \"ClassHandle_clone\": ClassHandle_clone,\n      \"ClassHandle_delete\": ClassHandle_delete,\n      \"ClassHandle_deleteLater\": ClassHandle_deleteLater,\n      \"ClassHandle_isAliasOf\": ClassHandle_isAliasOf,\n      \"ClassHandle_isDeleted\": ClassHandle_isDeleted,\n      \"RegisteredClass\": RegisteredClass,\n      \"RegisteredPointer\": RegisteredPointer,\n      \"RegisteredPointer_deleteObject\": RegisteredPointer_deleteObject,\n      \"RegisteredPointer_destructor\": RegisteredPointer_destructor,\n      \"RegisteredPointer_fromWireType\": RegisteredPointer_fromWireType,\n      \"RegisteredPointer_getPointee\": RegisteredPointer_getPointee,\n      \"___cxa_allocate_exception\": ___cxa_allocate_exception,\n      \"___cxa_begin_catch\": ___cxa_begin_catch,\n      \"___cxa_pure_virtual\": ___cxa_pure_virtual,\n      \"___cxa_throw\": ___cxa_throw,\n      \"___cxa_uncaught_exception\": ___cxa_uncaught_exception,\n      \"___exception_addRef\": ___exception_addRef,\n      \"___exception_deAdjust\": ___exception_deAdjust,\n      \"___gxx_personality_v0\": ___gxx_personality_v0,\n      \"___lock\": ___lock,\n      \"___setErrNo\": ___setErrNo,\n      \"___syscall140\": ___syscall140,\n      \"___syscall146\": ___syscall146,\n      \"___syscall54\": ___syscall54,\n      \"___syscall6\": ___syscall6,\n      \"___unlock\": ___unlock,\n      \"__embind_register_bool\": __embind_register_bool,\n      \"__embind_register_class\": __embind_register_class,\n      \"__embind_register_class_constructor\": __embind_register_class_constructor,\n      \"__embind_register_class_function\": __embind_register_class_function,\n      \"__embind_register_class_property\": __embind_register_class_property,\n      \"__embind_register_emval\": __embind_register_emval,\n      \"__embind_register_enum\": __embind_register_enum,\n      \"__embind_register_enum_value\": __embind_register_enum_value,\n      \"__embind_register_float\": __embind_register_float,\n      \"__embind_register_function\": __embind_register_function,\n      \"__embind_register_integer\": __embind_register_integer,\n      \"__embind_register_memory_view\": __embind_register_memory_view,\n      \"__embind_register_std_string\": __embind_register_std_string,\n      \"__embind_register_std_wstring\": __embind_register_std_wstring,\n      \"__embind_register_void\": __embind_register_void,\n      \"__emval_decref\": __emval_decref,\n      \"__emval_incref\": __emval_incref,\n      \"__emval_register\": __emval_register,\n      \"__emval_take_value\": __emval_take_value,\n      \"_abort\": _abort,\n      \"_embind_repr\": _embind_repr,\n      \"_emscripten_get_heap_size\": _emscripten_get_heap_size,\n      \"_emscripten_memcpy_big\": _emscripten_memcpy_big,\n      \"_emscripten_resize_heap\": _emscripten_resize_heap,\n      \"_llvm_trap\": _llvm_trap,\n      \"abortOnCannotGrowMemory\": abortOnCannotGrowMemory,\n      \"attachFinalizer\": attachFinalizer,\n      \"constNoSmartPtrRawPointerToWireType\": constNoSmartPtrRawPointerToWireType,\n      \"count_emval_handles\": count_emval_handles,\n      \"craftInvokerFunction\": craftInvokerFunction,\n      \"createNamedFunction\": createNamedFunction,\n      \"detachFinalizer\": detachFinalizer,\n      \"downcastPointer\": downcastPointer,\n      \"embind__requireFunction\": embind__requireFunction,\n      \"embind_init_charCodes\": embind_init_charCodes,\n      \"emscripten_realloc_buffer\": emscripten_realloc_buffer,\n      \"ensureOverloadTable\": ensureOverloadTable,\n      \"enumReadValueFromPointer\": enumReadValueFromPointer,\n      \"exposePublicSymbol\": exposePublicSymbol,\n      \"extendError\": extendError,\n      \"floatReadValueFromPointer\": floatReadValueFromPointer,\n      \"flushPendingDeletes\": flushPendingDeletes,\n      \"flush_NO_FILESYSTEM\": flush_NO_FILESYSTEM,\n      \"genericPointerToWireType\": genericPointerToWireType,\n      \"getBasestPointer\": getBasestPointer,\n      \"getInheritedInstance\": getInheritedInstance,\n      \"getInheritedInstanceCount\": getInheritedInstanceCount,\n      \"getLiveInheritedInstances\": getLiveInheritedInstances,\n      \"getShiftFromSize\": getShiftFromSize,\n      \"getTypeName\": getTypeName,\n      \"get_first_emval\": get_first_emval,\n      \"heap32VectorToArray\": heap32VectorToArray,\n      \"init_ClassHandle\": init_ClassHandle,\n      \"init_RegisteredPointer\": init_RegisteredPointer,\n      \"init_embind\": init_embind,\n      \"init_emval\": init_emval,\n      \"integerReadValueFromPointer\": integerReadValueFromPointer,\n      \"makeClassHandle\": makeClassHandle,\n      \"makeLegalFunctionName\": makeLegalFunctionName,\n      \"new_\": new_,\n      \"nonConstNoSmartPtrRawPointerToWireType\": nonConstNoSmartPtrRawPointerToWireType,\n      \"readLatin1String\": readLatin1String,\n      \"registerType\": registerType,\n      \"releaseClassHandle\": releaseClassHandle,\n      \"replacePublicSymbol\": replacePublicSymbol,\n      \"requireRegisteredType\": requireRegisteredType,\n      \"runDestructor\": runDestructor,\n      \"runDestructors\": runDestructors,\n      \"setDelayFunction\": setDelayFunction,\n      \"shallowCopyInternalPointer\": shallowCopyInternalPointer,\n      \"simpleReadValueFromPointer\": simpleReadValueFromPointer,\n      \"throwBindingError\": throwBindingError,\n      \"throwInstanceAlreadyDeleted\": throwInstanceAlreadyDeleted,\n      \"throwInternalError\": throwInternalError,\n      \"throwUnboundTypeError\": throwUnboundTypeError,\n      \"upcastPointer\": upcastPointer,\n      \"validateThis\": validateThis,\n      \"whenDependentTypesAreResolved\": whenDependentTypesAreResolved,\n      \"tempDoublePtr\": tempDoublePtr,\n      \"DYNAMICTOP_PTR\": DYNAMICTOP_PTR\n    }; // EMSCRIPTEN_START_ASM\n\n    var asm = Module[\"asm\"] // EMSCRIPTEN_END_ASM\n    (asmGlobalArg, asmLibraryArg, buffer);\n    var real___ZSt18uncaught_exceptionv = asm[\"__ZSt18uncaught_exceptionv\"];\n\n    asm[\"__ZSt18uncaught_exceptionv\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real___ZSt18uncaught_exceptionv.apply(null, arguments);\n    };\n\n    var real____cxa_can_catch = asm[\"___cxa_can_catch\"];\n\n    asm[\"___cxa_can_catch\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real____cxa_can_catch.apply(null, arguments);\n    };\n\n    var real____cxa_is_pointer_type = asm[\"___cxa_is_pointer_type\"];\n\n    asm[\"___cxa_is_pointer_type\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real____cxa_is_pointer_type.apply(null, arguments);\n    };\n\n    var real____embind_register_native_and_builtin_types = asm[\"___embind_register_native_and_builtin_types\"];\n\n    asm[\"___embind_register_native_and_builtin_types\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real____embind_register_native_and_builtin_types.apply(null, arguments);\n    };\n\n    var real____errno_location = asm[\"___errno_location\"];\n\n    asm[\"___errno_location\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real____errno_location.apply(null, arguments);\n    };\n\n    var real____getTypeName = asm[\"___getTypeName\"];\n\n    asm[\"___getTypeName\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real____getTypeName.apply(null, arguments);\n    };\n\n    var real__fflush = asm[\"_fflush\"];\n\n    asm[\"_fflush\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real__fflush.apply(null, arguments);\n    };\n\n    var real__free = asm[\"_free\"];\n\n    asm[\"_free\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real__free.apply(null, arguments);\n    };\n\n    var real__llvm_round_f32 = asm[\"_llvm_round_f32\"];\n\n    asm[\"_llvm_round_f32\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real__llvm_round_f32.apply(null, arguments);\n    };\n\n    var real__malloc = asm[\"_malloc\"];\n\n    asm[\"_malloc\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real__malloc.apply(null, arguments);\n    };\n\n    var real__memmove = asm[\"_memmove\"];\n\n    asm[\"_memmove\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real__memmove.apply(null, arguments);\n    };\n\n    var real__sbrk = asm[\"_sbrk\"];\n\n    asm[\"_sbrk\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real__sbrk.apply(null, arguments);\n    };\n\n    var real_establishStackSpace = asm[\"establishStackSpace\"];\n\n    asm[\"establishStackSpace\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real_establishStackSpace.apply(null, arguments);\n    };\n\n    var real_globalCtors = asm[\"globalCtors\"];\n\n    asm[\"globalCtors\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real_globalCtors.apply(null, arguments);\n    };\n\n    var real_stackAlloc = asm[\"stackAlloc\"];\n\n    asm[\"stackAlloc\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real_stackAlloc.apply(null, arguments);\n    };\n\n    var real_stackRestore = asm[\"stackRestore\"];\n\n    asm[\"stackRestore\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real_stackRestore.apply(null, arguments);\n    };\n\n    var real_stackSave = asm[\"stackSave\"];\n\n    asm[\"stackSave\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real_stackSave.apply(null, arguments);\n    };\n\n    Module[\"asm\"] = asm;\n\n    var __ZSt18uncaught_exceptionv = Module[\"__ZSt18uncaught_exceptionv\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"__ZSt18uncaught_exceptionv\"].apply(null, arguments);\n    };\n\n    var ___cxa_can_catch = Module[\"___cxa_can_catch\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"___cxa_can_catch\"].apply(null, arguments);\n    };\n\n    var ___cxa_is_pointer_type = Module[\"___cxa_is_pointer_type\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"___cxa_is_pointer_type\"].apply(null, arguments);\n    };\n\n    var ___embind_register_native_and_builtin_types = Module[\"___embind_register_native_and_builtin_types\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"___embind_register_native_and_builtin_types\"].apply(null, arguments);\n    };\n\n    var ___errno_location = Module[\"___errno_location\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"___errno_location\"].apply(null, arguments);\n    };\n\n    var ___getTypeName = Module[\"___getTypeName\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"___getTypeName\"].apply(null, arguments);\n    };\n\n    var _emscripten_replace_memory = Module[\"_emscripten_replace_memory\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"_emscripten_replace_memory\"].apply(null, arguments);\n    };\n\n    var _fflush = Module[\"_fflush\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"_fflush\"].apply(null, arguments);\n    };\n\n    var _free = Module[\"_free\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"_free\"].apply(null, arguments);\n    };\n\n    var _llvm_round_f32 = Module[\"_llvm_round_f32\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"_llvm_round_f32\"].apply(null, arguments);\n    };\n\n    var _malloc = Module[\"_malloc\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"_malloc\"].apply(null, arguments);\n    };\n\n    var _memcpy = Module[\"_memcpy\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"_memcpy\"].apply(null, arguments);\n    };\n\n    var _memmove = Module[\"_memmove\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"_memmove\"].apply(null, arguments);\n    };\n\n    var _memset = Module[\"_memset\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"_memset\"].apply(null, arguments);\n    };\n\n    var _sbrk = Module[\"_sbrk\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"_sbrk\"].apply(null, arguments);\n    };\n\n    var establishStackSpace = Module[\"establishStackSpace\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"establishStackSpace\"].apply(null, arguments);\n    };\n\n    var globalCtors = Module[\"globalCtors\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"globalCtors\"].apply(null, arguments);\n    };\n\n    var stackAlloc = Module[\"stackAlloc\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"stackAlloc\"].apply(null, arguments);\n    };\n\n    var stackRestore = Module[\"stackRestore\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"stackRestore\"].apply(null, arguments);\n    };\n\n    var stackSave = Module[\"stackSave\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"stackSave\"].apply(null, arguments);\n    };\n\n    var dynCall_fii = Module[\"dynCall_fii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_fii\"].apply(null, arguments);\n    };\n\n    var dynCall_i = Module[\"dynCall_i\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_i\"].apply(null, arguments);\n    };\n\n    var dynCall_ii = Module[\"dynCall_ii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_ii\"].apply(null, arguments);\n    };\n\n    var dynCall_iidiiii = Module[\"dynCall_iidiiii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_iidiiii\"].apply(null, arguments);\n    };\n\n    var dynCall_iii = Module[\"dynCall_iii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_iii\"].apply(null, arguments);\n    };\n\n    var dynCall_iiii = Module[\"dynCall_iiii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_iiii\"].apply(null, arguments);\n    };\n\n    var dynCall_iiiii = Module[\"dynCall_iiiii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_iiiii\"].apply(null, arguments);\n    };\n\n    var dynCall_iiiiii = Module[\"dynCall_iiiiii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_iiiiii\"].apply(null, arguments);\n    };\n\n    var dynCall_jiji = Module[\"dynCall_jiji\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_jiji\"].apply(null, arguments);\n    };\n\n    var dynCall_v = Module[\"dynCall_v\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_v\"].apply(null, arguments);\n    };\n\n    var dynCall_vi = Module[\"dynCall_vi\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_vi\"].apply(null, arguments);\n    };\n\n    var dynCall_vii = Module[\"dynCall_vii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_vii\"].apply(null, arguments);\n    };\n\n    var dynCall_viif = Module[\"dynCall_viif\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_viif\"].apply(null, arguments);\n    };\n\n    var dynCall_viii = Module[\"dynCall_viii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_viii\"].apply(null, arguments);\n    };\n\n    var dynCall_viiii = Module[\"dynCall_viiii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_viiii\"].apply(null, arguments);\n    };\n\n    var dynCall_viiiii = Module[\"dynCall_viiiii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_viiiii\"].apply(null, arguments);\n    };\n\n    var dynCall_viiiiii = Module[\"dynCall_viiiiii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_viiiiii\"].apply(null, arguments);\n    };\n\n    ; // === Auto-generated postamble setup entry stuff ===\n\n    Module['asm'] = asm;\n    if (!Module[\"intArrayFromString\"]) Module[\"intArrayFromString\"] = function () {\n      abort(\"'intArrayFromString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"intArrayToString\"]) Module[\"intArrayToString\"] = function () {\n      abort(\"'intArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"ccall\"]) Module[\"ccall\"] = function () {\n      abort(\"'ccall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"cwrap\"]) Module[\"cwrap\"] = function () {\n      abort(\"'cwrap' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"setValue\"]) Module[\"setValue\"] = function () {\n      abort(\"'setValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"getValue\"]) Module[\"getValue\"] = function () {\n      abort(\"'getValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"allocate\"]) Module[\"allocate\"] = function () {\n      abort(\"'allocate' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"getMemory\"]) Module[\"getMemory\"] = function () {\n      abort(\"'getMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"AsciiToString\"]) Module[\"AsciiToString\"] = function () {\n      abort(\"'AsciiToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"stringToAscii\"]) Module[\"stringToAscii\"] = function () {\n      abort(\"'stringToAscii' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"UTF8ArrayToString\"]) Module[\"UTF8ArrayToString\"] = function () {\n      abort(\"'UTF8ArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"UTF8ToString\"]) Module[\"UTF8ToString\"] = function () {\n      abort(\"'UTF8ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"stringToUTF8Array\"]) Module[\"stringToUTF8Array\"] = function () {\n      abort(\"'stringToUTF8Array' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"stringToUTF8\"]) Module[\"stringToUTF8\"] = function () {\n      abort(\"'stringToUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"lengthBytesUTF8\"]) Module[\"lengthBytesUTF8\"] = function () {\n      abort(\"'lengthBytesUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"UTF16ToString\"]) Module[\"UTF16ToString\"] = function () {\n      abort(\"'UTF16ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"stringToUTF16\"]) Module[\"stringToUTF16\"] = function () {\n      abort(\"'stringToUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"lengthBytesUTF16\"]) Module[\"lengthBytesUTF16\"] = function () {\n      abort(\"'lengthBytesUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"UTF32ToString\"]) Module[\"UTF32ToString\"] = function () {\n      abort(\"'UTF32ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"stringToUTF32\"]) Module[\"stringToUTF32\"] = function () {\n      abort(\"'stringToUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"lengthBytesUTF32\"]) Module[\"lengthBytesUTF32\"] = function () {\n      abort(\"'lengthBytesUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"allocateUTF8\"]) Module[\"allocateUTF8\"] = function () {\n      abort(\"'allocateUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"stackTrace\"]) Module[\"stackTrace\"] = function () {\n      abort(\"'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"addOnPreRun\"]) Module[\"addOnPreRun\"] = function () {\n      abort(\"'addOnPreRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"addOnInit\"]) Module[\"addOnInit\"] = function () {\n      abort(\"'addOnInit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"addOnPreMain\"]) Module[\"addOnPreMain\"] = function () {\n      abort(\"'addOnPreMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"addOnExit\"]) Module[\"addOnExit\"] = function () {\n      abort(\"'addOnExit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"addOnPostRun\"]) Module[\"addOnPostRun\"] = function () {\n      abort(\"'addOnPostRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"writeStringToMemory\"]) Module[\"writeStringToMemory\"] = function () {\n      abort(\"'writeStringToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"writeArrayToMemory\"]) Module[\"writeArrayToMemory\"] = function () {\n      abort(\"'writeArrayToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"writeAsciiToMemory\"]) Module[\"writeAsciiToMemory\"] = function () {\n      abort(\"'writeAsciiToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"addRunDependency\"]) Module[\"addRunDependency\"] = function () {\n      abort(\"'addRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"removeRunDependency\"]) Module[\"removeRunDependency\"] = function () {\n      abort(\"'removeRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"ENV\"]) Module[\"ENV\"] = function () {\n      abort(\"'ENV' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"FS\"]) Module[\"FS\"] = function () {\n      abort(\"'FS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"FS_createFolder\"]) Module[\"FS_createFolder\"] = function () {\n      abort(\"'FS_createFolder' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"FS_createPath\"]) Module[\"FS_createPath\"] = function () {\n      abort(\"'FS_createPath' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"FS_createDataFile\"]) Module[\"FS_createDataFile\"] = function () {\n      abort(\"'FS_createDataFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"FS_createPreloadedFile\"]) Module[\"FS_createPreloadedFile\"] = function () {\n      abort(\"'FS_createPreloadedFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"FS_createLazyFile\"]) Module[\"FS_createLazyFile\"] = function () {\n      abort(\"'FS_createLazyFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"FS_createLink\"]) Module[\"FS_createLink\"] = function () {\n      abort(\"'FS_createLink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"FS_createDevice\"]) Module[\"FS_createDevice\"] = function () {\n      abort(\"'FS_createDevice' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"FS_unlink\"]) Module[\"FS_unlink\"] = function () {\n      abort(\"'FS_unlink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"GL\"]) Module[\"GL\"] = function () {\n      abort(\"'GL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"dynamicAlloc\"]) Module[\"dynamicAlloc\"] = function () {\n      abort(\"'dynamicAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"warnOnce\"]) Module[\"warnOnce\"] = function () {\n      abort(\"'warnOnce' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"loadDynamicLibrary\"]) Module[\"loadDynamicLibrary\"] = function () {\n      abort(\"'loadDynamicLibrary' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"loadWebAssemblyModule\"]) Module[\"loadWebAssemblyModule\"] = function () {\n      abort(\"'loadWebAssemblyModule' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"getLEB\"]) Module[\"getLEB\"] = function () {\n      abort(\"'getLEB' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"getFunctionTables\"]) Module[\"getFunctionTables\"] = function () {\n      abort(\"'getFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"alignFunctionTables\"]) Module[\"alignFunctionTables\"] = function () {\n      abort(\"'alignFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"registerFunctions\"]) Module[\"registerFunctions\"] = function () {\n      abort(\"'registerFunctions' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"addFunction\"]) Module[\"addFunction\"] = function () {\n      abort(\"'addFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"removeFunction\"]) Module[\"removeFunction\"] = function () {\n      abort(\"'removeFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"getFuncWrapper\"]) Module[\"getFuncWrapper\"] = function () {\n      abort(\"'getFuncWrapper' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"prettyPrint\"]) Module[\"prettyPrint\"] = function () {\n      abort(\"'prettyPrint' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"makeBigInt\"]) Module[\"makeBigInt\"] = function () {\n      abort(\"'makeBigInt' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"dynCall\"]) Module[\"dynCall\"] = function () {\n      abort(\"'dynCall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"getCompilerSetting\"]) Module[\"getCompilerSetting\"] = function () {\n      abort(\"'getCompilerSetting' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"stackSave\"]) Module[\"stackSave\"] = function () {\n      abort(\"'stackSave' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"stackRestore\"]) Module[\"stackRestore\"] = function () {\n      abort(\"'stackRestore' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"stackAlloc\"]) Module[\"stackAlloc\"] = function () {\n      abort(\"'stackAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"establishStackSpace\"]) Module[\"establishStackSpace\"] = function () {\n      abort(\"'establishStackSpace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"print\"]) Module[\"print\"] = function () {\n      abort(\"'print' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"printErr\"]) Module[\"printErr\"] = function () {\n      abort(\"'printErr' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"getTempRet0\"]) Module[\"getTempRet0\"] = function () {\n      abort(\"'getTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"setTempRet0\"]) Module[\"setTempRet0\"] = function () {\n      abort(\"'setTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"Pointer_stringify\"]) Module[\"Pointer_stringify\"] = function () {\n      abort(\"'Pointer_stringify' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"writeStackCookie\"]) Module[\"writeStackCookie\"] = function () {\n      abort(\"'writeStackCookie' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"checkStackCookie\"]) Module[\"checkStackCookie\"] = function () {\n      abort(\"'checkStackCookie' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"abortStackOverflow\"]) Module[\"abortStackOverflow\"] = function () {\n      abort(\"'abortStackOverflow' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"ALLOC_NORMAL\"]) Object.defineProperty(Module, \"ALLOC_NORMAL\", {\n      get: function () {\n        abort(\"'ALLOC_NORMAL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      }\n    });\n    if (!Module[\"ALLOC_STACK\"]) Object.defineProperty(Module, \"ALLOC_STACK\", {\n      get: function () {\n        abort(\"'ALLOC_STACK' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      }\n    });\n    if (!Module[\"ALLOC_DYNAMIC\"]) Object.defineProperty(Module, \"ALLOC_DYNAMIC\", {\n      get: function () {\n        abort(\"'ALLOC_DYNAMIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      }\n    });\n    if (!Module[\"ALLOC_NONE\"]) Object.defineProperty(Module, \"ALLOC_NONE\", {\n      get: function () {\n        abort(\"'ALLOC_NONE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      }\n    }); // Modularize mode returns a function, which can be called to\n    // create instances. The instances provide a then() method,\n    // must like a Promise, that receives a callback. The callback\n    // is called when the module is ready to run, with the module\n    // as a parameter. (Like a Promise, it also returns the module\n    // so you can use the output of .then(..)).\n\n    Module['then'] = function (func) {\n      // We may already be ready to run code at this time. if\n      // so, just queue a call to the callback.\n      if (Module['calledRun']) {\n        func(Module);\n      } else {\n        // we are not ready to call then() yet. we must call it\n        // at the same time we would call onRuntimeInitialized.\n        var old = Module['onRuntimeInitialized'];\n\n        Module['onRuntimeInitialized'] = function () {\n          if (old) old();\n          func(Module);\n        };\n      }\n\n      return Module;\n    };\n    /**\n     * @constructor\n     * @extends {Error}\n     * @this {ExitStatus}\n     */\n\n\n    function ExitStatus(status) {\n      this.name = \"ExitStatus\";\n      this.message = \"Program terminated with exit(\" + status + \")\";\n      this.status = status;\n    }\n\n    ;\n    ExitStatus.prototype = new Error();\n    ExitStatus.prototype.constructor = ExitStatus;\n    var calledMain = false;\n\n    dependenciesFulfilled = function runCaller() {\n      // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)\n      if (!Module['calledRun']) run();\n      if (!Module['calledRun']) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled\n    };\n    /** @type {function(Array=)} */\n\n\n    function run(args) {\n      args = args || Module['arguments'];\n\n      if (runDependencies > 0) {\n        return;\n      }\n\n      writeStackCookie();\n      preRun();\n      if (runDependencies > 0) return; // a preRun added a dependency, run will be called later\n\n      if (Module['calledRun']) return; // run may have just been called through dependencies being fulfilled just in this very frame\n\n      function doRun() {\n        if (Module['calledRun']) return; // run may have just been called while the async setStatus time below was happening\n\n        Module['calledRun'] = true;\n        if (ABORT) return;\n        initRuntime();\n        preMain();\n        if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();\n        assert(!Module['_main'], 'compiled without a main, but one is present. if you added it from JS, use Module[\"onRuntimeInitialized\"]');\n        postRun();\n      }\n\n      if (Module['setStatus']) {\n        Module['setStatus']('Running...');\n        setTimeout(function () {\n          setTimeout(function () {\n            Module['setStatus']('');\n          }, 1);\n          doRun();\n        }, 1);\n      } else {\n        doRun();\n      }\n\n      checkStackCookie();\n    }\n\n    Module['run'] = run;\n\n    function checkUnflushedContent() {\n      // Compiler settings do not allow exiting the runtime, so flushing\n      // the streams is not possible. but in ASSERTIONS mode we check\n      // if there was something to flush, and if so tell the user they\n      // should request that the runtime be exitable.\n      // Normally we would not even include flush() at all, but in ASSERTIONS\n      // builds we do so just for this check, and here we see if there is any\n      // content to flush, that is, we check if there would have been\n      // something a non-ASSERTIONS build would have not seen.\n      // How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0\n      // mode (which has its own special function for this; otherwise, all\n      // the code is inside libc)\n      var print = out;\n      var printErr = err;\n      var has = false;\n\n      out = err = function (x) {\n        has = true;\n      };\n\n      try {\n        // it doesn't matter if it fails\n        var flush = flush_NO_FILESYSTEM;\n        if (flush) flush(0);\n      } catch (e) {}\n\n      out = print;\n      err = printErr;\n\n      if (has) {\n        warnOnce('stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the FAQ), or make sure to emit a newline when you printf etc.');\n        warnOnce('(this may also be due to not including full filesystem support - try building with -s FORCE_FILESYSTEM=1)');\n      }\n    }\n\n    function exit(status, implicit) {\n      checkUnflushedContent(); // if this is just main exit-ing implicitly, and the status is 0, then we\n      // don't need to do anything here and can just leave. if the status is\n      // non-zero, though, then we need to report it.\n      // (we may have warned about this earlier, if a situation justifies doing so)\n\n      if (implicit && Module['noExitRuntime'] && status === 0) {\n        return;\n      }\n\n      if (Module['noExitRuntime']) {\n        // if exit() was called, we may warn the user if the runtime isn't actually being shut down\n        if (!implicit) {\n          err('exit(' + status + ') called, but EXIT_RUNTIME is not set, so halting execution but not exiting the runtime or preventing further async execution (build with EXIT_RUNTIME=1, if you want a true shutdown)');\n        }\n      } else {\n        ABORT = true;\n        EXITSTATUS = status;\n        exitRuntime();\n        if (Module['onExit']) Module['onExit'](status);\n      }\n\n      Module['quit'](status, new ExitStatus(status));\n    }\n\n    var abortDecorators = [];\n\n    function abort(what) {\n      if (Module['onAbort']) {\n        Module['onAbort'](what);\n      }\n\n      if (what !== undefined) {\n        out(what);\n        err(what);\n        what = '\"' + what + '\"';\n      } else {\n        what = '';\n      }\n\n      ABORT = true;\n      EXITSTATUS = 1;\n      var extra = '';\n      var output = 'abort(' + what + ') at ' + stackTrace() + extra;\n\n      if (abortDecorators) {\n        abortDecorators.forEach(function (decorator) {\n          output = decorator(output, what);\n        });\n      }\n\n      throw output;\n    }\n\n    Module['abort'] = abort;\n\n    if (Module['preInit']) {\n      if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];\n\n      while (Module['preInit'].length > 0) {\n        Module['preInit'].pop()();\n      }\n    }\n\n    Module[\"noExitRuntime\"] = true;\n    run(); // {{MODULE_ADDITIONS}}\n\n    return GradientCaptureCore;\n  };\n}();\n\nif (true) module.exports = GradientCaptureCoreScript;else {}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ \"./node_modules/process/browser.js\"), \"/\"))\n\n//# sourceURL=webpack:///./node_modules/@capture/gradient-core/src/GradientCaptureCoreScript.js?");

/***/ }),

/***/ "./node_modules/@capture/gradient-core/src/GradientExtractor.worker.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@capture/gradient-core/src/GradientExtractor.worker.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _GradientExtractorHelper = _interopRequireDefault(__webpack_require__(/*! ./GradientExtractorHelper */ \"./node_modules/@capture/gradient-core/src/GradientExtractorHelper.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nself.addEventListener('message', function (options) {\n  const postResult = extractedData => {\n    // had to check this because while running UT this in listener is undefined\n    if (this) {\n      this.postMessage(extractedData);\n    } else {\n      self.postMessage(extractedData);\n    }\n  };\n\n  let extractor = new _GradientExtractorHelper.default();\n\n  if (options.data.path) {\n    extractor.extractGradientFromPath(options.data.imageData, options.data.width, options.data.height, options.data.stopsCount, options.data.path).then(extractedData => postResult(extractedData));\n  } else {\n    extractor.extractGradientFrom(options.data.imageData, options.data.width, options.data.height, options.data.stopsCount).then(extractedData => postResult(extractedData));\n  }\n}, false);\nself.addEventListener('error', function () {\n  // error returned here\n  self.postMessage('Error');\n}, false);\n\n//# sourceURL=webpack:///./node_modules/@capture/gradient-core/src/GradientExtractor.worker.js?");

/***/ }),

/***/ "./node_modules/@capture/gradient-core/src/GradientExtractorHelper.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@capture/gradient-core/src/GradientExtractorHelper.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _GradientCaptureCoreScript = _interopRequireDefault(__webpack_require__(/*! ./GradientCaptureCoreScript */ \"./node_modules/@capture/gradient-core/src/GradientCaptureCoreScript.js\"));\n\nvar _GradientCaptureCore = _interopRequireDefault(__webpack_require__(/*! ./GradientCaptureCore.wasm */ \"./node_modules/@capture/gradient-core/src/GradientCaptureCore.wasm\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst gradientCore = (0, _GradientCaptureCoreScript.default)({\n  locateFile: path => {\n    return path.endsWith('.wasm') ? _GradientCaptureCore.default : path;\n  },\n  readBinary: () => {\n    var arrayBuffer = new ArrayBuffer(_GradientCaptureCore.default.data.length);\n    var view = new Uint8Array(arrayBuffer);\n\n    for (var i = 0; i < _GradientCaptureCore.default.data.length; ++i) {\n      view[i] = _GradientCaptureCore.default.data[i];\n    }\n\n    return arrayBuffer;\n  }\n});\n\ngradientCore.onRuntimeInitialized = () => {\n  GradientExtractorHelper.available = true;\n};\n\nclass GradientExtractorHelper {\n  constructor() {\n    this.gradientCore = gradientCore;\n  }\n\n  extractGradientFrom(imageData, width, height, numStops) {\n    return new Promise(resolve => {\n      this.gradientCore.then(_ => {\n        const [bmp, heapBytes] = this._createBitmapFromImageData(imageData, width, height);\n\n        const gradientCoreResult = this.gradientCore.extractGradientFromImage(bmp, numStops);\n\n        const jsResult = this._createGradientReturnResultFromCoreResult(gradientCoreResult);\n\n        this._cleanUpCoreMemoryCommon(bmp, heapBytes, gradientCoreResult);\n\n        resolve(jsResult);\n      });\n    });\n  }\n\n  extractGradientFromPath(imageData, width, height, numStops, path) {\n    return new Promise(resolve => {\n      this.gradientCore.then(_ => {\n        const [bmp, heapBytes] = this._createBitmapFromImageData(imageData, width, height);\n\n        const corePath = new this.gradientCore.PositionVector();\n        path.forEach(pt => corePath.push_back(new this.gradientCore.Position(pt.x, pt.y)));\n        const gradientCoreResult = this.gradientCore.extractGradientFromImagePath(bmp, numStops, corePath);\n\n        const jsResult = this._createGradientReturnResultFromCoreResult(gradientCoreResult);\n\n        this._cleanUpCoreMemory(bmp, heapBytes, gradientCoreResult, corePath);\n\n        resolve(jsResult);\n      });\n    });\n  }\n\n  _createGradientReturnResultFromCoreResult(coreResult) {\n    const jsResult = [];\n\n    for (let i = 0; i < coreResult.size(); i++) {\n      const gradientStops = coreResult.get(i).stops;\n      const jsStops = [];\n\n      for (let j = 0; j < gradientStops.size(); j++) {\n        const stop = gradientStops.get(j);\n        jsStops.push({\n          color: {\n            r: stop.colorValue.r,\n            g: stop.colorValue.g,\n            b: stop.colorValue.b,\n            a: stop.colorValue.a\n          },\n          offset: stop.offset,\n          position: {\n            x: stop.position.xPosition,\n            y: stop.position.yPosition\n          }\n        });\n      }\n\n      jsResult.push(jsStops);\n    }\n\n    return jsResult;\n  }\n\n  _createBitmapFromImageData(imageData, width, height) {\n    const numBytes = width * height * 4;\n\n    const ptr = this.gradientCore._malloc(numBytes);\n\n    const heapBytes = new Uint8Array(this.gradientCore.HEAPU8.buffer, ptr, numBytes);\n    heapBytes.set(new Uint8Array(imageData.data));\n    const bmp = new this.gradientCore.BitmapData_RGBA32(heapBytes.byteOffset, width, height);\n    return [bmp, heapBytes];\n  }\n\n  _cleanUpCoreMemoryCommon(bmp, heapBytes, gradientCoreResult) {\n    bmp.delete();\n    gradientCoreResult.delete();\n\n    this.gradientCore._free(heapBytes.byteOffset);\n  }\n\n  _cleanUpCoreMemory(bmp, heapBytes, gradientCoreResult, corePath) {\n    this._cleanUpCoreMemoryCommon(bmp, heapBytes, gradientCoreResult);\n\n    corePath.delete();\n  }\n\n}\n\nexports.default = GradientExtractorHelper;\nGradientExtractorHelper.available = false;\n\n//# sourceURL=webpack:///./node_modules/@capture/gradient-core/src/GradientExtractorHelper.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ })

/******/ });
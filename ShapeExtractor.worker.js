/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./node_modules/@capture/shape-core/src/ShapeExtractor.worker.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@capture/shape-core/src/ShapeExtractor.worker.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@capture/shape-core/src/ShapeExtractor.worker.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _Vectorize = _interopRequireDefault(__webpack_require__(/*! ./vectorize/Vectorize */ \"./node_modules/@capture/shape-core/src/vectorize/Vectorize.js\"));\n\nvar _Cornucopia = _interopRequireDefault(__webpack_require__(/*! ./cornucopia/Cornucopia */ \"./node_modules/@capture/shape-core/src/cornucopia/Cornucopia.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nself.addEventListener('message', function (options) {\n  let result = null;\n\n  if (options.data.isSmoothingEnabled) {\n    result = _Cornucopia.default.process(options.data.imageData, options.data.width, options.data.height);\n  } else {\n    result = _Vectorize.default.process(options.data.imageData, options.data.width, options.data.height);\n  } // had to check this because while running UT this in listener is undefined\n\n\n  if (this) {\n    this.postMessage(result);\n  } else {\n    self.postMessage(result);\n  }\n}, false);\nself.addEventListener('error', function () {\n  // error returned here\n  self.postMessage('Error');\n}, false);\n\n//# sourceURL=webpack:///./node_modules/@capture/shape-core/src/ShapeExtractor.worker.js?");

/***/ }),

/***/ "./node_modules/@capture/shape-core/src/cornucopia/Cornucopia.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@capture/shape-core/src/cornucopia/Cornucopia.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _SVGHelper = _interopRequireDefault(__webpack_require__(/*! ../helpers/SVGHelper */ \"./node_modules/@capture/shape-core/src/helpers/SVGHelper.js\"));\n\nvar _CornucopiaCore = _interopRequireDefault(__webpack_require__(/*! ./CornucopiaCore */ \"./node_modules/@capture/shape-core/src/cornucopia/CornucopiaCore.js\"));\n\nvar _CornucopiaCore2 = _interopRequireDefault(__webpack_require__(/*! ./CornucopiaCore.wasm */ \"./node_modules/@capture/shape-core/src/cornucopia/CornucopiaCore.wasm\"));\n\nvar _Vectorize = _interopRequireDefault(__webpack_require__(/*! ../vectorize/Vectorize */ \"./node_modules/@capture/shape-core/src/vectorize/Vectorize.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst cornucopiaCore = (0, _CornucopiaCore.default)({\n  locateFile: path => {\n    return path === 'CornucopiaCore.wasm' ? _CornucopiaCore2.default : path;\n  },\n  readBinary: () => {\n    var arrayBuffer = new ArrayBuffer(_CornucopiaCore2.default.data.length);\n    var view = new Uint8Array(arrayBuffer);\n\n    for (var i = 0; i < _CornucopiaCore2.default.data.length; ++i) {\n      view[i] = _CornucopiaCore2.default.data[i];\n    }\n\n    return arrayBuffer;\n  }\n});\n\ncornucopiaCore.onRuntimeInitialized = () => {\n  Cornucopia.available = true;\n};\n\nclass Cornucopia {\n  static process(imageData, width, height) {\n    if (!this.available) {\n      return null;\n    } // sanity checks on data\n\n\n    if (typeof imageData === 'undefined' || typeof width !== 'number' || typeof height !== 'number' || typeof imageData.length !== 'number' || imageData.length !== 4 * width * height) {\n      return null;\n    }\n\n    const vectorPaths = _Vectorize.default.process(imageData, width, height, false).paths;\n\n    if (this._cornucopiaExport === null) {\n      this._cornucopiaExport = new cornucopiaCore.CornucopiaExport();\n    }\n\n    var paths = []; // begin SVG data\n\n    var svg = _SVGHelper.default.beginShape(width, height);\n\n    while (vectorPaths.length !== 0) {\n      // get the vector be smoothened\n      var vectorToSmoothen = vectorPaths.pop(); // begin svg path\n\n      var svgPath = _SVGHelper.default.beginPath(); // this is the paths array\n\n\n      var subPaths = []; // iterate over the number of paths in this vectors\n\n      for (var j = 0; j < vectorToSmoothen.length; j++) {\n        // get the path data\n        var subPath = vectorToSmoothen[j]; // begin this cornucopia curve\n\n        this._cornucopiaExport.BeginCurve(); // add the vertices for this path in the curve\n\n\n        for (var k = 0; k < subPath.length; k += 2) {\n          this._cornucopiaExport.AddPoint(subPath[k], subPath[k + 1]);\n        } // do the curve fitting and get the number of bezier vertices in this path\n\n\n        this._cornucopiaExport.FitCurve(); // array which will store the vertices data for this path (output from cornucopia)\n\n\n        var vertexData = [];\n\n        while (this._cornucopiaExport.NextBezier()) {\n          // for the first curve add the first point as well\n          if (vertexData.length === 0) {\n            vertexData.push(this._cornucopiaExport.GetPointX(0), this._cornucopiaExport.GetPointY(0));\n          }\n\n          vertexData.push(this._cornucopiaExport.GetPointX(1), this._cornucopiaExport.GetPointY(1));\n          vertexData.push(this._cornucopiaExport.GetPointX(2), this._cornucopiaExport.GetPointY(2));\n          vertexData.push(this._cornucopiaExport.GetPointX(3), this._cornucopiaExport.GetPointY(3));\n        }\n\n        svgPath += _SVGHelper.default.addPath(vertexData, true, height);\n        subPaths.push(vertexData);\n      }\n\n      svgPath += _SVGHelper.default.endPath();\n\n      if (subPath.length > 0) {\n        svg += svgPath;\n        paths.push(subPaths);\n      }\n    }\n\n    svg += _SVGHelper.default.endShape();\n    return {\n      paths,\n      svg\n    };\n  }\n\n}\n\nexports.default = Cornucopia;\nCornucopia.available = false;\nCornucopia._cornucopiaExport = null;\n\n//# sourceURL=webpack:///./node_modules/@capture/shape-core/src/cornucopia/Cornucopia.js?");

/***/ }),

/***/ "./node_modules/@capture/shape-core/src/cornucopia/CornucopiaCore.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@capture/shape-core/src/cornucopia/CornucopiaCore.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process, __dirname, Buffer) {var require;\n\n/* eslint-disable */\nvar Module = function () {\n  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;\n\n  return function (Module) {\n    Module = Module || {};\n\n    if (typeof window === 'undefined') {\n      var window = self;\n    }\n\n    require = window.nodeRequire;\n    var Module = typeof Module !== \"undefined\" ? Module : {};\n    var moduleOverrides = {};\n    var key;\n\n    for (key in Module) {\n      if (Module.hasOwnProperty(key)) {\n        moduleOverrides[key] = Module[key];\n      }\n    }\n\n    Module[\"arguments\"] = [];\n    Module[\"thisProgram\"] = \"./this.program\";\n\n    Module[\"quit\"] = function (status, toThrow) {\n      throw toThrow;\n    };\n\n    Module[\"preRun\"] = [];\n    Module[\"postRun\"] = [];\n    var ENVIRONMENT_IS_WEB = false;\n    var ENVIRONMENT_IS_WORKER = false;\n    var ENVIRONMENT_IS_NODE = false;\n    var ENVIRONMENT_IS_SHELL = false;\n    ENVIRONMENT_IS_WEB = typeof window === \"object\";\n    ENVIRONMENT_IS_WORKER = typeof importScripts === \"function\";\n    ENVIRONMENT_IS_NODE = typeof process === \"object\" && typeof require === \"function\" && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;\n    ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\n    var scriptDirectory = \"\";\n\n    function locateFile(path) {\n      if (Module[\"locateFile\"]) {\n        return Module[\"locateFile\"](path, scriptDirectory);\n      } else {\n        return scriptDirectory + path;\n      }\n    }\n\n    if (ENVIRONMENT_IS_NODE) {\n      scriptDirectory = __dirname + \"/\";\n      var nodeFS;\n      var nodePath;\n\n      Module[\"read\"] = function shell_read(filename, binary) {\n        var ret;\n        if (!nodeFS) nodeFS = require(\"fs\");\n        if (!nodePath) nodePath = require(\"path\");\n        filename = nodePath[\"normalize\"](filename);\n        ret = nodeFS[\"readFileSync\"](filename);\n        return binary ? ret : ret.toString();\n      };\n\n      Module[\"readBinary\"] = function readBinary(filename) {\n        var ret = Module[\"read\"](filename, true);\n\n        if (!ret.buffer) {\n          ret = new Uint8Array(ret);\n        }\n\n        assert(ret.buffer);\n        return ret;\n      };\n\n      if (process[\"argv\"].length > 1) {\n        Module[\"thisProgram\"] = process[\"argv\"][1].replace(/\\\\/g, \"/\");\n      }\n\n      Module[\"arguments\"] = process[\"argv\"].slice(2);\n      process[\"on\"](\"uncaughtException\", function (ex) {\n        if (!(ex instanceof ExitStatus)) {\n          throw ex;\n        }\n      });\n      process[\"on\"](\"unhandledRejection\", abort);\n\n      Module[\"quit\"] = function (status) {\n        process[\"exit\"](status);\n      };\n\n      Module[\"inspect\"] = function () {\n        return \"[Emscripten Module object]\";\n      };\n    } else if (ENVIRONMENT_IS_SHELL) {\n      if (typeof read != \"undefined\") {\n        Module[\"read\"] = function shell_read(f) {\n          return read(f);\n        };\n      }\n\n      Module[\"readBinary\"] = function readBinary(f) {\n        var data;\n\n        if (typeof readbuffer === \"function\") {\n          return new Uint8Array(readbuffer(f));\n        }\n\n        data = read(f, \"binary\");\n        assert(typeof data === \"object\");\n        return data;\n      };\n\n      if (typeof scriptArgs != \"undefined\") {\n        Module[\"arguments\"] = scriptArgs;\n      } else if (typeof arguments != \"undefined\") {\n        Module[\"arguments\"] = arguments;\n      }\n\n      if (typeof quit === \"function\") {\n        Module[\"quit\"] = function (status) {\n          quit(status);\n        };\n      }\n    } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n      if (ENVIRONMENT_IS_WORKER) {\n        scriptDirectory = self.location.href;\n      } else if (document.currentScript) {\n        scriptDirectory = document.currentScript.src;\n      }\n\n      if (_scriptDir) {\n        scriptDirectory = _scriptDir;\n      }\n\n      if (scriptDirectory.indexOf(\"blob:\") !== 0) {\n        scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf(\"/\") + 1);\n      } else {\n        scriptDirectory = \"\";\n      }\n\n      Module[\"read\"] = function shell_read(url) {\n        var xhr = new XMLHttpRequest();\n        xhr.open(\"GET\", url, false);\n        xhr.send(null);\n        return xhr.responseText;\n      };\n\n      if (ENVIRONMENT_IS_WORKER) {\n        Module[\"readBinary\"] = function readBinary(url) {\n          var xhr = new XMLHttpRequest();\n          xhr.open(\"GET\", url, false);\n          xhr.responseType = \"arraybuffer\";\n          xhr.send(null);\n          return new Uint8Array(xhr.response);\n        };\n      }\n\n      Module[\"readAsync\"] = function readAsync(url, onload, onerror) {\n        var xhr = new XMLHttpRequest();\n        xhr.open(\"GET\", url, true);\n        xhr.responseType = \"arraybuffer\";\n\n        xhr.onload = function xhr_onload() {\n          if (xhr.status == 200 || xhr.status == 0 && xhr.response) {\n            onload(xhr.response);\n            return;\n          }\n\n          onerror();\n        };\n\n        xhr.onerror = onerror;\n        xhr.send(null);\n      };\n\n      Module[\"setWindowTitle\"] = function (title) {\n        document.title = title;\n      };\n    } else {}\n\n    var out = Module[\"print\"] || (typeof console !== \"undefined\" ? console.log.bind(console) : typeof print !== \"undefined\" ? print : null);\n    var err = Module[\"printErr\"] || (typeof printErr !== \"undefined\" ? printErr : typeof console !== \"undefined\" && console.warn.bind(console) || out);\n\n    for (key in moduleOverrides) {\n      if (moduleOverrides.hasOwnProperty(key)) {\n        Module[key] = moduleOverrides[key];\n      }\n    }\n\n    moduleOverrides = undefined;\n\n    function dynamicAlloc(size) {\n      var ret = HEAP32[DYNAMICTOP_PTR >> 2];\n      var end = ret + size + 15 & -16;\n\n      if (end <= _emscripten_get_heap_size()) {\n        HEAP32[DYNAMICTOP_PTR >> 2] = end;\n      } else {\n        var success = _emscripten_resize_heap(end);\n\n        if (!success) return 0;\n      }\n\n      return ret;\n    }\n\n    function getNativeTypeSize(type) {\n      switch (type) {\n        case \"i1\":\n        case \"i8\":\n          return 1;\n\n        case \"i16\":\n          return 2;\n\n        case \"i32\":\n          return 4;\n\n        case \"i64\":\n          return 8;\n\n        case \"float\":\n          return 4;\n\n        case \"double\":\n          return 8;\n\n        default:\n          {\n            if (type[type.length - 1] === \"*\") {\n              return 4;\n            } else if (type[0] === \"i\") {\n              var bits = parseInt(type.substr(1));\n              assert(bits % 8 === 0, \"getNativeTypeSize invalid bits \" + bits + \", type \" + type);\n              return bits / 8;\n            } else {\n              return 0;\n            }\n          }\n      }\n    }\n\n    var asm2wasmImports = {\n      \"f64-rem\": function (x, y) {\n        return x % y;\n      },\n      \"debugger\": function () {\n        debugger;\n      }\n    };\n    var functionPointers = new Array(0);\n\n    if (typeof WebAssembly !== \"object\") {\n      err(\"no native wasm support detected\");\n    }\n\n    function getValue(ptr, type, noSafe) {\n      type = type || \"i8\";\n      if (type.charAt(type.length - 1) === \"*\") type = \"i32\";\n\n      switch (type) {\n        case \"i1\":\n          return HEAP8[ptr >> 0];\n\n        case \"i8\":\n          return HEAP8[ptr >> 0];\n\n        case \"i16\":\n          return HEAP16[ptr >> 1];\n\n        case \"i32\":\n          return HEAP32[ptr >> 2];\n\n        case \"i64\":\n          return HEAP32[ptr >> 2];\n\n        case \"float\":\n          return HEAPF32[ptr >> 2];\n\n        case \"double\":\n          return HEAPF64[ptr >> 3];\n\n        default:\n          abort(\"invalid type for getValue: \" + type);\n      }\n\n      return null;\n    }\n\n    var wasmMemory;\n    var wasmTable;\n    var ABORT = false;\n    var EXITSTATUS = 0;\n\n    function assert(condition, text) {\n      if (!condition) {\n        abort(\"Assertion failed: \" + text);\n      }\n    }\n\n    function setValue(ptr, value, type, noSafe) {\n      type = type || \"i8\";\n      if (type.charAt(type.length - 1) === \"*\") type = \"i32\";\n\n      switch (type) {\n        case \"i1\":\n          HEAP8[ptr >> 0] = value;\n          break;\n\n        case \"i8\":\n          HEAP8[ptr >> 0] = value;\n          break;\n\n        case \"i16\":\n          HEAP16[ptr >> 1] = value;\n          break;\n\n        case \"i32\":\n          HEAP32[ptr >> 2] = value;\n          break;\n\n        case \"i64\":\n          tempI64 = [value >>> 0, (tempDouble = value, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];\n          break;\n\n        case \"float\":\n          HEAPF32[ptr >> 2] = value;\n          break;\n\n        case \"double\":\n          HEAPF64[ptr >> 3] = value;\n          break;\n\n        default:\n          abort(\"invalid type for setValue: \" + type);\n      }\n    }\n\n    var ALLOC_NONE = 3;\n\n    function allocate(slab, types, allocator, ptr) {\n      var zeroinit, size;\n\n      if (typeof slab === \"number\") {\n        zeroinit = true;\n        size = slab;\n      } else {\n        zeroinit = false;\n        size = slab.length;\n      }\n\n      var singleType = typeof types === \"string\" ? types : null;\n      var ret;\n\n      if (allocator == ALLOC_NONE) {\n        ret = ptr;\n      } else {\n        ret = [_malloc, stackAlloc, dynamicAlloc][allocator](Math.max(size, singleType ? 1 : types.length));\n      }\n\n      if (zeroinit) {\n        var stop;\n        ptr = ret;\n        assert((ret & 3) == 0);\n        stop = ret + (size & ~3);\n\n        for (; ptr < stop; ptr += 4) {\n          HEAP32[ptr >> 2] = 0;\n        }\n\n        stop = ret + size;\n\n        while (ptr < stop) {\n          HEAP8[ptr++ >> 0] = 0;\n        }\n\n        return ret;\n      }\n\n      if (singleType === \"i8\") {\n        if (slab.subarray || slab.slice) {\n          HEAPU8.set(slab, ret);\n        } else {\n          HEAPU8.set(new Uint8Array(slab), ret);\n        }\n\n        return ret;\n      }\n\n      var i = 0,\n          type,\n          typeSize,\n          previousType;\n\n      while (i < size) {\n        var curr = slab[i];\n        type = singleType || types[i];\n\n        if (type === 0) {\n          i++;\n          continue;\n        }\n\n        if (type == \"i64\") type = \"i32\";\n        setValue(ret + i, curr, type);\n\n        if (previousType !== type) {\n          typeSize = getNativeTypeSize(type);\n          previousType = type;\n        }\n\n        i += typeSize;\n      }\n\n      return ret;\n    }\n\n    var UTF8Decoder = typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf8\") : undefined;\n\n    function UTF8ArrayToString(u8Array, idx, maxBytesToRead) {\n      var endIdx = idx + maxBytesToRead;\n      var endPtr = idx;\n\n      while (u8Array[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n\n      if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {\n        return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));\n      } else {\n        var str = \"\";\n\n        while (idx < endPtr) {\n          var u0 = u8Array[idx++];\n\n          if (!(u0 & 128)) {\n            str += String.fromCharCode(u0);\n            continue;\n          }\n\n          var u1 = u8Array[idx++] & 63;\n\n          if ((u0 & 224) == 192) {\n            str += String.fromCharCode((u0 & 31) << 6 | u1);\n            continue;\n          }\n\n          var u2 = u8Array[idx++] & 63;\n\n          if ((u0 & 240) == 224) {\n            u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n          } else {\n            u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | u8Array[idx++] & 63;\n          }\n\n          if (u0 < 65536) {\n            str += String.fromCharCode(u0);\n          } else {\n            var ch = u0 - 65536;\n            str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n          }\n        }\n      }\n\n      return str;\n    }\n\n    function UTF8ToString(ptr, maxBytesToRead) {\n      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : \"\";\n    }\n\n    function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {\n      if (!(maxBytesToWrite > 0)) return 0;\n      var startIdx = outIdx;\n      var endIdx = outIdx + maxBytesToWrite - 1;\n\n      for (var i = 0; i < str.length; ++i) {\n        var u = str.charCodeAt(i);\n\n        if (u >= 55296 && u <= 57343) {\n          var u1 = str.charCodeAt(++i);\n          u = 65536 + ((u & 1023) << 10) | u1 & 1023;\n        }\n\n        if (u <= 127) {\n          if (outIdx >= endIdx) break;\n          outU8Array[outIdx++] = u;\n        } else if (u <= 2047) {\n          if (outIdx + 1 >= endIdx) break;\n          outU8Array[outIdx++] = 192 | u >> 6;\n          outU8Array[outIdx++] = 128 | u & 63;\n        } else if (u <= 65535) {\n          if (outIdx + 2 >= endIdx) break;\n          outU8Array[outIdx++] = 224 | u >> 12;\n          outU8Array[outIdx++] = 128 | u >> 6 & 63;\n          outU8Array[outIdx++] = 128 | u & 63;\n        } else {\n          if (outIdx + 3 >= endIdx) break;\n          outU8Array[outIdx++] = 240 | u >> 18;\n          outU8Array[outIdx++] = 128 | u >> 12 & 63;\n          outU8Array[outIdx++] = 128 | u >> 6 & 63;\n          outU8Array[outIdx++] = 128 | u & 63;\n        }\n      }\n\n      outU8Array[outIdx] = 0;\n      return outIdx - startIdx;\n    }\n\n    function stringToUTF8(str, outPtr, maxBytesToWrite) {\n      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n    }\n\n    function lengthBytesUTF8(str) {\n      var len = 0;\n\n      for (var i = 0; i < str.length; ++i) {\n        var u = str.charCodeAt(i);\n        if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;\n        if (u <= 127) ++len;else if (u <= 2047) len += 2;else if (u <= 65535) len += 3;else len += 4;\n      }\n\n      return len;\n    }\n\n    var UTF16Decoder = typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf-16le\") : undefined;\n\n    function allocateUTF8(str) {\n      var size = lengthBytesUTF8(str) + 1;\n\n      var ret = _malloc(size);\n\n      if (ret) stringToUTF8Array(str, HEAP8, ret, size);\n      return ret;\n    }\n\n    function writeArrayToMemory(array, buffer) {\n      HEAP8.set(array, buffer);\n    }\n\n    function demangle(func) {\n      return func;\n    }\n\n    function demangleAll(text) {\n      var regex = /__Z[\\w\\d_]+/g;\n      return text.replace(regex, function (x) {\n        var y = demangle(x);\n        return x === y ? x : y + \" [\" + x + \"]\";\n      });\n    }\n\n    function jsStackTrace() {\n      var err = new Error();\n\n      if (!err.stack) {\n        try {\n          throw new Error(0);\n        } catch (e) {\n          err = e;\n        }\n\n        if (!err.stack) {\n          return \"(no stack trace available)\";\n        }\n      }\n\n      return err.stack.toString();\n    }\n\n    function stackTrace() {\n      var js = jsStackTrace();\n      if (Module[\"extraStackTrace\"]) js += \"\\n\" + Module[\"extraStackTrace\"]();\n      return demangleAll(js);\n    }\n\n    var WASM_PAGE_SIZE = 65536;\n\n    function alignUp(x, multiple) {\n      if (x % multiple > 0) {\n        x += multiple - x % multiple;\n      }\n\n      return x;\n    }\n\n    var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\n\n    function updateGlobalBuffer(buf) {\n      Module[\"buffer\"] = buffer = buf;\n    }\n\n    function updateGlobalBufferViews() {\n      Module[\"HEAP8\"] = HEAP8 = new Int8Array(buffer);\n      Module[\"HEAP16\"] = HEAP16 = new Int16Array(buffer);\n      Module[\"HEAP32\"] = HEAP32 = new Int32Array(buffer);\n      Module[\"HEAPU8\"] = HEAPU8 = new Uint8Array(buffer);\n      Module[\"HEAPU16\"] = HEAPU16 = new Uint16Array(buffer);\n      Module[\"HEAPU32\"] = HEAPU32 = new Uint32Array(buffer);\n      Module[\"HEAPF32\"] = HEAPF32 = new Float32Array(buffer);\n      Module[\"HEAPF64\"] = HEAPF64 = new Float64Array(buffer);\n    }\n\n    var DYNAMIC_BASE = 5276816,\n        DYNAMICTOP_PTR = 33680;\n    var TOTAL_STACK = 5242880;\n    var TOTAL_MEMORY = Module[\"TOTAL_MEMORY\"] || 16777216;\n    if (TOTAL_MEMORY < TOTAL_STACK) err(\"TOTAL_MEMORY should be larger than TOTAL_STACK, was \" + TOTAL_MEMORY + \"! (TOTAL_STACK=\" + TOTAL_STACK + \")\");\n\n    if (Module[\"buffer\"]) {\n      buffer = Module[\"buffer\"];\n    } else {\n      if (typeof WebAssembly === \"object\" && typeof WebAssembly.Memory === \"function\") {\n        wasmMemory = new WebAssembly.Memory({\n          \"initial\": TOTAL_MEMORY / WASM_PAGE_SIZE\n        });\n        buffer = wasmMemory.buffer;\n      } else {\n        buffer = new ArrayBuffer(TOTAL_MEMORY);\n      }\n\n      Module[\"buffer\"] = buffer;\n    }\n\n    updateGlobalBufferViews();\n    HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;\n\n    function callRuntimeCallbacks(callbacks) {\n      while (callbacks.length > 0) {\n        var callback = callbacks.shift();\n\n        if (typeof callback == \"function\") {\n          callback();\n          continue;\n        }\n\n        var func = callback.func;\n\n        if (typeof func === \"number\") {\n          if (callback.arg === undefined) {\n            Module[\"dynCall_v\"](func);\n          } else {\n            Module[\"dynCall_vi\"](func, callback.arg);\n          }\n        } else {\n          func(callback.arg === undefined ? null : callback.arg);\n        }\n      }\n    }\n\n    var __ATPRERUN__ = [];\n    var __ATINIT__ = [];\n    var __ATMAIN__ = [];\n    var __ATPOSTRUN__ = [];\n    var runtimeInitialized = false;\n\n    function preRun() {\n      if (Module[\"preRun\"]) {\n        if (typeof Module[\"preRun\"] == \"function\") Module[\"preRun\"] = [Module[\"preRun\"]];\n\n        while (Module[\"preRun\"].length) {\n          addOnPreRun(Module[\"preRun\"].shift());\n        }\n      }\n\n      callRuntimeCallbacks(__ATPRERUN__);\n    }\n\n    function ensureInitRuntime() {\n      if (runtimeInitialized) return;\n      runtimeInitialized = true;\n      if (!Module[\"noFSInit\"] && !FS.init.initialized) FS.init();\n      TTY.init();\n      callRuntimeCallbacks(__ATINIT__);\n    }\n\n    function preMain() {\n      FS.ignorePermissions = false;\n      callRuntimeCallbacks(__ATMAIN__);\n    }\n\n    function postRun() {\n      if (Module[\"postRun\"]) {\n        if (typeof Module[\"postRun\"] == \"function\") Module[\"postRun\"] = [Module[\"postRun\"]];\n\n        while (Module[\"postRun\"].length) {\n          addOnPostRun(Module[\"postRun\"].shift());\n        }\n      }\n\n      callRuntimeCallbacks(__ATPOSTRUN__);\n    }\n\n    function addOnPreRun(cb) {\n      __ATPRERUN__.unshift(cb);\n    }\n\n    function addOnPreMain(cb) {\n      __ATMAIN__.unshift(cb);\n    }\n\n    function addOnPostRun(cb) {\n      __ATPOSTRUN__.unshift(cb);\n    }\n\n    var Math_abs = Math.abs;\n    var Math_ceil = Math.ceil;\n    var Math_floor = Math.floor;\n    var Math_min = Math.min;\n    var runDependencies = 0;\n    var runDependencyWatcher = null;\n    var dependenciesFulfilled = null;\n\n    function getUniqueRunDependency(id) {\n      return id;\n    }\n\n    function addRunDependency(id) {\n      runDependencies++;\n\n      if (Module[\"monitorRunDependencies\"]) {\n        Module[\"monitorRunDependencies\"](runDependencies);\n      }\n    }\n\n    function removeRunDependency(id) {\n      runDependencies--;\n\n      if (Module[\"monitorRunDependencies\"]) {\n        Module[\"monitorRunDependencies\"](runDependencies);\n      }\n\n      if (runDependencies == 0) {\n        if (runDependencyWatcher !== null) {\n          clearInterval(runDependencyWatcher);\n          runDependencyWatcher = null;\n        }\n\n        if (dependenciesFulfilled) {\n          var callback = dependenciesFulfilled;\n          dependenciesFulfilled = null;\n          callback();\n        }\n      }\n    }\n\n    Module[\"preloadedImages\"] = {};\n    Module[\"preloadedAudios\"] = {};\n    var dataURIPrefix = \"data:application/octet-stream;base64,\";\n\n    function isDataURI(filename) {\n      return String.prototype.startsWith ? filename.startsWith(dataURIPrefix) : filename.indexOf(dataURIPrefix) === 0;\n    }\n\n    var wasmBinaryFile = \"CornucopiaCore.wasm\";\n\n    if (!isDataURI(wasmBinaryFile)) {\n      wasmBinaryFile = locateFile(wasmBinaryFile);\n    }\n\n    function getBinary() {\n      try {\n        if (Module[\"wasmBinary\"]) {\n          return new Uint8Array(Module[\"wasmBinary\"]);\n        }\n\n        if (Module[\"readBinary\"]) {\n          return Module[\"readBinary\"](wasmBinaryFile);\n        } else {\n          throw \"both async and sync fetching of the wasm failed\";\n        }\n      } catch (err) {\n        abort(err);\n      }\n    }\n\n    function getBinaryPromise() {\n      if (!Module[\"wasmBinary\"] && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === 'function') {\n        if (window.location.protocol !== 'file:') {\n          return fetch(wasmBinaryFile, {\n            credentials: \"same-origin\"\n          }).then(function (response) {\n            if (!response[\"ok\"]) {\n              throw \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\";\n            }\n\n            return response[\"arrayBuffer\"]();\n          }).catch(function () {\n            return getBinary();\n          });\n        } else {\n          return new Promise(resolve => {\n            Module['readAsync'](wasmBinaryFile, src => {\n              resolve(src);\n            });\n          });\n        }\n      }\n\n      return new Promise(function (resolve, reject) {\n        resolve(getBinary());\n      });\n    }\n\n    function createWasm(env) {\n      var info = {\n        \"env\": env,\n        \"global\": {\n          \"NaN\": NaN,\n          Infinity: Infinity\n        },\n        \"global.Math\": Math,\n        \"asm2wasm\": asm2wasmImports\n      };\n\n      function receiveInstance(instance, module) {\n        var exports = instance.exports;\n        Module[\"asm\"] = exports;\n        removeRunDependency(\"wasm-instantiate\");\n      }\n\n      addRunDependency(\"wasm-instantiate\");\n\n      if (Module[\"instantiateWasm\"]) {\n        try {\n          return Module[\"instantiateWasm\"](info, receiveInstance);\n        } catch (e) {\n          err(\"Module.instantiateWasm callback failed with error: \" + e);\n          return false;\n        }\n      }\n\n      function receiveInstantiatedSource(output) {\n        receiveInstance(output[\"instance\"]);\n      }\n\n      function instantiateArrayBuffer(receiver) {\n        getBinaryPromise().then(function (binary) {\n          return WebAssembly.instantiate(binary, info);\n        }).then(receiver, function (reason) {\n          err(\"failed to asynchronously prepare wasm: \" + reason);\n          abort(reason);\n        });\n      }\n\n      if (!Module[\"wasmBinary\"] && typeof WebAssembly.instantiateStreaming === \"function\" && !isDataURI(wasmBinaryFile) && typeof fetch === \"function\" && window.location.protocol !== 'file:') {\n        WebAssembly.instantiateStreaming(fetch(wasmBinaryFile, {\n          credentials: \"same-origin\"\n        }), info).then(receiveInstantiatedSource, function (reason) {\n          err(\"wasm streaming compile failed: \" + reason);\n          err(\"falling back to ArrayBuffer instantiation\");\n          instantiateArrayBuffer(receiveInstantiatedSource);\n        });\n      } else {\n        instantiateArrayBuffer(receiveInstantiatedSource);\n      }\n\n      return {};\n    }\n\n    Module[\"asm\"] = function (global, env, providedBuffer) {\n      env[\"memory\"] = wasmMemory;\n      env[\"table\"] = wasmTable = new WebAssembly.Table({\n        \"initial\": 930,\n        \"maximum\": 930,\n        \"element\": \"anyfunc\"\n      });\n      env[\"__memory_base\"] = 1024;\n      env[\"__table_base\"] = 0;\n      var exports = createWasm(env);\n      return exports;\n    };\n\n    __ATINIT__.push({\n      func: function () {\n        globalCtors();\n      }\n    });\n\n    function ___assert_fail(condition, filename, line, func) {\n      abort(\"Assertion failed: \" + UTF8ToString(condition) + \", at: \" + [filename ? UTF8ToString(filename) : \"unknown filename\", line, func ? UTF8ToString(func) : \"unknown function\"]);\n    }\n\n    function ___cxa_allocate_exception(size) {\n      return _malloc(size);\n    }\n\n    function ___cxa_free_exception(ptr) {\n      try {\n        return _free(ptr);\n      } catch (e) {}\n    }\n\n    var EXCEPTIONS = {\n      last: 0,\n      caught: [],\n      infos: {},\n      deAdjust: function (adjusted) {\n        if (!adjusted || EXCEPTIONS.infos[adjusted]) return adjusted;\n\n        for (var key in EXCEPTIONS.infos) {\n          var ptr = +key;\n          var adj = EXCEPTIONS.infos[ptr].adjusted;\n          var len = adj.length;\n\n          for (var i = 0; i < len; i++) {\n            if (adj[i] === adjusted) {\n              return ptr;\n            }\n          }\n        }\n\n        return adjusted;\n      },\n      addRef: function (ptr) {\n        if (!ptr) return;\n        var info = EXCEPTIONS.infos[ptr];\n        info.refcount++;\n      },\n      decRef: function (ptr) {\n        if (!ptr) return;\n        var info = EXCEPTIONS.infos[ptr];\n        assert(info.refcount > 0);\n        info.refcount--;\n\n        if (info.refcount === 0 && !info.rethrown) {\n          if (info.destructor) {\n            Module[\"dynCall_vi\"](info.destructor, ptr);\n          }\n\n          delete EXCEPTIONS.infos[ptr];\n\n          ___cxa_free_exception(ptr);\n        }\n      },\n      clearRef: function (ptr) {\n        if (!ptr) return;\n        var info = EXCEPTIONS.infos[ptr];\n        info.refcount = 0;\n      }\n    };\n\n    function ___cxa_pure_virtual() {\n      ABORT = true;\n      throw \"Pure virtual function called!\";\n    }\n\n    function ___cxa_throw(ptr, type, destructor) {\n      EXCEPTIONS.infos[ptr] = {\n        ptr: ptr,\n        adjusted: [ptr],\n        type: type,\n        destructor: destructor,\n        refcount: 0,\n        caught: false,\n        rethrown: false\n      };\n      EXCEPTIONS.last = ptr;\n\n      if (!(\"uncaught_exception\" in __ZSt18uncaught_exceptionv)) {\n        __ZSt18uncaught_exceptionv.uncaught_exception = 1;\n      } else {\n        __ZSt18uncaught_exceptionv.uncaught_exception++;\n      }\n\n      throw ptr;\n    }\n\n    function ___cxa_uncaught_exception() {\n      return !!__ZSt18uncaught_exceptionv.uncaught_exception;\n    }\n\n    function ___lock() {}\n\n    function ___setErrNo(value) {\n      if (Module[\"___errno_location\"]) HEAP32[Module[\"___errno_location\"]() >> 2] = value;\n      return value;\n    }\n\n    function ___map_file(pathname, size) {\n      ___setErrNo(1);\n\n      return -1;\n    }\n\n    var PATH = {\n      splitPath: function (filename) {\n        var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n        return splitPathRe.exec(filename).slice(1);\n      },\n      normalizeArray: function (parts, allowAboveRoot) {\n        var up = 0;\n\n        for (var i = parts.length - 1; i >= 0; i--) {\n          var last = parts[i];\n\n          if (last === \".\") {\n            parts.splice(i, 1);\n          } else if (last === \"..\") {\n            parts.splice(i, 1);\n            up++;\n          } else if (up) {\n            parts.splice(i, 1);\n            up--;\n          }\n        }\n\n        if (allowAboveRoot) {\n          for (; up; up--) {\n            parts.unshift(\"..\");\n          }\n        }\n\n        return parts;\n      },\n      normalize: function (path) {\n        var isAbsolute = path.charAt(0) === \"/\",\n            trailingSlash = path.substr(-1) === \"/\";\n        path = PATH.normalizeArray(path.split(\"/\").filter(function (p) {\n          return !!p;\n        }), !isAbsolute).join(\"/\");\n\n        if (!path && !isAbsolute) {\n          path = \".\";\n        }\n\n        if (path && trailingSlash) {\n          path += \"/\";\n        }\n\n        return (isAbsolute ? \"/\" : \"\") + path;\n      },\n      dirname: function (path) {\n        var result = PATH.splitPath(path),\n            root = result[0],\n            dir = result[1];\n\n        if (!root && !dir) {\n          return \".\";\n        }\n\n        if (dir) {\n          dir = dir.substr(0, dir.length - 1);\n        }\n\n        return root + dir;\n      },\n      basename: function (path) {\n        if (path === \"/\") return \"/\";\n        var lastSlash = path.lastIndexOf(\"/\");\n        if (lastSlash === -1) return path;\n        return path.substr(lastSlash + 1);\n      },\n      extname: function (path) {\n        return PATH.splitPath(path)[3];\n      },\n      join: function () {\n        var paths = Array.prototype.slice.call(arguments, 0);\n        return PATH.normalize(paths.join(\"/\"));\n      },\n      join2: function (l, r) {\n        return PATH.normalize(l + \"/\" + r);\n      },\n      resolve: function () {\n        var resolvedPath = \"\",\n            resolvedAbsolute = false;\n\n        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n          var path = i >= 0 ? arguments[i] : FS.cwd();\n\n          if (typeof path !== \"string\") {\n            throw new TypeError(\"Arguments to path.resolve must be strings\");\n          } else if (!path) {\n            return \"\";\n          }\n\n          resolvedPath = path + \"/\" + resolvedPath;\n          resolvedAbsolute = path.charAt(0) === \"/\";\n        }\n\n        resolvedPath = PATH.normalizeArray(resolvedPath.split(\"/\").filter(function (p) {\n          return !!p;\n        }), !resolvedAbsolute).join(\"/\");\n        return (resolvedAbsolute ? \"/\" : \"\") + resolvedPath || \".\";\n      },\n      relative: function (from, to) {\n        from = PATH.resolve(from).substr(1);\n        to = PATH.resolve(to).substr(1);\n\n        function trim(arr) {\n          var start = 0;\n\n          for (; start < arr.length; start++) {\n            if (arr[start] !== \"\") break;\n          }\n\n          var end = arr.length - 1;\n\n          for (; end >= 0; end--) {\n            if (arr[end] !== \"\") break;\n          }\n\n          if (start > end) return [];\n          return arr.slice(start, end - start + 1);\n        }\n\n        var fromParts = trim(from.split(\"/\"));\n        var toParts = trim(to.split(\"/\"));\n        var length = Math.min(fromParts.length, toParts.length);\n        var samePartsLength = length;\n\n        for (var i = 0; i < length; i++) {\n          if (fromParts[i] !== toParts[i]) {\n            samePartsLength = i;\n            break;\n          }\n        }\n\n        var outputParts = [];\n\n        for (var i = samePartsLength; i < fromParts.length; i++) {\n          outputParts.push(\"..\");\n        }\n\n        outputParts = outputParts.concat(toParts.slice(samePartsLength));\n        return outputParts.join(\"/\");\n      }\n    };\n    var TTY = {\n      ttys: [],\n      init: function () {},\n      shutdown: function () {},\n      register: function (dev, ops) {\n        TTY.ttys[dev] = {\n          input: [],\n          output: [],\n          ops: ops\n        };\n        FS.registerDevice(dev, TTY.stream_ops);\n      },\n      stream_ops: {\n        open: function (stream) {\n          var tty = TTY.ttys[stream.node.rdev];\n\n          if (!tty) {\n            throw new FS.ErrnoError(ERRNO_CODES.ENODEV);\n          }\n\n          stream.tty = tty;\n          stream.seekable = false;\n        },\n        close: function (stream) {\n          stream.tty.ops.flush(stream.tty);\n        },\n        flush: function (stream) {\n          stream.tty.ops.flush(stream.tty);\n        },\n        read: function (stream, buffer, offset, length, pos) {\n          if (!stream.tty || !stream.tty.ops.get_char) {\n            throw new FS.ErrnoError(ERRNO_CODES.ENXIO);\n          }\n\n          var bytesRead = 0;\n\n          for (var i = 0; i < length; i++) {\n            var result;\n\n            try {\n              result = stream.tty.ops.get_char(stream.tty);\n            } catch (e) {\n              throw new FS.ErrnoError(ERRNO_CODES.EIO);\n            }\n\n            if (result === undefined && bytesRead === 0) {\n              throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);\n            }\n\n            if (result === null || result === undefined) break;\n            bytesRead++;\n            buffer[offset + i] = result;\n          }\n\n          if (bytesRead) {\n            stream.node.timestamp = Date.now();\n          }\n\n          return bytesRead;\n        },\n        write: function (stream, buffer, offset, length, pos) {\n          if (!stream.tty || !stream.tty.ops.put_char) {\n            throw new FS.ErrnoError(ERRNO_CODES.ENXIO);\n          }\n\n          try {\n            for (var i = 0; i < length; i++) {\n              stream.tty.ops.put_char(stream.tty, buffer[offset + i]);\n            }\n          } catch (e) {\n            throw new FS.ErrnoError(ERRNO_CODES.EIO);\n          }\n\n          if (length) {\n            stream.node.timestamp = Date.now();\n          }\n\n          return i;\n        }\n      },\n      default_tty_ops: {\n        get_char: function (tty) {\n          if (!tty.input.length) {\n            var result = null;\n\n            if (ENVIRONMENT_IS_NODE) {\n              var BUFSIZE = 256;\n              var buf = new Buffer(BUFSIZE);\n              var bytesRead = 0;\n              var isPosixPlatform = process.platform != \"win32\";\n              var fd = process.stdin.fd;\n\n              if (isPosixPlatform) {\n                var usingDevice = false;\n\n                try {\n                  fd = fs.openSync(\"/dev/stdin\", \"r\");\n                  usingDevice = true;\n                } catch (e) {}\n              }\n\n              try {\n                bytesRead = fs.readSync(fd, buf, 0, BUFSIZE, null);\n              } catch (e) {\n                if (e.toString().indexOf(\"EOF\") != -1) bytesRead = 0;else throw e;\n              }\n\n              if (usingDevice) {\n                fs.closeSync(fd);\n              }\n\n              if (bytesRead > 0) {\n                result = buf.slice(0, bytesRead).toString(\"utf-8\");\n              } else {\n                result = null;\n              }\n            } else if (typeof window != \"undefined\" && typeof window.prompt == \"function\") {\n              result = window.prompt(\"Input: \");\n\n              if (result !== null) {\n                result += \"\\n\";\n              }\n            } else if (typeof readline == \"function\") {\n              result = readline();\n\n              if (result !== null) {\n                result += \"\\n\";\n              }\n            }\n\n            if (!result) {\n              return null;\n            }\n\n            tty.input = intArrayFromString(result, true);\n          }\n\n          return tty.input.shift();\n        },\n        put_char: function (tty, val) {\n          if (val === null || val === 10) {\n            out(UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          } else {\n            if (val != 0) tty.output.push(val);\n          }\n        },\n        flush: function (tty) {\n          if (tty.output && tty.output.length > 0) {\n            out(UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          }\n        }\n      },\n      default_tty1_ops: {\n        put_char: function (tty, val) {\n          if (val === null || val === 10) {\n            err(UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          } else {\n            if (val != 0) tty.output.push(val);\n          }\n        },\n        flush: function (tty) {\n          if (tty.output && tty.output.length > 0) {\n            err(UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          }\n        }\n      }\n    };\n    var MEMFS = {\n      ops_table: null,\n      mount: function (mount) {\n        return MEMFS.createNode(null, \"/\", 16384 | 511, 0);\n      },\n      createNode: function (parent, name, mode, dev) {\n        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        }\n\n        if (!MEMFS.ops_table) {\n          MEMFS.ops_table = {\n            dir: {\n              node: {\n                getattr: MEMFS.node_ops.getattr,\n                setattr: MEMFS.node_ops.setattr,\n                lookup: MEMFS.node_ops.lookup,\n                mknod: MEMFS.node_ops.mknod,\n                rename: MEMFS.node_ops.rename,\n                unlink: MEMFS.node_ops.unlink,\n                rmdir: MEMFS.node_ops.rmdir,\n                readdir: MEMFS.node_ops.readdir,\n                symlink: MEMFS.node_ops.symlink\n              },\n              stream: {\n                llseek: MEMFS.stream_ops.llseek\n              }\n            },\n            file: {\n              node: {\n                getattr: MEMFS.node_ops.getattr,\n                setattr: MEMFS.node_ops.setattr\n              },\n              stream: {\n                llseek: MEMFS.stream_ops.llseek,\n                read: MEMFS.stream_ops.read,\n                write: MEMFS.stream_ops.write,\n                allocate: MEMFS.stream_ops.allocate,\n                mmap: MEMFS.stream_ops.mmap,\n                msync: MEMFS.stream_ops.msync\n              }\n            },\n            link: {\n              node: {\n                getattr: MEMFS.node_ops.getattr,\n                setattr: MEMFS.node_ops.setattr,\n                readlink: MEMFS.node_ops.readlink\n              },\n              stream: {}\n            },\n            chrdev: {\n              node: {\n                getattr: MEMFS.node_ops.getattr,\n                setattr: MEMFS.node_ops.setattr\n              },\n              stream: FS.chrdev_stream_ops\n            }\n          };\n        }\n\n        var node = FS.createNode(parent, name, mode, dev);\n\n        if (FS.isDir(node.mode)) {\n          node.node_ops = MEMFS.ops_table.dir.node;\n          node.stream_ops = MEMFS.ops_table.dir.stream;\n          node.contents = {};\n        } else if (FS.isFile(node.mode)) {\n          node.node_ops = MEMFS.ops_table.file.node;\n          node.stream_ops = MEMFS.ops_table.file.stream;\n          node.usedBytes = 0;\n          node.contents = null;\n        } else if (FS.isLink(node.mode)) {\n          node.node_ops = MEMFS.ops_table.link.node;\n          node.stream_ops = MEMFS.ops_table.link.stream;\n        } else if (FS.isChrdev(node.mode)) {\n          node.node_ops = MEMFS.ops_table.chrdev.node;\n          node.stream_ops = MEMFS.ops_table.chrdev.stream;\n        }\n\n        node.timestamp = Date.now();\n\n        if (parent) {\n          parent.contents[name] = node;\n        }\n\n        return node;\n      },\n      getFileDataAsRegularArray: function (node) {\n        if (node.contents && node.contents.subarray) {\n          var arr = [];\n\n          for (var i = 0; i < node.usedBytes; ++i) arr.push(node.contents[i]);\n\n          return arr;\n        }\n\n        return node.contents;\n      },\n      getFileDataAsTypedArray: function (node) {\n        if (!node.contents) return new Uint8Array();\n        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes);\n        return new Uint8Array(node.contents);\n      },\n      expandFileStorage: function (node, newCapacity) {\n        var prevCapacity = node.contents ? node.contents.length : 0;\n        if (prevCapacity >= newCapacity) return;\n        var CAPACITY_DOUBLING_MAX = 1024 * 1024;\n        newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) | 0);\n        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);\n        var oldContents = node.contents;\n        node.contents = new Uint8Array(newCapacity);\n        if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0);\n        return;\n      },\n      resizeFileStorage: function (node, newSize) {\n        if (node.usedBytes == newSize) return;\n\n        if (newSize == 0) {\n          node.contents = null;\n          node.usedBytes = 0;\n          return;\n        }\n\n        if (!node.contents || node.contents.subarray) {\n          var oldContents = node.contents;\n          node.contents = new Uint8Array(new ArrayBuffer(newSize));\n\n          if (oldContents) {\n            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));\n          }\n\n          node.usedBytes = newSize;\n          return;\n        }\n\n        if (!node.contents) node.contents = [];\n        if (node.contents.length > newSize) node.contents.length = newSize;else while (node.contents.length < newSize) node.contents.push(0);\n        node.usedBytes = newSize;\n      },\n      node_ops: {\n        getattr: function (node) {\n          var attr = {};\n          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\n          attr.ino = node.id;\n          attr.mode = node.mode;\n          attr.nlink = 1;\n          attr.uid = 0;\n          attr.gid = 0;\n          attr.rdev = node.rdev;\n\n          if (FS.isDir(node.mode)) {\n            attr.size = 4096;\n          } else if (FS.isFile(node.mode)) {\n            attr.size = node.usedBytes;\n          } else if (FS.isLink(node.mode)) {\n            attr.size = node.link.length;\n          } else {\n            attr.size = 0;\n          }\n\n          attr.atime = new Date(node.timestamp);\n          attr.mtime = new Date(node.timestamp);\n          attr.ctime = new Date(node.timestamp);\n          attr.blksize = 4096;\n          attr.blocks = Math.ceil(attr.size / attr.blksize);\n          return attr;\n        },\n        setattr: function (node, attr) {\n          if (attr.mode !== undefined) {\n            node.mode = attr.mode;\n          }\n\n          if (attr.timestamp !== undefined) {\n            node.timestamp = attr.timestamp;\n          }\n\n          if (attr.size !== undefined) {\n            MEMFS.resizeFileStorage(node, attr.size);\n          }\n        },\n        lookup: function (parent, name) {\n          throw FS.genericErrors[ERRNO_CODES.ENOENT];\n        },\n        mknod: function (parent, name, mode, dev) {\n          return MEMFS.createNode(parent, name, mode, dev);\n        },\n        rename: function (old_node, new_dir, new_name) {\n          if (FS.isDir(old_node.mode)) {\n            var new_node;\n\n            try {\n              new_node = FS.lookupNode(new_dir, new_name);\n            } catch (e) {}\n\n            if (new_node) {\n              for (var i in new_node.contents) {\n                throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);\n              }\n            }\n          }\n\n          delete old_node.parent.contents[old_node.name];\n          old_node.name = new_name;\n          new_dir.contents[new_name] = old_node;\n          old_node.parent = new_dir;\n        },\n        unlink: function (parent, name) {\n          delete parent.contents[name];\n        },\n        rmdir: function (parent, name) {\n          var node = FS.lookupNode(parent, name);\n\n          for (var i in node.contents) {\n            throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);\n          }\n\n          delete parent.contents[name];\n        },\n        readdir: function (node) {\n          var entries = [\".\", \"..\"];\n\n          for (var key in node.contents) {\n            if (!node.contents.hasOwnProperty(key)) {\n              continue;\n            }\n\n            entries.push(key);\n          }\n\n          return entries;\n        },\n        symlink: function (parent, newname, oldpath) {\n          var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);\n          node.link = oldpath;\n          return node;\n        },\n        readlink: function (node) {\n          if (!FS.isLink(node.mode)) {\n            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n          }\n\n          return node.link;\n        }\n      },\n      stream_ops: {\n        read: function (stream, buffer, offset, length, position) {\n          var contents = stream.node.contents;\n          if (position >= stream.node.usedBytes) return 0;\n          var size = Math.min(stream.node.usedBytes - position, length);\n\n          if (size > 8 && contents.subarray) {\n            buffer.set(contents.subarray(position, position + size), offset);\n          } else {\n            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];\n          }\n\n          return size;\n        },\n        write: function (stream, buffer, offset, length, position, canOwn) {\n          canOwn = false;\n          if (!length) return 0;\n          var node = stream.node;\n          node.timestamp = Date.now();\n\n          if (buffer.subarray && (!node.contents || node.contents.subarray)) {\n            if (canOwn) {\n              node.contents = buffer.subarray(offset, offset + length);\n              node.usedBytes = length;\n              return length;\n            } else if (node.usedBytes === 0 && position === 0) {\n              node.contents = new Uint8Array(buffer.subarray(offset, offset + length));\n              node.usedBytes = length;\n              return length;\n            } else if (position + length <= node.usedBytes) {\n              node.contents.set(buffer.subarray(offset, offset + length), position);\n              return length;\n            }\n          }\n\n          MEMFS.expandFileStorage(node, position + length);\n          if (node.contents.subarray && buffer.subarray) node.contents.set(buffer.subarray(offset, offset + length), position);else {\n            for (var i = 0; i < length; i++) {\n              node.contents[position + i] = buffer[offset + i];\n            }\n          }\n          node.usedBytes = Math.max(node.usedBytes, position + length);\n          return length;\n        },\n        llseek: function (stream, offset, whence) {\n          var position = offset;\n\n          if (whence === 1) {\n            position += stream.position;\n          } else if (whence === 2) {\n            if (FS.isFile(stream.node.mode)) {\n              position += stream.node.usedBytes;\n            }\n          }\n\n          if (position < 0) {\n            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n          }\n\n          return position;\n        },\n        allocate: function (stream, offset, length) {\n          MEMFS.expandFileStorage(stream.node, offset + length);\n          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);\n        },\n        mmap: function (stream, buffer, offset, length, position, prot, flags) {\n          if (!FS.isFile(stream.node.mode)) {\n            throw new FS.ErrnoError(ERRNO_CODES.ENODEV);\n          }\n\n          var ptr;\n          var allocated;\n          var contents = stream.node.contents;\n\n          if (!(flags & 2) && (contents.buffer === buffer || contents.buffer === buffer.buffer)) {\n            allocated = false;\n            ptr = contents.byteOffset;\n          } else {\n            if (position > 0 || position + length < stream.node.usedBytes) {\n              if (contents.subarray) {\n                contents = contents.subarray(position, position + length);\n              } else {\n                contents = Array.prototype.slice.call(contents, position, position + length);\n              }\n            }\n\n            allocated = true;\n            ptr = _malloc(length);\n\n            if (!ptr) {\n              throw new FS.ErrnoError(ERRNO_CODES.ENOMEM);\n            }\n\n            buffer.set(contents, ptr);\n          }\n\n          return {\n            ptr: ptr,\n            allocated: allocated\n          };\n        },\n        msync: function (stream, buffer, offset, length, mmapFlags) {\n          if (!FS.isFile(stream.node.mode)) {\n            throw new FS.ErrnoError(ERRNO_CODES.ENODEV);\n          }\n\n          if (mmapFlags & 2) {\n            return 0;\n          }\n\n          var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\n          return 0;\n        }\n      }\n    };\n    var IDBFS = {\n      dbs: {},\n      indexedDB: function () {\n        if (typeof indexedDB !== \"undefined\") return indexedDB;\n        var ret = null;\n        if (typeof window === \"object\") ret = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\n        assert(ret, \"IDBFS used, but indexedDB not supported\");\n        return ret;\n      },\n      DB_VERSION: 21,\n      DB_STORE_NAME: \"FILE_DATA\",\n      mount: function (mount) {\n        return MEMFS.mount.apply(null, arguments);\n      },\n      syncfs: function (mount, populate, callback) {\n        IDBFS.getLocalSet(mount, function (err, local) {\n          if (err) return callback(err);\n          IDBFS.getRemoteSet(mount, function (err, remote) {\n            if (err) return callback(err);\n            var src = populate ? remote : local;\n            var dst = populate ? local : remote;\n            IDBFS.reconcile(src, dst, callback);\n          });\n        });\n      },\n      getDB: function (name, callback) {\n        var db = IDBFS.dbs[name];\n\n        if (db) {\n          return callback(null, db);\n        }\n\n        var req;\n\n        try {\n          req = IDBFS.indexedDB().open(name, IDBFS.DB_VERSION);\n        } catch (e) {\n          return callback(e);\n        }\n\n        if (!req) {\n          return callback(\"Unable to connect to IndexedDB\");\n        }\n\n        req.onupgradeneeded = function (e) {\n          var db = e.target.result;\n          var transaction = e.target.transaction;\n          var fileStore;\n\n          if (db.objectStoreNames.contains(IDBFS.DB_STORE_NAME)) {\n            fileStore = transaction.objectStore(IDBFS.DB_STORE_NAME);\n          } else {\n            fileStore = db.createObjectStore(IDBFS.DB_STORE_NAME);\n          }\n\n          if (!fileStore.indexNames.contains(\"timestamp\")) {\n            fileStore.createIndex(\"timestamp\", \"timestamp\", {\n              unique: false\n            });\n          }\n        };\n\n        req.onsuccess = function () {\n          db = req.result;\n          IDBFS.dbs[name] = db;\n          callback(null, db);\n        };\n\n        req.onerror = function (e) {\n          callback(this.error);\n          e.preventDefault();\n        };\n      },\n      getLocalSet: function (mount, callback) {\n        var entries = {};\n\n        function isRealDir(p) {\n          return p !== \".\" && p !== \"..\";\n        }\n\n        function toAbsolute(root) {\n          return function (p) {\n            return PATH.join2(root, p);\n          };\n        }\n\n        var check = FS.readdir(mount.mountpoint).filter(isRealDir).map(toAbsolute(mount.mountpoint));\n\n        while (check.length) {\n          var path = check.pop();\n          var stat;\n\n          try {\n            stat = FS.stat(path);\n          } catch (e) {\n            return callback(e);\n          }\n\n          if (FS.isDir(stat.mode)) {\n            check.push.apply(check, FS.readdir(path).filter(isRealDir).map(toAbsolute(path)));\n          }\n\n          entries[path] = {\n            timestamp: stat.mtime\n          };\n        }\n\n        return callback(null, {\n          type: \"local\",\n          entries: entries\n        });\n      },\n      getRemoteSet: function (mount, callback) {\n        var entries = {};\n        IDBFS.getDB(mount.mountpoint, function (err, db) {\n          if (err) return callback(err);\n\n          try {\n            var transaction = db.transaction([IDBFS.DB_STORE_NAME], \"readonly\");\n\n            transaction.onerror = function (e) {\n              callback(this.error);\n              e.preventDefault();\n            };\n\n            var store = transaction.objectStore(IDBFS.DB_STORE_NAME);\n            var index = store.index(\"timestamp\");\n\n            index.openKeyCursor().onsuccess = function (event) {\n              var cursor = event.target.result;\n\n              if (!cursor) {\n                return callback(null, {\n                  type: \"remote\",\n                  db: db,\n                  entries: entries\n                });\n              }\n\n              entries[cursor.primaryKey] = {\n                timestamp: cursor.key\n              };\n              cursor.continue();\n            };\n          } catch (e) {\n            return callback(e);\n          }\n        });\n      },\n      loadLocalEntry: function (path, callback) {\n        var stat, node;\n\n        try {\n          var lookup = FS.lookupPath(path);\n          node = lookup.node;\n          stat = FS.stat(path);\n        } catch (e) {\n          return callback(e);\n        }\n\n        if (FS.isDir(stat.mode)) {\n          return callback(null, {\n            timestamp: stat.mtime,\n            mode: stat.mode\n          });\n        } else if (FS.isFile(stat.mode)) {\n          node.contents = MEMFS.getFileDataAsTypedArray(node);\n          return callback(null, {\n            timestamp: stat.mtime,\n            mode: stat.mode,\n            contents: node.contents\n          });\n        } else {\n          return callback(new Error(\"node type not supported\"));\n        }\n      },\n      storeLocalEntry: function (path, entry, callback) {\n        try {\n          if (FS.isDir(entry.mode)) {\n            FS.mkdir(path, entry.mode);\n          } else if (FS.isFile(entry.mode)) {\n            FS.writeFile(path, entry.contents, {\n              canOwn: true\n            });\n          } else {\n            return callback(new Error(\"node type not supported\"));\n          }\n\n          FS.chmod(path, entry.mode);\n          FS.utime(path, entry.timestamp, entry.timestamp);\n        } catch (e) {\n          return callback(e);\n        }\n\n        callback(null);\n      },\n      removeLocalEntry: function (path, callback) {\n        try {\n          var lookup = FS.lookupPath(path);\n          var stat = FS.stat(path);\n\n          if (FS.isDir(stat.mode)) {\n            FS.rmdir(path);\n          } else if (FS.isFile(stat.mode)) {\n            FS.unlink(path);\n          }\n        } catch (e) {\n          return callback(e);\n        }\n\n        callback(null);\n      },\n      loadRemoteEntry: function (store, path, callback) {\n        var req = store.get(path);\n\n        req.onsuccess = function (event) {\n          callback(null, event.target.result);\n        };\n\n        req.onerror = function (e) {\n          callback(this.error);\n          e.preventDefault();\n        };\n      },\n      storeRemoteEntry: function (store, path, entry, callback) {\n        var req = store.put(entry, path);\n\n        req.onsuccess = function () {\n          callback(null);\n        };\n\n        req.onerror = function (e) {\n          callback(this.error);\n          e.preventDefault();\n        };\n      },\n      removeRemoteEntry: function (store, path, callback) {\n        var req = store.delete(path);\n\n        req.onsuccess = function () {\n          callback(null);\n        };\n\n        req.onerror = function (e) {\n          callback(this.error);\n          e.preventDefault();\n        };\n      },\n      reconcile: function (src, dst, callback) {\n        var total = 0;\n        var create = [];\n        Object.keys(src.entries).forEach(function (key) {\n          var e = src.entries[key];\n          var e2 = dst.entries[key];\n\n          if (!e2 || e.timestamp > e2.timestamp) {\n            create.push(key);\n            total++;\n          }\n        });\n        var remove = [];\n        Object.keys(dst.entries).forEach(function (key) {\n          var e = dst.entries[key];\n          var e2 = src.entries[key];\n\n          if (!e2) {\n            remove.push(key);\n            total++;\n          }\n        });\n\n        if (!total) {\n          return callback(null);\n        }\n\n        var errored = false;\n        var completed = 0;\n        var db = src.type === \"remote\" ? src.db : dst.db;\n        var transaction = db.transaction([IDBFS.DB_STORE_NAME], \"readwrite\");\n        var store = transaction.objectStore(IDBFS.DB_STORE_NAME);\n\n        function done(err) {\n          if (err) {\n            if (!done.errored) {\n              done.errored = true;\n              return callback(err);\n            }\n\n            return;\n          }\n\n          if (++completed >= total) {\n            return callback(null);\n          }\n        }\n\n        transaction.onerror = function (e) {\n          done(this.error);\n          e.preventDefault();\n        };\n\n        create.sort().forEach(function (path) {\n          if (dst.type === \"local\") {\n            IDBFS.loadRemoteEntry(store, path, function (err, entry) {\n              if (err) return done(err);\n              IDBFS.storeLocalEntry(path, entry, done);\n            });\n          } else {\n            IDBFS.loadLocalEntry(path, function (err, entry) {\n              if (err) return done(err);\n              IDBFS.storeRemoteEntry(store, path, entry, done);\n            });\n          }\n        });\n        remove.sort().reverse().forEach(function (path) {\n          if (dst.type === \"local\") {\n            IDBFS.removeLocalEntry(path, done);\n          } else {\n            IDBFS.removeRemoteEntry(store, path, done);\n          }\n        });\n      }\n    };\n    var NODEFS = {\n      isWindows: false,\n      staticInit: function () {\n        NODEFS.isWindows = !!process.platform.match(/^win/);\n        var flags = process[\"binding\"](\"constants\");\n\n        if (flags[\"fs\"]) {\n          flags = flags[\"fs\"];\n        }\n\n        NODEFS.flagsForNodeMap = {\n          1024: flags[\"O_APPEND\"],\n          64: flags[\"O_CREAT\"],\n          128: flags[\"O_EXCL\"],\n          0: flags[\"O_RDONLY\"],\n          2: flags[\"O_RDWR\"],\n          4096: flags[\"O_SYNC\"],\n          512: flags[\"O_TRUNC\"],\n          1: flags[\"O_WRONLY\"]\n        };\n      },\n      bufferFrom: function (arrayBuffer) {\n        return Buffer.alloc ? Buffer.from(arrayBuffer) : new Buffer(arrayBuffer);\n      },\n      mount: function (mount) {\n        assert(ENVIRONMENT_IS_NODE);\n        return NODEFS.createNode(null, \"/\", NODEFS.getMode(mount.opts.root), 0);\n      },\n      createNode: function (parent, name, mode, dev) {\n        if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n        }\n\n        var node = FS.createNode(parent, name, mode);\n        node.node_ops = NODEFS.node_ops;\n        node.stream_ops = NODEFS.stream_ops;\n        return node;\n      },\n      getMode: function (path) {\n        var stat;\n\n        try {\n          stat = fs.lstatSync(path);\n\n          if (NODEFS.isWindows) {\n            stat.mode = stat.mode | (stat.mode & 292) >> 2;\n          }\n        } catch (e) {\n          if (!e.code) throw e;\n          throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n        }\n\n        return stat.mode;\n      },\n      realPath: function (node) {\n        var parts = [];\n\n        while (node.parent !== node) {\n          parts.push(node.name);\n          node = node.parent;\n        }\n\n        parts.push(node.mount.opts.root);\n        parts.reverse();\n        return PATH.join.apply(null, parts);\n      },\n      flagsForNode: function (flags) {\n        flags &= ~2097152;\n        flags &= ~2048;\n        flags &= ~32768;\n        flags &= ~524288;\n        var newFlags = 0;\n\n        for (var k in NODEFS.flagsForNodeMap) {\n          if (flags & k) {\n            newFlags |= NODEFS.flagsForNodeMap[k];\n            flags ^= k;\n          }\n        }\n\n        if (!flags) {\n          return newFlags;\n        } else {\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n        }\n      },\n      node_ops: {\n        getattr: function (node) {\n          var path = NODEFS.realPath(node);\n          var stat;\n\n          try {\n            stat = fs.lstatSync(path);\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n\n          if (NODEFS.isWindows && !stat.blksize) {\n            stat.blksize = 4096;\n          }\n\n          if (NODEFS.isWindows && !stat.blocks) {\n            stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;\n          }\n\n          return {\n            dev: stat.dev,\n            ino: stat.ino,\n            mode: stat.mode,\n            nlink: stat.nlink,\n            uid: stat.uid,\n            gid: stat.gid,\n            rdev: stat.rdev,\n            size: stat.size,\n            atime: stat.atime,\n            mtime: stat.mtime,\n            ctime: stat.ctime,\n            blksize: stat.blksize,\n            blocks: stat.blocks\n          };\n        },\n        setattr: function (node, attr) {\n          var path = NODEFS.realPath(node);\n\n          try {\n            if (attr.mode !== undefined) {\n              fs.chmodSync(path, attr.mode);\n              node.mode = attr.mode;\n            }\n\n            if (attr.timestamp !== undefined) {\n              var date = new Date(attr.timestamp);\n              fs.utimesSync(path, date, date);\n            }\n\n            if (attr.size !== undefined) {\n              fs.truncateSync(path, attr.size);\n            }\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n        },\n        lookup: function (parent, name) {\n          var path = PATH.join2(NODEFS.realPath(parent), name);\n          var mode = NODEFS.getMode(path);\n          return NODEFS.createNode(parent, name, mode);\n        },\n        mknod: function (parent, name, mode, dev) {\n          var node = NODEFS.createNode(parent, name, mode, dev);\n          var path = NODEFS.realPath(node);\n\n          try {\n            if (FS.isDir(node.mode)) {\n              fs.mkdirSync(path, node.mode);\n            } else {\n              fs.writeFileSync(path, \"\", {\n                mode: node.mode\n              });\n            }\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n\n          return node;\n        },\n        rename: function (oldNode, newDir, newName) {\n          var oldPath = NODEFS.realPath(oldNode);\n          var newPath = PATH.join2(NODEFS.realPath(newDir), newName);\n\n          try {\n            fs.renameSync(oldPath, newPath);\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n        },\n        unlink: function (parent, name) {\n          var path = PATH.join2(NODEFS.realPath(parent), name);\n\n          try {\n            fs.unlinkSync(path);\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n        },\n        rmdir: function (parent, name) {\n          var path = PATH.join2(NODEFS.realPath(parent), name);\n\n          try {\n            fs.rmdirSync(path);\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n        },\n        readdir: function (node) {\n          var path = NODEFS.realPath(node);\n\n          try {\n            return fs.readdirSync(path);\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n        },\n        symlink: function (parent, newName, oldPath) {\n          var newPath = PATH.join2(NODEFS.realPath(parent), newName);\n\n          try {\n            fs.symlinkSync(oldPath, newPath);\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n        },\n        readlink: function (node) {\n          var path = NODEFS.realPath(node);\n\n          try {\n            path = fs.readlinkSync(path);\n            path = NODEJS_PATH.relative(NODEJS_PATH.resolve(node.mount.opts.root), path);\n            return path;\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n        }\n      },\n      stream_ops: {\n        open: function (stream) {\n          var path = NODEFS.realPath(stream.node);\n\n          try {\n            if (FS.isFile(stream.node.mode)) {\n              stream.nfd = fs.openSync(path, NODEFS.flagsForNode(stream.flags));\n            }\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n        },\n        close: function (stream) {\n          try {\n            if (FS.isFile(stream.node.mode) && stream.nfd) {\n              fs.closeSync(stream.nfd);\n            }\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n        },\n        read: function (stream, buffer, offset, length, position) {\n          if (length === 0) return 0;\n\n          try {\n            return fs.readSync(stream.nfd, NODEFS.bufferFrom(buffer.buffer), offset, length, position);\n          } catch (e) {\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n        },\n        write: function (stream, buffer, offset, length, position) {\n          try {\n            return fs.writeSync(stream.nfd, NODEFS.bufferFrom(buffer.buffer), offset, length, position);\n          } catch (e) {\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n        },\n        llseek: function (stream, offset, whence) {\n          var position = offset;\n\n          if (whence === 1) {\n            position += stream.position;\n          } else if (whence === 2) {\n            if (FS.isFile(stream.node.mode)) {\n              try {\n                var stat = fs.fstatSync(stream.nfd);\n                position += stat.size;\n              } catch (e) {\n                throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n              }\n            }\n          }\n\n          if (position < 0) {\n            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n          }\n\n          return position;\n        }\n      }\n    };\n    var WORKERFS = {\n      DIR_MODE: 16895,\n      FILE_MODE: 33279,\n      reader: null,\n      mount: function (mount) {\n        assert(ENVIRONMENT_IS_WORKER);\n        if (!WORKERFS.reader) WORKERFS.reader = new FileReaderSync();\n        var root = WORKERFS.createNode(null, \"/\", WORKERFS.DIR_MODE, 0);\n        var createdParents = {};\n\n        function ensureParent(path) {\n          var parts = path.split(\"/\");\n          var parent = root;\n\n          for (var i = 0; i < parts.length - 1; i++) {\n            var curr = parts.slice(0, i + 1).join(\"/\");\n\n            if (!createdParents[curr]) {\n              createdParents[curr] = WORKERFS.createNode(parent, parts[i], WORKERFS.DIR_MODE, 0);\n            }\n\n            parent = createdParents[curr];\n          }\n\n          return parent;\n        }\n\n        function base(path) {\n          var parts = path.split(\"/\");\n          return parts[parts.length - 1];\n        }\n\n        Array.prototype.forEach.call(mount.opts[\"files\"] || [], function (file) {\n          WORKERFS.createNode(ensureParent(file.name), base(file.name), WORKERFS.FILE_MODE, 0, file, file.lastModifiedDate);\n        });\n        (mount.opts[\"blobs\"] || []).forEach(function (obj) {\n          WORKERFS.createNode(ensureParent(obj[\"name\"]), base(obj[\"name\"]), WORKERFS.FILE_MODE, 0, obj[\"data\"]);\n        });\n        (mount.opts[\"packages\"] || []).forEach(function (pack) {\n          pack[\"metadata\"].files.forEach(function (file) {\n            var name = file.filename.substr(1);\n            WORKERFS.createNode(ensureParent(name), base(name), WORKERFS.FILE_MODE, 0, pack[\"blob\"].slice(file.start, file.end));\n          });\n        });\n        return root;\n      },\n      createNode: function (parent, name, mode, dev, contents, mtime) {\n        var node = FS.createNode(parent, name, mode);\n        node.mode = mode;\n        node.node_ops = WORKERFS.node_ops;\n        node.stream_ops = WORKERFS.stream_ops;\n        node.timestamp = (mtime || new Date()).getTime();\n        assert(WORKERFS.FILE_MODE !== WORKERFS.DIR_MODE);\n\n        if (mode === WORKERFS.FILE_MODE) {\n          node.size = contents.size;\n          node.contents = contents;\n        } else {\n          node.size = 4096;\n          node.contents = {};\n        }\n\n        if (parent) {\n          parent.contents[name] = node;\n        }\n\n        return node;\n      },\n      node_ops: {\n        getattr: function (node) {\n          return {\n            dev: 1,\n            ino: undefined,\n            mode: node.mode,\n            nlink: 1,\n            uid: 0,\n            gid: 0,\n            rdev: undefined,\n            size: node.size,\n            atime: new Date(node.timestamp),\n            mtime: new Date(node.timestamp),\n            ctime: new Date(node.timestamp),\n            blksize: 4096,\n            blocks: Math.ceil(node.size / 4096)\n          };\n        },\n        setattr: function (node, attr) {\n          if (attr.mode !== undefined) {\n            node.mode = attr.mode;\n          }\n\n          if (attr.timestamp !== undefined) {\n            node.timestamp = attr.timestamp;\n          }\n        },\n        lookup: function (parent, name) {\n          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);\n        },\n        mknod: function (parent, name, mode, dev) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        },\n        rename: function (oldNode, newDir, newName) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        },\n        unlink: function (parent, name) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        },\n        rmdir: function (parent, name) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        },\n        readdir: function (node) {\n          var entries = [\".\", \"..\"];\n\n          for (var key in node.contents) {\n            if (!node.contents.hasOwnProperty(key)) {\n              continue;\n            }\n\n            entries.push(key);\n          }\n\n          return entries;\n        },\n        symlink: function (parent, newName, oldPath) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        },\n        readlink: function (node) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        }\n      },\n      stream_ops: {\n        read: function (stream, buffer, offset, length, position) {\n          if (position >= stream.node.size) return 0;\n          var chunk = stream.node.contents.slice(position, position + length);\n          var ab = WORKERFS.reader.readAsArrayBuffer(chunk);\n          buffer.set(new Uint8Array(ab), offset);\n          return chunk.size;\n        },\n        write: function (stream, buffer, offset, length, position) {\n          throw new FS.ErrnoError(ERRNO_CODES.EIO);\n        },\n        llseek: function (stream, offset, whence) {\n          var position = offset;\n\n          if (whence === 1) {\n            position += stream.position;\n          } else if (whence === 2) {\n            if (FS.isFile(stream.node.mode)) {\n              position += stream.node.size;\n            }\n          }\n\n          if (position < 0) {\n            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n          }\n\n          return position;\n        }\n      }\n    };\n    var FS = {\n      root: null,\n      mounts: [],\n      devices: {},\n      streams: [],\n      nextInode: 1,\n      nameTable: null,\n      currentPath: \"/\",\n      initialized: false,\n      ignorePermissions: true,\n      trackingDelegate: {},\n      tracking: {\n        openFlags: {\n          READ: 1,\n          WRITE: 2\n        }\n      },\n      ErrnoError: null,\n      genericErrors: {},\n      filesystems: null,\n      syncFSRequests: 0,\n      handleFSError: function (e) {\n        if (!(e instanceof FS.ErrnoError)) throw e + \" : \" + stackTrace();\n        return ___setErrNo(e.errno);\n      },\n      lookupPath: function (path, opts) {\n        path = PATH.resolve(FS.cwd(), path);\n        opts = opts || {};\n        if (!path) return {\n          path: \"\",\n          node: null\n        };\n        var defaults = {\n          follow_mount: true,\n          recurse_count: 0\n        };\n\n        for (var key in defaults) {\n          if (opts[key] === undefined) {\n            opts[key] = defaults[key];\n          }\n        }\n\n        if (opts.recurse_count > 8) {\n          throw new FS.ErrnoError(40);\n        }\n\n        var parts = PATH.normalizeArray(path.split(\"/\").filter(function (p) {\n          return !!p;\n        }), false);\n        var current = FS.root;\n        var current_path = \"/\";\n\n        for (var i = 0; i < parts.length; i++) {\n          var islast = i === parts.length - 1;\n\n          if (islast && opts.parent) {\n            break;\n          }\n\n          current = FS.lookupNode(current, parts[i]);\n          current_path = PATH.join2(current_path, parts[i]);\n\n          if (FS.isMountpoint(current)) {\n            if (!islast || islast && opts.follow_mount) {\n              current = current.mounted.root;\n            }\n          }\n\n          if (!islast || opts.follow) {\n            var count = 0;\n\n            while (FS.isLink(current.mode)) {\n              var link = FS.readlink(current_path);\n              current_path = PATH.resolve(PATH.dirname(current_path), link);\n              var lookup = FS.lookupPath(current_path, {\n                recurse_count: opts.recurse_count\n              });\n              current = lookup.node;\n\n              if (count++ > 40) {\n                throw new FS.ErrnoError(40);\n              }\n            }\n          }\n        }\n\n        return {\n          path: current_path,\n          node: current\n        };\n      },\n      getPath: function (node) {\n        var path;\n\n        while (true) {\n          if (FS.isRoot(node)) {\n            var mount = node.mount.mountpoint;\n            if (!path) return mount;\n            return mount[mount.length - 1] !== \"/\" ? mount + \"/\" + path : mount + path;\n          }\n\n          path = path ? node.name + \"/\" + path : node.name;\n          node = node.parent;\n        }\n      },\n      hashName: function (parentid, name) {\n        var hash = 0;\n\n        for (var i = 0; i < name.length; i++) {\n          hash = (hash << 5) - hash + name.charCodeAt(i) | 0;\n        }\n\n        return (parentid + hash >>> 0) % FS.nameTable.length;\n      },\n      hashAddNode: function (node) {\n        var hash = FS.hashName(node.parent.id, node.name);\n        node.name_next = FS.nameTable[hash];\n        FS.nameTable[hash] = node;\n      },\n      hashRemoveNode: function (node) {\n        var hash = FS.hashName(node.parent.id, node.name);\n\n        if (FS.nameTable[hash] === node) {\n          FS.nameTable[hash] = node.name_next;\n        } else {\n          var current = FS.nameTable[hash];\n\n          while (current) {\n            if (current.name_next === node) {\n              current.name_next = node.name_next;\n              break;\n            }\n\n            current = current.name_next;\n          }\n        }\n      },\n      lookupNode: function (parent, name) {\n        var err = FS.mayLookup(parent);\n\n        if (err) {\n          throw new FS.ErrnoError(err, parent);\n        }\n\n        var hash = FS.hashName(parent.id, name);\n\n        for (var node = FS.nameTable[hash]; node; node = node.name_next) {\n          var nodeName = node.name;\n\n          if (node.parent.id === parent.id && nodeName === name) {\n            return node;\n          }\n        }\n\n        return FS.lookup(parent, name);\n      },\n      createNode: function (parent, name, mode, rdev) {\n        if (!FS.FSNode) {\n          FS.FSNode = function (parent, name, mode, rdev) {\n            if (!parent) {\n              parent = this;\n            }\n\n            this.parent = parent;\n            this.mount = parent.mount;\n            this.mounted = null;\n            this.id = FS.nextInode++;\n            this.name = name;\n            this.mode = mode;\n            this.node_ops = {};\n            this.stream_ops = {};\n            this.rdev = rdev;\n          };\n\n          FS.FSNode.prototype = {};\n          var readMode = 292 | 73;\n          var writeMode = 146;\n          Object.defineProperties(FS.FSNode.prototype, {\n            read: {\n              get: function () {\n                return (this.mode & readMode) === readMode;\n              },\n              set: function (val) {\n                val ? this.mode |= readMode : this.mode &= ~readMode;\n              }\n            },\n            write: {\n              get: function () {\n                return (this.mode & writeMode) === writeMode;\n              },\n              set: function (val) {\n                val ? this.mode |= writeMode : this.mode &= ~writeMode;\n              }\n            },\n            isFolder: {\n              get: function () {\n                return FS.isDir(this.mode);\n              }\n            },\n            isDevice: {\n              get: function () {\n                return FS.isChrdev(this.mode);\n              }\n            }\n          });\n        }\n\n        var node = new FS.FSNode(parent, name, mode, rdev);\n        FS.hashAddNode(node);\n        return node;\n      },\n      destroyNode: function (node) {\n        FS.hashRemoveNode(node);\n      },\n      isRoot: function (node) {\n        return node === node.parent;\n      },\n      isMountpoint: function (node) {\n        return !!node.mounted;\n      },\n      isFile: function (mode) {\n        return (mode & 61440) === 32768;\n      },\n      isDir: function (mode) {\n        return (mode & 61440) === 16384;\n      },\n      isLink: function (mode) {\n        return (mode & 61440) === 40960;\n      },\n      isChrdev: function (mode) {\n        return (mode & 61440) === 8192;\n      },\n      isBlkdev: function (mode) {\n        return (mode & 61440) === 24576;\n      },\n      isFIFO: function (mode) {\n        return (mode & 61440) === 4096;\n      },\n      isSocket: function (mode) {\n        return (mode & 49152) === 49152;\n      },\n      flagModes: {\n        \"r\": 0,\n        \"rs\": 1052672,\n        \"r+\": 2,\n        \"w\": 577,\n        \"wx\": 705,\n        \"xw\": 705,\n        \"w+\": 578,\n        \"wx+\": 706,\n        \"xw+\": 706,\n        \"a\": 1089,\n        \"ax\": 1217,\n        \"xa\": 1217,\n        \"a+\": 1090,\n        \"ax+\": 1218,\n        \"xa+\": 1218\n      },\n      modeStringToFlags: function (str) {\n        var flags = FS.flagModes[str];\n\n        if (typeof flags === \"undefined\") {\n          throw new Error(\"Unknown file open mode: \" + str);\n        }\n\n        return flags;\n      },\n      flagsToPermissionString: function (flag) {\n        var perms = [\"r\", \"w\", \"rw\"][flag & 3];\n\n        if (flag & 512) {\n          perms += \"w\";\n        }\n\n        return perms;\n      },\n      nodePermissions: function (node, perms) {\n        if (FS.ignorePermissions) {\n          return 0;\n        }\n\n        if (perms.indexOf(\"r\") !== -1 && !(node.mode & 292)) {\n          return 13;\n        } else if (perms.indexOf(\"w\") !== -1 && !(node.mode & 146)) {\n          return 13;\n        } else if (perms.indexOf(\"x\") !== -1 && !(node.mode & 73)) {\n          return 13;\n        }\n\n        return 0;\n      },\n      mayLookup: function (dir) {\n        var err = FS.nodePermissions(dir, \"x\");\n        if (err) return err;\n        if (!dir.node_ops.lookup) return 13;\n        return 0;\n      },\n      mayCreate: function (dir, name) {\n        try {\n          var node = FS.lookupNode(dir, name);\n          return 17;\n        } catch (e) {}\n\n        return FS.nodePermissions(dir, \"wx\");\n      },\n      mayDelete: function (dir, name, isdir) {\n        var node;\n\n        try {\n          node = FS.lookupNode(dir, name);\n        } catch (e) {\n          return e.errno;\n        }\n\n        var err = FS.nodePermissions(dir, \"wx\");\n\n        if (err) {\n          return err;\n        }\n\n        if (isdir) {\n          if (!FS.isDir(node.mode)) {\n            return 20;\n          }\n\n          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\n            return 16;\n          }\n        } else {\n          if (FS.isDir(node.mode)) {\n            return 21;\n          }\n        }\n\n        return 0;\n      },\n      mayOpen: function (node, flags) {\n        if (!node) {\n          return 2;\n        }\n\n        if (FS.isLink(node.mode)) {\n          return 40;\n        } else if (FS.isDir(node.mode)) {\n          if (FS.flagsToPermissionString(flags) !== \"r\" || flags & 512) {\n            return 21;\n          }\n        }\n\n        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\n      },\n      MAX_OPEN_FDS: 4096,\n      nextfd: function (fd_start, fd_end) {\n        fd_start = fd_start || 0;\n        fd_end = fd_end || FS.MAX_OPEN_FDS;\n\n        for (var fd = fd_start; fd <= fd_end; fd++) {\n          if (!FS.streams[fd]) {\n            return fd;\n          }\n        }\n\n        throw new FS.ErrnoError(24);\n      },\n      getStream: function (fd) {\n        return FS.streams[fd];\n      },\n      createStream: function (stream, fd_start, fd_end) {\n        if (!FS.FSStream) {\n          FS.FSStream = function () {};\n\n          FS.FSStream.prototype = {};\n          Object.defineProperties(FS.FSStream.prototype, {\n            object: {\n              get: function () {\n                return this.node;\n              },\n              set: function (val) {\n                this.node = val;\n              }\n            },\n            isRead: {\n              get: function () {\n                return (this.flags & 2097155) !== 1;\n              }\n            },\n            isWrite: {\n              get: function () {\n                return (this.flags & 2097155) !== 0;\n              }\n            },\n            isAppend: {\n              get: function () {\n                return this.flags & 1024;\n              }\n            }\n          });\n        }\n\n        var newStream = new FS.FSStream();\n\n        for (var p in stream) {\n          newStream[p] = stream[p];\n        }\n\n        stream = newStream;\n        var fd = FS.nextfd(fd_start, fd_end);\n        stream.fd = fd;\n        FS.streams[fd] = stream;\n        return stream;\n      },\n      closeStream: function (fd) {\n        FS.streams[fd] = null;\n      },\n      chrdev_stream_ops: {\n        open: function (stream) {\n          var device = FS.getDevice(stream.node.rdev);\n          stream.stream_ops = device.stream_ops;\n\n          if (stream.stream_ops.open) {\n            stream.stream_ops.open(stream);\n          }\n        },\n        llseek: function () {\n          throw new FS.ErrnoError(29);\n        }\n      },\n      major: function (dev) {\n        return dev >> 8;\n      },\n      minor: function (dev) {\n        return dev & 255;\n      },\n      makedev: function (ma, mi) {\n        return ma << 8 | mi;\n      },\n      registerDevice: function (dev, ops) {\n        FS.devices[dev] = {\n          stream_ops: ops\n        };\n      },\n      getDevice: function (dev) {\n        return FS.devices[dev];\n      },\n      getMounts: function (mount) {\n        var mounts = [];\n        var check = [mount];\n\n        while (check.length) {\n          var m = check.pop();\n          mounts.push(m);\n          check.push.apply(check, m.mounts);\n        }\n\n        return mounts;\n      },\n      syncfs: function (populate, callback) {\n        if (typeof populate === \"function\") {\n          callback = populate;\n          populate = false;\n        }\n\n        FS.syncFSRequests++;\n\n        if (FS.syncFSRequests > 1) {\n          console.log(\"warning: \" + FS.syncFSRequests + \" FS.syncfs operations in flight at once, probably just doing extra work\");\n        }\n\n        var mounts = FS.getMounts(FS.root.mount);\n        var completed = 0;\n\n        function doCallback(err) {\n          FS.syncFSRequests--;\n          return callback(err);\n        }\n\n        function done(err) {\n          if (err) {\n            if (!done.errored) {\n              done.errored = true;\n              return doCallback(err);\n            }\n\n            return;\n          }\n\n          if (++completed >= mounts.length) {\n            doCallback(null);\n          }\n        }\n\n        mounts.forEach(function (mount) {\n          if (!mount.type.syncfs) {\n            return done(null);\n          }\n\n          mount.type.syncfs(mount, populate, done);\n        });\n      },\n      mount: function (type, opts, mountpoint) {\n        var root = mountpoint === \"/\";\n        var pseudo = !mountpoint;\n        var node;\n\n        if (root && FS.root) {\n          throw new FS.ErrnoError(16);\n        } else if (!root && !pseudo) {\n          var lookup = FS.lookupPath(mountpoint, {\n            follow_mount: false\n          });\n          mountpoint = lookup.path;\n          node = lookup.node;\n\n          if (FS.isMountpoint(node)) {\n            throw new FS.ErrnoError(16);\n          }\n\n          if (!FS.isDir(node.mode)) {\n            throw new FS.ErrnoError(20);\n          }\n        }\n\n        var mount = {\n          type: type,\n          opts: opts,\n          mountpoint: mountpoint,\n          mounts: []\n        };\n        var mountRoot = type.mount(mount);\n        mountRoot.mount = mount;\n        mount.root = mountRoot;\n\n        if (root) {\n          FS.root = mountRoot;\n        } else if (node) {\n          node.mounted = mount;\n\n          if (node.mount) {\n            node.mount.mounts.push(mount);\n          }\n        }\n\n        return mountRoot;\n      },\n      unmount: function (mountpoint) {\n        var lookup = FS.lookupPath(mountpoint, {\n          follow_mount: false\n        });\n\n        if (!FS.isMountpoint(lookup.node)) {\n          throw new FS.ErrnoError(22);\n        }\n\n        var node = lookup.node;\n        var mount = node.mounted;\n        var mounts = FS.getMounts(mount);\n        Object.keys(FS.nameTable).forEach(function (hash) {\n          var current = FS.nameTable[hash];\n\n          while (current) {\n            var next = current.name_next;\n\n            if (mounts.indexOf(current.mount) !== -1) {\n              FS.destroyNode(current);\n            }\n\n            current = next;\n          }\n        });\n        node.mounted = null;\n        var idx = node.mount.mounts.indexOf(mount);\n        node.mount.mounts.splice(idx, 1);\n      },\n      lookup: function (parent, name) {\n        return parent.node_ops.lookup(parent, name);\n      },\n      mknod: function (path, mode, dev) {\n        var lookup = FS.lookupPath(path, {\n          parent: true\n        });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n\n        if (!name || name === \".\" || name === \"..\") {\n          throw new FS.ErrnoError(22);\n        }\n\n        var err = FS.mayCreate(parent, name);\n\n        if (err) {\n          throw new FS.ErrnoError(err);\n        }\n\n        if (!parent.node_ops.mknod) {\n          throw new FS.ErrnoError(1);\n        }\n\n        return parent.node_ops.mknod(parent, name, mode, dev);\n      },\n      create: function (path, mode) {\n        mode = mode !== undefined ? mode : 438;\n        mode &= 4095;\n        mode |= 32768;\n        return FS.mknod(path, mode, 0);\n      },\n      mkdir: function (path, mode) {\n        mode = mode !== undefined ? mode : 511;\n        mode &= 511 | 512;\n        mode |= 16384;\n        return FS.mknod(path, mode, 0);\n      },\n      mkdirTree: function (path, mode) {\n        var dirs = path.split(\"/\");\n        var d = \"\";\n\n        for (var i = 0; i < dirs.length; ++i) {\n          if (!dirs[i]) continue;\n          d += \"/\" + dirs[i];\n\n          try {\n            FS.mkdir(d, mode);\n          } catch (e) {\n            if (e.errno != 17) throw e;\n          }\n        }\n      },\n      mkdev: function (path, mode, dev) {\n        if (typeof dev === \"undefined\") {\n          dev = mode;\n          mode = 438;\n        }\n\n        mode |= 8192;\n        return FS.mknod(path, mode, dev);\n      },\n      symlink: function (oldpath, newpath) {\n        if (!PATH.resolve(oldpath)) {\n          throw new FS.ErrnoError(2);\n        }\n\n        var lookup = FS.lookupPath(newpath, {\n          parent: true\n        });\n        var parent = lookup.node;\n\n        if (!parent) {\n          throw new FS.ErrnoError(2);\n        }\n\n        var newname = PATH.basename(newpath);\n        var err = FS.mayCreate(parent, newname);\n\n        if (err) {\n          throw new FS.ErrnoError(err);\n        }\n\n        if (!parent.node_ops.symlink) {\n          throw new FS.ErrnoError(1);\n        }\n\n        return parent.node_ops.symlink(parent, newname, oldpath);\n      },\n      rename: function (old_path, new_path) {\n        var old_dirname = PATH.dirname(old_path);\n        var new_dirname = PATH.dirname(new_path);\n        var old_name = PATH.basename(old_path);\n        var new_name = PATH.basename(new_path);\n        var lookup, old_dir, new_dir;\n\n        try {\n          lookup = FS.lookupPath(old_path, {\n            parent: true\n          });\n          old_dir = lookup.node;\n          lookup = FS.lookupPath(new_path, {\n            parent: true\n          });\n          new_dir = lookup.node;\n        } catch (e) {\n          throw new FS.ErrnoError(16);\n        }\n\n        if (!old_dir || !new_dir) throw new FS.ErrnoError(2);\n\n        if (old_dir.mount !== new_dir.mount) {\n          throw new FS.ErrnoError(18);\n        }\n\n        var old_node = FS.lookupNode(old_dir, old_name);\n        var relative = PATH.relative(old_path, new_dirname);\n\n        if (relative.charAt(0) !== \".\") {\n          throw new FS.ErrnoError(22);\n        }\n\n        relative = PATH.relative(new_path, old_dirname);\n\n        if (relative.charAt(0) !== \".\") {\n          throw new FS.ErrnoError(39);\n        }\n\n        var new_node;\n\n        try {\n          new_node = FS.lookupNode(new_dir, new_name);\n        } catch (e) {}\n\n        if (old_node === new_node) {\n          return;\n        }\n\n        var isdir = FS.isDir(old_node.mode);\n        var err = FS.mayDelete(old_dir, old_name, isdir);\n\n        if (err) {\n          throw new FS.ErrnoError(err);\n        }\n\n        err = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);\n\n        if (err) {\n          throw new FS.ErrnoError(err);\n        }\n\n        if (!old_dir.node_ops.rename) {\n          throw new FS.ErrnoError(1);\n        }\n\n        if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {\n          throw new FS.ErrnoError(16);\n        }\n\n        if (new_dir !== old_dir) {\n          err = FS.nodePermissions(old_dir, \"w\");\n\n          if (err) {\n            throw new FS.ErrnoError(err);\n          }\n        }\n\n        try {\n          if (FS.trackingDelegate[\"willMovePath\"]) {\n            FS.trackingDelegate[\"willMovePath\"](old_path, new_path);\n          }\n        } catch (e) {\n          console.log(\"FS.trackingDelegate['willMovePath']('\" + old_path + \"', '\" + new_path + \"') threw an exception: \" + e.message);\n        }\n\n        FS.hashRemoveNode(old_node);\n\n        try {\n          old_dir.node_ops.rename(old_node, new_dir, new_name);\n        } catch (e) {\n          throw e;\n        } finally {\n          FS.hashAddNode(old_node);\n        }\n\n        try {\n          if (FS.trackingDelegate[\"onMovePath\"]) FS.trackingDelegate[\"onMovePath\"](old_path, new_path);\n        } catch (e) {\n          console.log(\"FS.trackingDelegate['onMovePath']('\" + old_path + \"', '\" + new_path + \"') threw an exception: \" + e.message);\n        }\n      },\n      rmdir: function (path) {\n        var lookup = FS.lookupPath(path, {\n          parent: true\n        });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        var node = FS.lookupNode(parent, name);\n        var err = FS.mayDelete(parent, name, true);\n\n        if (err) {\n          throw new FS.ErrnoError(err);\n        }\n\n        if (!parent.node_ops.rmdir) {\n          throw new FS.ErrnoError(1);\n        }\n\n        if (FS.isMountpoint(node)) {\n          throw new FS.ErrnoError(16);\n        }\n\n        try {\n          if (FS.trackingDelegate[\"willDeletePath\"]) {\n            FS.trackingDelegate[\"willDeletePath\"](path);\n          }\n        } catch (e) {\n          console.log(\"FS.trackingDelegate['willDeletePath']('\" + path + \"') threw an exception: \" + e.message);\n        }\n\n        parent.node_ops.rmdir(parent, name);\n        FS.destroyNode(node);\n\n        try {\n          if (FS.trackingDelegate[\"onDeletePath\"]) FS.trackingDelegate[\"onDeletePath\"](path);\n        } catch (e) {\n          console.log(\"FS.trackingDelegate['onDeletePath']('\" + path + \"') threw an exception: \" + e.message);\n        }\n      },\n      readdir: function (path) {\n        var lookup = FS.lookupPath(path, {\n          follow: true\n        });\n        var node = lookup.node;\n\n        if (!node.node_ops.readdir) {\n          throw new FS.ErrnoError(20);\n        }\n\n        return node.node_ops.readdir(node);\n      },\n      unlink: function (path) {\n        var lookup = FS.lookupPath(path, {\n          parent: true\n        });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        var node = FS.lookupNode(parent, name);\n        var err = FS.mayDelete(parent, name, false);\n\n        if (err) {\n          throw new FS.ErrnoError(err);\n        }\n\n        if (!parent.node_ops.unlink) {\n          throw new FS.ErrnoError(1);\n        }\n\n        if (FS.isMountpoint(node)) {\n          throw new FS.ErrnoError(16);\n        }\n\n        try {\n          if (FS.trackingDelegate[\"willDeletePath\"]) {\n            FS.trackingDelegate[\"willDeletePath\"](path);\n          }\n        } catch (e) {\n          console.log(\"FS.trackingDelegate['willDeletePath']('\" + path + \"') threw an exception: \" + e.message);\n        }\n\n        parent.node_ops.unlink(parent, name);\n        FS.destroyNode(node);\n\n        try {\n          if (FS.trackingDelegate[\"onDeletePath\"]) FS.trackingDelegate[\"onDeletePath\"](path);\n        } catch (e) {\n          console.log(\"FS.trackingDelegate['onDeletePath']('\" + path + \"') threw an exception: \" + e.message);\n        }\n      },\n      readlink: function (path) {\n        var lookup = FS.lookupPath(path);\n        var link = lookup.node;\n\n        if (!link) {\n          throw new FS.ErrnoError(2);\n        }\n\n        if (!link.node_ops.readlink) {\n          throw new FS.ErrnoError(22);\n        }\n\n        return PATH.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));\n      },\n      stat: function (path, dontFollow) {\n        var lookup = FS.lookupPath(path, {\n          follow: !dontFollow\n        });\n        var node = lookup.node;\n\n        if (!node) {\n          throw new FS.ErrnoError(2);\n        }\n\n        if (!node.node_ops.getattr) {\n          throw new FS.ErrnoError(1);\n        }\n\n        return node.node_ops.getattr(node);\n      },\n      lstat: function (path) {\n        return FS.stat(path, true);\n      },\n      chmod: function (path, mode, dontFollow) {\n        var node;\n\n        if (typeof path === \"string\") {\n          var lookup = FS.lookupPath(path, {\n            follow: !dontFollow\n          });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(1);\n        }\n\n        node.node_ops.setattr(node, {\n          mode: mode & 4095 | node.mode & ~4095,\n          timestamp: Date.now()\n        });\n      },\n      lchmod: function (path, mode) {\n        FS.chmod(path, mode, true);\n      },\n      fchmod: function (fd, mode) {\n        var stream = FS.getStream(fd);\n\n        if (!stream) {\n          throw new FS.ErrnoError(9);\n        }\n\n        FS.chmod(stream.node, mode);\n      },\n      chown: function (path, uid, gid, dontFollow) {\n        var node;\n\n        if (typeof path === \"string\") {\n          var lookup = FS.lookupPath(path, {\n            follow: !dontFollow\n          });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(1);\n        }\n\n        node.node_ops.setattr(node, {\n          timestamp: Date.now()\n        });\n      },\n      lchown: function (path, uid, gid) {\n        FS.chown(path, uid, gid, true);\n      },\n      fchown: function (fd, uid, gid) {\n        var stream = FS.getStream(fd);\n\n        if (!stream) {\n          throw new FS.ErrnoError(9);\n        }\n\n        FS.chown(stream.node, uid, gid);\n      },\n      truncate: function (path, len) {\n        if (len < 0) {\n          throw new FS.ErrnoError(22);\n        }\n\n        var node;\n\n        if (typeof path === \"string\") {\n          var lookup = FS.lookupPath(path, {\n            follow: true\n          });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(1);\n        }\n\n        if (FS.isDir(node.mode)) {\n          throw new FS.ErrnoError(21);\n        }\n\n        if (!FS.isFile(node.mode)) {\n          throw new FS.ErrnoError(22);\n        }\n\n        var err = FS.nodePermissions(node, \"w\");\n\n        if (err) {\n          throw new FS.ErrnoError(err);\n        }\n\n        node.node_ops.setattr(node, {\n          size: len,\n          timestamp: Date.now()\n        });\n      },\n      ftruncate: function (fd, len) {\n        var stream = FS.getStream(fd);\n\n        if (!stream) {\n          throw new FS.ErrnoError(9);\n        }\n\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(22);\n        }\n\n        FS.truncate(stream.node, len);\n      },\n      utime: function (path, atime, mtime) {\n        var lookup = FS.lookupPath(path, {\n          follow: true\n        });\n        var node = lookup.node;\n        node.node_ops.setattr(node, {\n          timestamp: Math.max(atime, mtime)\n        });\n      },\n      open: function (path, flags, mode, fd_start, fd_end) {\n        if (path === \"\") {\n          throw new FS.ErrnoError(2);\n        }\n\n        flags = typeof flags === \"string\" ? FS.modeStringToFlags(flags) : flags;\n        mode = typeof mode === \"undefined\" ? 438 : mode;\n\n        if (flags & 64) {\n          mode = mode & 4095 | 32768;\n        } else {\n          mode = 0;\n        }\n\n        var node;\n\n        if (typeof path === \"object\") {\n          node = path;\n        } else {\n          path = PATH.normalize(path);\n\n          try {\n            var lookup = FS.lookupPath(path, {\n              follow: !(flags & 131072)\n            });\n            node = lookup.node;\n          } catch (e) {}\n        }\n\n        var created = false;\n\n        if (flags & 64) {\n          if (node) {\n            if (flags & 128) {\n              throw new FS.ErrnoError(17);\n            }\n          } else {\n            node = FS.mknod(path, mode, 0);\n            created = true;\n          }\n        }\n\n        if (!node) {\n          throw new FS.ErrnoError(2);\n        }\n\n        if (FS.isChrdev(node.mode)) {\n          flags &= ~512;\n        }\n\n        if (flags & 65536 && !FS.isDir(node.mode)) {\n          throw new FS.ErrnoError(20);\n        }\n\n        if (!created) {\n          var err = FS.mayOpen(node, flags);\n\n          if (err) {\n            throw new FS.ErrnoError(err);\n          }\n        }\n\n        if (flags & 512) {\n          FS.truncate(node, 0);\n        }\n\n        flags &= ~(128 | 512);\n        var stream = FS.createStream({\n          node: node,\n          path: FS.getPath(node),\n          flags: flags,\n          seekable: true,\n          position: 0,\n          stream_ops: node.stream_ops,\n          ungotten: [],\n          error: false\n        }, fd_start, fd_end);\n\n        if (stream.stream_ops.open) {\n          stream.stream_ops.open(stream);\n        }\n\n        if (Module[\"logReadFiles\"] && !(flags & 1)) {\n          if (!FS.readFiles) FS.readFiles = {};\n\n          if (!(path in FS.readFiles)) {\n            FS.readFiles[path] = 1;\n            console.log(\"FS.trackingDelegate error on read file: \" + path);\n          }\n        }\n\n        try {\n          if (FS.trackingDelegate[\"onOpenFile\"]) {\n            var trackingFlags = 0;\n\n            if ((flags & 2097155) !== 1) {\n              trackingFlags |= FS.tracking.openFlags.READ;\n            }\n\n            if ((flags & 2097155) !== 0) {\n              trackingFlags |= FS.tracking.openFlags.WRITE;\n            }\n\n            FS.trackingDelegate[\"onOpenFile\"](path, trackingFlags);\n          }\n        } catch (e) {\n          console.log(\"FS.trackingDelegate['onOpenFile']('\" + path + \"', flags) threw an exception: \" + e.message);\n        }\n\n        return stream;\n      },\n      close: function (stream) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(9);\n        }\n\n        if (stream.getdents) stream.getdents = null;\n\n        try {\n          if (stream.stream_ops.close) {\n            stream.stream_ops.close(stream);\n          }\n        } catch (e) {\n          throw e;\n        } finally {\n          FS.closeStream(stream.fd);\n        }\n\n        stream.fd = null;\n      },\n      isClosed: function (stream) {\n        return stream.fd === null;\n      },\n      llseek: function (stream, offset, whence) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(9);\n        }\n\n        if (!stream.seekable || !stream.stream_ops.llseek) {\n          throw new FS.ErrnoError(29);\n        }\n\n        if (whence != 0 && whence != 1 && whence != 2) {\n          throw new FS.ErrnoError(22);\n        }\n\n        stream.position = stream.stream_ops.llseek(stream, offset, whence);\n        stream.ungotten = [];\n        return stream.position;\n      },\n      read: function (stream, buffer, offset, length, position) {\n        if (length < 0 || position < 0) {\n          throw new FS.ErrnoError(22);\n        }\n\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(9);\n        }\n\n        if ((stream.flags & 2097155) === 1) {\n          throw new FS.ErrnoError(9);\n        }\n\n        if (FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(21);\n        }\n\n        if (!stream.stream_ops.read) {\n          throw new FS.ErrnoError(22);\n        }\n\n        var seeking = typeof position !== \"undefined\";\n\n        if (!seeking) {\n          position = stream.position;\n        } else if (!stream.seekable) {\n          throw new FS.ErrnoError(29);\n        }\n\n        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);\n        if (!seeking) stream.position += bytesRead;\n        return bytesRead;\n      },\n      write: function (stream, buffer, offset, length, position, canOwn) {\n        if (length < 0 || position < 0) {\n          throw new FS.ErrnoError(22);\n        }\n\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(9);\n        }\n\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(9);\n        }\n\n        if (FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(21);\n        }\n\n        if (!stream.stream_ops.write) {\n          throw new FS.ErrnoError(22);\n        }\n\n        if (stream.flags & 1024) {\n          FS.llseek(stream, 0, 2);\n        }\n\n        var seeking = typeof position !== \"undefined\";\n\n        if (!seeking) {\n          position = stream.position;\n        } else if (!stream.seekable) {\n          throw new FS.ErrnoError(29);\n        }\n\n        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);\n        if (!seeking) stream.position += bytesWritten;\n\n        try {\n          if (stream.path && FS.trackingDelegate[\"onWriteToFile\"]) FS.trackingDelegate[\"onWriteToFile\"](stream.path);\n        } catch (e) {\n          console.log(\"FS.trackingDelegate['onWriteToFile']('\" + stream.path + \"') threw an exception: \" + e.message);\n        }\n\n        return bytesWritten;\n      },\n      allocate: function (stream, offset, length) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(9);\n        }\n\n        if (offset < 0 || length <= 0) {\n          throw new FS.ErrnoError(22);\n        }\n\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(9);\n        }\n\n        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(19);\n        }\n\n        if (!stream.stream_ops.allocate) {\n          throw new FS.ErrnoError(95);\n        }\n\n        stream.stream_ops.allocate(stream, offset, length);\n      },\n      mmap: function (stream, buffer, offset, length, position, prot, flags) {\n        if ((stream.flags & 2097155) === 1) {\n          throw new FS.ErrnoError(13);\n        }\n\n        if (!stream.stream_ops.mmap) {\n          throw new FS.ErrnoError(19);\n        }\n\n        return stream.stream_ops.mmap(stream, buffer, offset, length, position, prot, flags);\n      },\n      msync: function (stream, buffer, offset, length, mmapFlags) {\n        if (!stream || !stream.stream_ops.msync) {\n          return 0;\n        }\n\n        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);\n      },\n      munmap: function (stream) {\n        return 0;\n      },\n      ioctl: function (stream, cmd, arg) {\n        if (!stream.stream_ops.ioctl) {\n          throw new FS.ErrnoError(25);\n        }\n\n        return stream.stream_ops.ioctl(stream, cmd, arg);\n      },\n      readFile: function (path, opts) {\n        opts = opts || {};\n        opts.flags = opts.flags || \"r\";\n        opts.encoding = opts.encoding || \"binary\";\n\n        if (opts.encoding !== \"utf8\" && opts.encoding !== \"binary\") {\n          throw new Error('Invalid encoding type \"' + opts.encoding + '\"');\n        }\n\n        var ret;\n        var stream = FS.open(path, opts.flags);\n        var stat = FS.stat(path);\n        var length = stat.size;\n        var buf = new Uint8Array(length);\n        FS.read(stream, buf, 0, length, 0);\n\n        if (opts.encoding === \"utf8\") {\n          ret = UTF8ArrayToString(buf, 0);\n        } else if (opts.encoding === \"binary\") {\n          ret = buf;\n        }\n\n        FS.close(stream);\n        return ret;\n      },\n      writeFile: function (path, data, opts) {\n        opts = opts || {};\n        opts.flags = opts.flags || \"w\";\n        var stream = FS.open(path, opts.flags, opts.mode);\n\n        if (typeof data === \"string\") {\n          var buf = new Uint8Array(lengthBytesUTF8(data) + 1);\n          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\n          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);\n        } else if (ArrayBuffer.isView(data)) {\n          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);\n        } else {\n          throw new Error(\"Unsupported data type\");\n        }\n\n        FS.close(stream);\n      },\n      cwd: function () {\n        return FS.currentPath;\n      },\n      chdir: function (path) {\n        var lookup = FS.lookupPath(path, {\n          follow: true\n        });\n\n        if (lookup.node === null) {\n          throw new FS.ErrnoError(2);\n        }\n\n        if (!FS.isDir(lookup.node.mode)) {\n          throw new FS.ErrnoError(20);\n        }\n\n        var err = FS.nodePermissions(lookup.node, \"x\");\n\n        if (err) {\n          throw new FS.ErrnoError(err);\n        }\n\n        FS.currentPath = lookup.path;\n      },\n      createDefaultDirectories: function () {\n        FS.mkdir(\"/tmp\");\n        FS.mkdir(\"/home\");\n        FS.mkdir(\"/home/web_user\");\n      },\n      createDefaultDevices: function () {\n        FS.mkdir(\"/dev\");\n        FS.registerDevice(FS.makedev(1, 3), {\n          read: function () {\n            return 0;\n          },\n          write: function (stream, buffer, offset, length, pos) {\n            return length;\n          }\n        });\n        FS.mkdev(\"/dev/null\", FS.makedev(1, 3));\n        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\n        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\n        FS.mkdev(\"/dev/tty\", FS.makedev(5, 0));\n        FS.mkdev(\"/dev/tty1\", FS.makedev(6, 0));\n        var random_device;\n\n        if (typeof crypto === \"object\" && typeof crypto[\"getRandomValues\"] === \"function\") {\n          var randomBuffer = new Uint8Array(1);\n\n          random_device = function () {\n            crypto.getRandomValues(randomBuffer);\n            return randomBuffer[0];\n          };\n        } else if (ENVIRONMENT_IS_NODE) {\n          try {\n            var crypto_module = require(\"crypto\");\n\n            random_device = function () {\n              return crypto_module[\"randomBytes\"](1)[0];\n            };\n          } catch (e) {}\n        } else {}\n\n        if (!random_device) {\n          random_device = function () {\n            abort(\"random_device\");\n          };\n        }\n\n        FS.createDevice(\"/dev\", \"random\", random_device);\n        FS.createDevice(\"/dev\", \"urandom\", random_device);\n        FS.mkdir(\"/dev/shm\");\n        FS.mkdir(\"/dev/shm/tmp\");\n      },\n      createSpecialDirectories: function () {\n        FS.mkdir(\"/proc\");\n        FS.mkdir(\"/proc/self\");\n        FS.mkdir(\"/proc/self/fd\");\n        FS.mount({\n          mount: function () {\n            var node = FS.createNode(\"/proc/self\", \"fd\", 16384 | 511, 73);\n            node.node_ops = {\n              lookup: function (parent, name) {\n                var fd = +name;\n                var stream = FS.getStream(fd);\n                if (!stream) throw new FS.ErrnoError(9);\n                var ret = {\n                  parent: null,\n                  mount: {\n                    mountpoint: \"fake\"\n                  },\n                  node_ops: {\n                    readlink: function () {\n                      return stream.path;\n                    }\n                  }\n                };\n                ret.parent = ret;\n                return ret;\n              }\n            };\n            return node;\n          }\n        }, {}, \"/proc/self/fd\");\n      },\n      createStandardStreams: function () {\n        if (Module[\"stdin\"]) {\n          FS.createDevice(\"/dev\", \"stdin\", Module[\"stdin\"]);\n        } else {\n          FS.symlink(\"/dev/tty\", \"/dev/stdin\");\n        }\n\n        if (Module[\"stdout\"]) {\n          FS.createDevice(\"/dev\", \"stdout\", null, Module[\"stdout\"]);\n        } else {\n          FS.symlink(\"/dev/tty\", \"/dev/stdout\");\n        }\n\n        if (Module[\"stderr\"]) {\n          FS.createDevice(\"/dev\", \"stderr\", null, Module[\"stderr\"]);\n        } else {\n          FS.symlink(\"/dev/tty1\", \"/dev/stderr\");\n        }\n\n        var stdin = FS.open(\"/dev/stdin\", \"r\");\n        var stdout = FS.open(\"/dev/stdout\", \"w\");\n        var stderr = FS.open(\"/dev/stderr\", \"w\");\n      },\n      ensureErrnoError: function () {\n        if (FS.ErrnoError) return;\n\n        FS.ErrnoError = function ErrnoError(errno, node) {\n          this.node = node;\n\n          this.setErrno = function (errno) {\n            this.errno = errno;\n          };\n\n          this.setErrno(errno);\n          this.message = \"FS error\";\n          if (this.stack) Object.defineProperty(this, \"stack\", {\n            value: new Error().stack,\n            writable: true\n          });\n        };\n\n        FS.ErrnoError.prototype = new Error();\n        FS.ErrnoError.prototype.constructor = FS.ErrnoError;\n        [2].forEach(function (code) {\n          FS.genericErrors[code] = new FS.ErrnoError(code);\n          FS.genericErrors[code].stack = \"<generic error, no stack>\";\n        });\n      },\n      staticInit: function () {\n        FS.ensureErrnoError();\n        FS.nameTable = new Array(4096);\n        FS.mount(MEMFS, {}, \"/\");\n        FS.createDefaultDirectories();\n        FS.createDefaultDevices();\n        FS.createSpecialDirectories();\n        FS.filesystems = {\n          \"MEMFS\": MEMFS,\n          \"IDBFS\": IDBFS,\n          \"NODEFS\": NODEFS,\n          \"WORKERFS\": WORKERFS\n        };\n      },\n      init: function (input, output, error) {\n        FS.init.initialized = true;\n        FS.ensureErrnoError();\n        Module[\"stdin\"] = input || Module[\"stdin\"];\n        Module[\"stdout\"] = output || Module[\"stdout\"];\n        Module[\"stderr\"] = error || Module[\"stderr\"];\n        FS.createStandardStreams();\n      },\n      quit: function () {\n        FS.init.initialized = false;\n        var fflush = Module[\"_fflush\"];\n        if (fflush) fflush(0);\n\n        for (var i = 0; i < FS.streams.length; i++) {\n          var stream = FS.streams[i];\n\n          if (!stream) {\n            continue;\n          }\n\n          FS.close(stream);\n        }\n      },\n      getMode: function (canRead, canWrite) {\n        var mode = 0;\n        if (canRead) mode |= 292 | 73;\n        if (canWrite) mode |= 146;\n        return mode;\n      },\n      joinPath: function (parts, forceRelative) {\n        var path = PATH.join.apply(null, parts);\n        if (forceRelative && path[0] == \"/\") path = path.substr(1);\n        return path;\n      },\n      absolutePath: function (relative, base) {\n        return PATH.resolve(base, relative);\n      },\n      standardizePath: function (path) {\n        return PATH.normalize(path);\n      },\n      findObject: function (path, dontResolveLastLink) {\n        var ret = FS.analyzePath(path, dontResolveLastLink);\n\n        if (ret.exists) {\n          return ret.object;\n        } else {\n          ___setErrNo(ret.error);\n\n          return null;\n        }\n      },\n      analyzePath: function (path, dontResolveLastLink) {\n        try {\n          var lookup = FS.lookupPath(path, {\n            follow: !dontResolveLastLink\n          });\n          path = lookup.path;\n        } catch (e) {}\n\n        var ret = {\n          isRoot: false,\n          exists: false,\n          error: 0,\n          name: null,\n          path: null,\n          object: null,\n          parentExists: false,\n          parentPath: null,\n          parentObject: null\n        };\n\n        try {\n          var lookup = FS.lookupPath(path, {\n            parent: true\n          });\n          ret.parentExists = true;\n          ret.parentPath = lookup.path;\n          ret.parentObject = lookup.node;\n          ret.name = PATH.basename(path);\n          lookup = FS.lookupPath(path, {\n            follow: !dontResolveLastLink\n          });\n          ret.exists = true;\n          ret.path = lookup.path;\n          ret.object = lookup.node;\n          ret.name = lookup.node.name;\n          ret.isRoot = lookup.path === \"/\";\n        } catch (e) {\n          ret.error = e.errno;\n        }\n\n        return ret;\n      },\n      createFolder: function (parent, name, canRead, canWrite) {\n        var path = PATH.join2(typeof parent === \"string\" ? parent : FS.getPath(parent), name);\n        var mode = FS.getMode(canRead, canWrite);\n        return FS.mkdir(path, mode);\n      },\n      createPath: function (parent, path, canRead, canWrite) {\n        parent = typeof parent === \"string\" ? parent : FS.getPath(parent);\n        var parts = path.split(\"/\").reverse();\n\n        while (parts.length) {\n          var part = parts.pop();\n          if (!part) continue;\n          var current = PATH.join2(parent, part);\n\n          try {\n            FS.mkdir(current);\n          } catch (e) {}\n\n          parent = current;\n        }\n\n        return current;\n      },\n      createFile: function (parent, name, properties, canRead, canWrite) {\n        var path = PATH.join2(typeof parent === \"string\" ? parent : FS.getPath(parent), name);\n        var mode = FS.getMode(canRead, canWrite);\n        return FS.create(path, mode);\n      },\n      createDataFile: function (parent, name, data, canRead, canWrite, canOwn) {\n        var path = name ? PATH.join2(typeof parent === \"string\" ? parent : FS.getPath(parent), name) : parent;\n        var mode = FS.getMode(canRead, canWrite);\n        var node = FS.create(path, mode);\n\n        if (data) {\n          if (typeof data === \"string\") {\n            var arr = new Array(data.length);\n\n            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);\n\n            data = arr;\n          }\n\n          FS.chmod(node, mode | 146);\n          var stream = FS.open(node, \"w\");\n          FS.write(stream, data, 0, data.length, 0, canOwn);\n          FS.close(stream);\n          FS.chmod(node, mode);\n        }\n\n        return node;\n      },\n      createDevice: function (parent, name, input, output) {\n        var path = PATH.join2(typeof parent === \"string\" ? parent : FS.getPath(parent), name);\n        var mode = FS.getMode(!!input, !!output);\n        if (!FS.createDevice.major) FS.createDevice.major = 64;\n        var dev = FS.makedev(FS.createDevice.major++, 0);\n        FS.registerDevice(dev, {\n          open: function (stream) {\n            stream.seekable = false;\n          },\n          close: function (stream) {\n            if (output && output.buffer && output.buffer.length) {\n              output(10);\n            }\n          },\n          read: function (stream, buffer, offset, length, pos) {\n            var bytesRead = 0;\n\n            for (var i = 0; i < length; i++) {\n              var result;\n\n              try {\n                result = input();\n              } catch (e) {\n                throw new FS.ErrnoError(5);\n              }\n\n              if (result === undefined && bytesRead === 0) {\n                throw new FS.ErrnoError(11);\n              }\n\n              if (result === null || result === undefined) break;\n              bytesRead++;\n              buffer[offset + i] = result;\n            }\n\n            if (bytesRead) {\n              stream.node.timestamp = Date.now();\n            }\n\n            return bytesRead;\n          },\n          write: function (stream, buffer, offset, length, pos) {\n            for (var i = 0; i < length; i++) {\n              try {\n                output(buffer[offset + i]);\n              } catch (e) {\n                throw new FS.ErrnoError(5);\n              }\n            }\n\n            if (length) {\n              stream.node.timestamp = Date.now();\n            }\n\n            return i;\n          }\n        });\n        return FS.mkdev(path, mode, dev);\n      },\n      createLink: function (parent, name, target, canRead, canWrite) {\n        var path = PATH.join2(typeof parent === \"string\" ? parent : FS.getPath(parent), name);\n        return FS.symlink(target, path);\n      },\n      forceLoadFile: function (obj) {\n        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;\n        var success = true;\n\n        if (typeof XMLHttpRequest !== \"undefined\") {\n          throw new Error(\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\");\n        } else if (Module[\"read\"]) {\n          try {\n            obj.contents = intArrayFromString(Module[\"read\"](obj.url), true);\n            obj.usedBytes = obj.contents.length;\n          } catch (e) {\n            success = false;\n          }\n        } else {\n          throw new Error(\"Cannot load without read() or XMLHttpRequest.\");\n        }\n\n        if (!success) ___setErrNo(5);\n        return success;\n      },\n      createLazyFile: function (parent, name, url, canRead, canWrite) {\n        function LazyUint8Array() {\n          this.lengthKnown = false;\n          this.chunks = [];\n        }\n\n        LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {\n          if (idx > this.length - 1 || idx < 0) {\n            return undefined;\n          }\n\n          var chunkOffset = idx % this.chunkSize;\n          var chunkNum = idx / this.chunkSize | 0;\n          return this.getter(chunkNum)[chunkOffset];\n        };\n\n        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {\n          this.getter = getter;\n        };\n\n        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {\n          var xhr = new XMLHttpRequest();\n          xhr.open(\"HEAD\", url, false);\n          xhr.send(null);\n          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n          var datalength = Number(xhr.getResponseHeader(\"Content-length\"));\n          var header;\n          var hasByteServing = (header = xhr.getResponseHeader(\"Accept-Ranges\")) && header === \"bytes\";\n          var usesGzip = (header = xhr.getResponseHeader(\"Content-Encoding\")) && header === \"gzip\";\n          var chunkSize = 1024 * 1024;\n          if (!hasByteServing) chunkSize = datalength;\n\n          var doXHR = function (from, to) {\n            if (from > to) throw new Error(\"invalid range (\" + from + \", \" + to + \") or no bytes requested!\");\n            if (to > datalength - 1) throw new Error(\"only \" + datalength + \" bytes available! programmer error!\");\n            var xhr = new XMLHttpRequest();\n            xhr.open(\"GET\", url, false);\n            if (datalength !== chunkSize) xhr.setRequestHeader(\"Range\", \"bytes=\" + from + \"-\" + to);\n            if (typeof Uint8Array != \"undefined\") xhr.responseType = \"arraybuffer\";\n\n            if (xhr.overrideMimeType) {\n              xhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\n            }\n\n            xhr.send(null);\n            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n\n            if (xhr.response !== undefined) {\n              return new Uint8Array(xhr.response || []);\n            } else {\n              return intArrayFromString(xhr.responseText || \"\", true);\n            }\n          };\n\n          var lazyArray = this;\n          lazyArray.setDataGetter(function (chunkNum) {\n            var start = chunkNum * chunkSize;\n            var end = (chunkNum + 1) * chunkSize - 1;\n            end = Math.min(end, datalength - 1);\n\n            if (typeof lazyArray.chunks[chunkNum] === \"undefined\") {\n              lazyArray.chunks[chunkNum] = doXHR(start, end);\n            }\n\n            if (typeof lazyArray.chunks[chunkNum] === \"undefined\") throw new Error(\"doXHR failed!\");\n            return lazyArray.chunks[chunkNum];\n          });\n\n          if (usesGzip || !datalength) {\n            chunkSize = datalength = 1;\n            datalength = this.getter(0).length;\n            chunkSize = datalength;\n            console.log(\"LazyFiles on gzip forces download of the whole file when length is accessed\");\n          }\n\n          this._length = datalength;\n          this._chunkSize = chunkSize;\n          this.lengthKnown = true;\n        };\n\n        if (typeof XMLHttpRequest !== \"undefined\") {\n          if (!ENVIRONMENT_IS_WORKER) throw \"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc\";\n          var lazyArray = new LazyUint8Array();\n          Object.defineProperties(lazyArray, {\n            length: {\n              get: function () {\n                if (!this.lengthKnown) {\n                  this.cacheLength();\n                }\n\n                return this._length;\n              }\n            },\n            chunkSize: {\n              get: function () {\n                if (!this.lengthKnown) {\n                  this.cacheLength();\n                }\n\n                return this._chunkSize;\n              }\n            }\n          });\n          var properties = {\n            isDevice: false,\n            contents: lazyArray\n          };\n        } else {\n          var properties = {\n            isDevice: false,\n            url: url\n          };\n        }\n\n        var node = FS.createFile(parent, name, properties, canRead, canWrite);\n\n        if (properties.contents) {\n          node.contents = properties.contents;\n        } else if (properties.url) {\n          node.contents = null;\n          node.url = properties.url;\n        }\n\n        Object.defineProperties(node, {\n          usedBytes: {\n            get: function () {\n              return this.contents.length;\n            }\n          }\n        });\n        var stream_ops = {};\n        var keys = Object.keys(node.stream_ops);\n        keys.forEach(function (key) {\n          var fn = node.stream_ops[key];\n\n          stream_ops[key] = function forceLoadLazyFile() {\n            if (!FS.forceLoadFile(node)) {\n              throw new FS.ErrnoError(5);\n            }\n\n            return fn.apply(null, arguments);\n          };\n        });\n\n        stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) {\n          if (!FS.forceLoadFile(node)) {\n            throw new FS.ErrnoError(5);\n          }\n\n          var contents = stream.node.contents;\n          if (position >= contents.length) return 0;\n          var size = Math.min(contents.length - position, length);\n\n          if (contents.slice) {\n            for (var i = 0; i < size; i++) {\n              buffer[offset + i] = contents[position + i];\n            }\n          } else {\n            for (var i = 0; i < size; i++) {\n              buffer[offset + i] = contents.get(position + i);\n            }\n          }\n\n          return size;\n        };\n\n        node.stream_ops = stream_ops;\n        return node;\n      },\n      createPreloadedFile: function (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {\n        Browser.init();\n        var fullname = name ? PATH.resolve(PATH.join2(parent, name)) : parent;\n        var dep = getUniqueRunDependency(\"cp \" + fullname);\n\n        function processData(byteArray) {\n          function finish(byteArray) {\n            if (preFinish) preFinish();\n\n            if (!dontCreateFile) {\n              FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);\n            }\n\n            if (onload) onload();\n            removeRunDependency(dep);\n          }\n\n          var handled = false;\n          Module[\"preloadPlugins\"].forEach(function (plugin) {\n            if (handled) return;\n\n            if (plugin[\"canHandle\"](fullname)) {\n              plugin[\"handle\"](byteArray, fullname, finish, function () {\n                if (onerror) onerror();\n                removeRunDependency(dep);\n              });\n              handled = true;\n            }\n          });\n          if (!handled) finish(byteArray);\n        }\n\n        addRunDependency(dep);\n\n        if (typeof url == \"string\") {\n          Browser.asyncLoad(url, function (byteArray) {\n            processData(byteArray);\n          }, onerror);\n        } else {\n          processData(url);\n        }\n      },\n      indexedDB: function () {\n        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\n      },\n      DB_NAME: function () {\n        return \"EM_FS_\" + window.location.pathname;\n      },\n      DB_VERSION: 20,\n      DB_STORE_NAME: \"FILE_DATA\",\n      saveFilesToDB: function (paths, onload, onerror) {\n        onload = onload || function () {};\n\n        onerror = onerror || function () {};\n\n        var indexedDB = FS.indexedDB();\n\n        try {\n          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);\n        } catch (e) {\n          return onerror(e);\n        }\n\n        openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {\n          console.log(\"creating db\");\n          var db = openRequest.result;\n          db.createObjectStore(FS.DB_STORE_NAME);\n        };\n\n        openRequest.onsuccess = function openRequest_onsuccess() {\n          var db = openRequest.result;\n          var transaction = db.transaction([FS.DB_STORE_NAME], \"readwrite\");\n          var files = transaction.objectStore(FS.DB_STORE_NAME);\n          var ok = 0,\n              fail = 0,\n              total = paths.length;\n\n          function finish() {\n            if (fail == 0) onload();else onerror();\n          }\n\n          paths.forEach(function (path) {\n            var putRequest = files.put(FS.analyzePath(path).object.contents, path);\n\n            putRequest.onsuccess = function putRequest_onsuccess() {\n              ok++;\n              if (ok + fail == total) finish();\n            };\n\n            putRequest.onerror = function putRequest_onerror() {\n              fail++;\n              if (ok + fail == total) finish();\n            };\n          });\n          transaction.onerror = onerror;\n        };\n\n        openRequest.onerror = onerror;\n      },\n      loadFilesFromDB: function (paths, onload, onerror) {\n        onload = onload || function () {};\n\n        onerror = onerror || function () {};\n\n        var indexedDB = FS.indexedDB();\n\n        try {\n          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);\n        } catch (e) {\n          return onerror(e);\n        }\n\n        openRequest.onupgradeneeded = onerror;\n\n        openRequest.onsuccess = function openRequest_onsuccess() {\n          var db = openRequest.result;\n\n          try {\n            var transaction = db.transaction([FS.DB_STORE_NAME], \"readonly\");\n          } catch (e) {\n            onerror(e);\n            return;\n          }\n\n          var files = transaction.objectStore(FS.DB_STORE_NAME);\n          var ok = 0,\n              fail = 0,\n              total = paths.length;\n\n          function finish() {\n            if (fail == 0) onload();else onerror();\n          }\n\n          paths.forEach(function (path) {\n            var getRequest = files.get(path);\n\n            getRequest.onsuccess = function getRequest_onsuccess() {\n              if (FS.analyzePath(path).exists) {\n                FS.unlink(path);\n              }\n\n              FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);\n              ok++;\n              if (ok + fail == total) finish();\n            };\n\n            getRequest.onerror = function getRequest_onerror() {\n              fail++;\n              if (ok + fail == total) finish();\n            };\n          });\n          transaction.onerror = onerror;\n        };\n\n        openRequest.onerror = onerror;\n      }\n    };\n    var ERRNO_CODES = {\n      EPERM: 1,\n      ENOENT: 2,\n      ESRCH: 3,\n      EINTR: 4,\n      EIO: 5,\n      ENXIO: 6,\n      E2BIG: 7,\n      ENOEXEC: 8,\n      EBADF: 9,\n      ECHILD: 10,\n      EAGAIN: 11,\n      EWOULDBLOCK: 11,\n      ENOMEM: 12,\n      EACCES: 13,\n      EFAULT: 14,\n      ENOTBLK: 15,\n      EBUSY: 16,\n      EEXIST: 17,\n      EXDEV: 18,\n      ENODEV: 19,\n      ENOTDIR: 20,\n      EISDIR: 21,\n      EINVAL: 22,\n      ENFILE: 23,\n      EMFILE: 24,\n      ENOTTY: 25,\n      ETXTBSY: 26,\n      EFBIG: 27,\n      ENOSPC: 28,\n      ESPIPE: 29,\n      EROFS: 30,\n      EMLINK: 31,\n      EPIPE: 32,\n      EDOM: 33,\n      ERANGE: 34,\n      ENOMSG: 42,\n      EIDRM: 43,\n      ECHRNG: 44,\n      EL2NSYNC: 45,\n      EL3HLT: 46,\n      EL3RST: 47,\n      ELNRNG: 48,\n      EUNATCH: 49,\n      ENOCSI: 50,\n      EL2HLT: 51,\n      EDEADLK: 35,\n      ENOLCK: 37,\n      EBADE: 52,\n      EBADR: 53,\n      EXFULL: 54,\n      ENOANO: 55,\n      EBADRQC: 56,\n      EBADSLT: 57,\n      EDEADLOCK: 35,\n      EBFONT: 59,\n      ENOSTR: 60,\n      ENODATA: 61,\n      ETIME: 62,\n      ENOSR: 63,\n      ENONET: 64,\n      ENOPKG: 65,\n      EREMOTE: 66,\n      ENOLINK: 67,\n      EADV: 68,\n      ESRMNT: 69,\n      ECOMM: 70,\n      EPROTO: 71,\n      EMULTIHOP: 72,\n      EDOTDOT: 73,\n      EBADMSG: 74,\n      ENOTUNIQ: 76,\n      EBADFD: 77,\n      EREMCHG: 78,\n      ELIBACC: 79,\n      ELIBBAD: 80,\n      ELIBSCN: 81,\n      ELIBMAX: 82,\n      ELIBEXEC: 83,\n      ENOSYS: 38,\n      ENOTEMPTY: 39,\n      ENAMETOOLONG: 36,\n      ELOOP: 40,\n      EOPNOTSUPP: 95,\n      EPFNOSUPPORT: 96,\n      ECONNRESET: 104,\n      ENOBUFS: 105,\n      EAFNOSUPPORT: 97,\n      EPROTOTYPE: 91,\n      ENOTSOCK: 88,\n      ENOPROTOOPT: 92,\n      ESHUTDOWN: 108,\n      ECONNREFUSED: 111,\n      EADDRINUSE: 98,\n      ECONNABORTED: 103,\n      ENETUNREACH: 101,\n      ENETDOWN: 100,\n      ETIMEDOUT: 110,\n      EHOSTDOWN: 112,\n      EHOSTUNREACH: 113,\n      EINPROGRESS: 115,\n      EALREADY: 114,\n      EDESTADDRREQ: 89,\n      EMSGSIZE: 90,\n      EPROTONOSUPPORT: 93,\n      ESOCKTNOSUPPORT: 94,\n      EADDRNOTAVAIL: 99,\n      ENETRESET: 102,\n      EISCONN: 106,\n      ENOTCONN: 107,\n      ETOOMANYREFS: 109,\n      EUSERS: 87,\n      EDQUOT: 122,\n      ESTALE: 116,\n      ENOTSUP: 95,\n      ENOMEDIUM: 123,\n      EILSEQ: 84,\n      EOVERFLOW: 75,\n      ECANCELED: 125,\n      ENOTRECOVERABLE: 131,\n      EOWNERDEAD: 130,\n      ESTRPIPE: 86\n    };\n    var SYSCALLS = {\n      DEFAULT_POLLMASK: 5,\n      mappings: {},\n      umask: 511,\n      calculateAt: function (dirfd, path) {\n        if (path[0] !== \"/\") {\n          var dir;\n\n          if (dirfd === -100) {\n            dir = FS.cwd();\n          } else {\n            var dirstream = FS.getStream(dirfd);\n            if (!dirstream) throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n            dir = dirstream.path;\n          }\n\n          path = PATH.join2(dir, path);\n        }\n\n        return path;\n      },\n      doStat: function (func, path, buf) {\n        try {\n          var stat = func(path);\n        } catch (e) {\n          if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {\n            return -ERRNO_CODES.ENOTDIR;\n          }\n\n          throw e;\n        }\n\n        HEAP32[buf >> 2] = stat.dev;\n        HEAP32[buf + 4 >> 2] = 0;\n        HEAP32[buf + 8 >> 2] = stat.ino;\n        HEAP32[buf + 12 >> 2] = stat.mode;\n        HEAP32[buf + 16 >> 2] = stat.nlink;\n        HEAP32[buf + 20 >> 2] = stat.uid;\n        HEAP32[buf + 24 >> 2] = stat.gid;\n        HEAP32[buf + 28 >> 2] = stat.rdev;\n        HEAP32[buf + 32 >> 2] = 0;\n        HEAP32[buf + 36 >> 2] = stat.size;\n        HEAP32[buf + 40 >> 2] = 4096;\n        HEAP32[buf + 44 >> 2] = stat.blocks;\n        HEAP32[buf + 48 >> 2] = stat.atime.getTime() / 1e3 | 0;\n        HEAP32[buf + 52 >> 2] = 0;\n        HEAP32[buf + 56 >> 2] = stat.mtime.getTime() / 1e3 | 0;\n        HEAP32[buf + 60 >> 2] = 0;\n        HEAP32[buf + 64 >> 2] = stat.ctime.getTime() / 1e3 | 0;\n        HEAP32[buf + 68 >> 2] = 0;\n        HEAP32[buf + 72 >> 2] = stat.ino;\n        return 0;\n      },\n      doMsync: function (addr, stream, len, flags) {\n        var buffer = new Uint8Array(HEAPU8.subarray(addr, addr + len));\n        FS.msync(stream, buffer, 0, len, flags);\n      },\n      doMkdir: function (path, mode) {\n        path = PATH.normalize(path);\n        if (path[path.length - 1] === \"/\") path = path.substr(0, path.length - 1);\n        FS.mkdir(path, mode, 0);\n        return 0;\n      },\n      doMknod: function (path, mode, dev) {\n        switch (mode & 61440) {\n          case 32768:\n          case 8192:\n          case 24576:\n          case 4096:\n          case 49152:\n            break;\n\n          default:\n            return -ERRNO_CODES.EINVAL;\n        }\n\n        FS.mknod(path, mode, dev);\n        return 0;\n      },\n      doReadlink: function (path, buf, bufsize) {\n        if (bufsize <= 0) return -ERRNO_CODES.EINVAL;\n        var ret = FS.readlink(path);\n        var len = Math.min(bufsize, lengthBytesUTF8(ret));\n        var endChar = HEAP8[buf + len];\n        stringToUTF8(ret, buf, bufsize + 1);\n        HEAP8[buf + len] = endChar;\n        return len;\n      },\n      doAccess: function (path, amode) {\n        if (amode & ~7) {\n          return -ERRNO_CODES.EINVAL;\n        }\n\n        var node;\n        var lookup = FS.lookupPath(path, {\n          follow: true\n        });\n        node = lookup.node;\n        var perms = \"\";\n        if (amode & 4) perms += \"r\";\n        if (amode & 2) perms += \"w\";\n        if (amode & 1) perms += \"x\";\n\n        if (perms && FS.nodePermissions(node, perms)) {\n          return -ERRNO_CODES.EACCES;\n        }\n\n        return 0;\n      },\n      doDup: function (path, flags, suggestFD) {\n        var suggest = FS.getStream(suggestFD);\n        if (suggest) FS.close(suggest);\n        return FS.open(path, flags, 0, suggestFD, suggestFD).fd;\n      },\n      doReadv: function (stream, iov, iovcnt, offset) {\n        var ret = 0;\n\n        for (var i = 0; i < iovcnt; i++) {\n          var ptr = HEAP32[iov + i * 8 >> 2];\n          var len = HEAP32[iov + (i * 8 + 4) >> 2];\n          var curr = FS.read(stream, HEAP8, ptr, len, offset);\n          if (curr < 0) return -1;\n          ret += curr;\n          if (curr < len) break;\n        }\n\n        return ret;\n      },\n      doWritev: function (stream, iov, iovcnt, offset) {\n        var ret = 0;\n\n        for (var i = 0; i < iovcnt; i++) {\n          var ptr = HEAP32[iov + i * 8 >> 2];\n          var len = HEAP32[iov + (i * 8 + 4) >> 2];\n          var curr = FS.write(stream, HEAP8, ptr, len, offset);\n          if (curr < 0) return -1;\n          ret += curr;\n        }\n\n        return ret;\n      },\n      varargs: 0,\n      get: function (varargs) {\n        SYSCALLS.varargs += 4;\n        var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];\n        return ret;\n      },\n      getStr: function () {\n        var ret = UTF8ToString(SYSCALLS.get());\n        return ret;\n      },\n      getStreamFromFD: function () {\n        var stream = FS.getStream(SYSCALLS.get());\n        if (!stream) throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n        return stream;\n      },\n      getSocketFromFD: function () {\n        var socket = SOCKFS.getSocket(SYSCALLS.get());\n        if (!socket) throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n        return socket;\n      },\n      getSocketAddress: function (allowNull) {\n        var addrp = SYSCALLS.get(),\n            addrlen = SYSCALLS.get();\n        if (allowNull && addrp === 0) return null;\n\n        var info = __read_sockaddr(addrp, addrlen);\n\n        if (info.errno) throw new FS.ErrnoError(info.errno);\n        info.addr = DNS.lookup_addr(info.addr) || info.addr;\n        return info;\n      },\n      get64: function () {\n        var low = SYSCALLS.get(),\n            high = SYSCALLS.get();\n        return low;\n      },\n      getZero: function () {\n        SYSCALLS.get();\n      }\n    };\n\n    function ___syscall140(which, varargs) {\n      SYSCALLS.varargs = varargs;\n\n      try {\n        var stream = SYSCALLS.getStreamFromFD(),\n            offset_high = SYSCALLS.get(),\n            offset_low = SYSCALLS.get(),\n            result = SYSCALLS.get(),\n            whence = SYSCALLS.get();\n        var offset = offset_low;\n        FS.llseek(stream, offset, whence);\n        HEAP32[result >> 2] = stream.position;\n        if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null;\n        return 0;\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\n        return -e.errno;\n      }\n    }\n\n    function ___syscall146(which, varargs) {\n      SYSCALLS.varargs = varargs;\n\n      try {\n        var stream = SYSCALLS.getStreamFromFD(),\n            iov = SYSCALLS.get(),\n            iovcnt = SYSCALLS.get();\n        return SYSCALLS.doWritev(stream, iov, iovcnt);\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\n        return -e.errno;\n      }\n    }\n\n    function ___syscall6(which, varargs) {\n      SYSCALLS.varargs = varargs;\n\n      try {\n        var stream = SYSCALLS.getStreamFromFD();\n        FS.close(stream);\n        return 0;\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\n        return -e.errno;\n      }\n    }\n\n    function ___syscall91(which, varargs) {\n      SYSCALLS.varargs = varargs;\n\n      try {\n        var addr = SYSCALLS.get(),\n            len = SYSCALLS.get();\n        var info = SYSCALLS.mappings[addr];\n        if (!info) return 0;\n\n        if (len === info.len) {\n          var stream = FS.getStream(info.fd);\n          SYSCALLS.doMsync(addr, stream, len, info.flags);\n          FS.munmap(stream);\n          SYSCALLS.mappings[addr] = null;\n\n          if (info.allocated) {\n            _free(info.malloc);\n          }\n        }\n\n        return 0;\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\n        return -e.errno;\n      }\n    }\n\n    function ___unlock() {}\n\n    function _abort() {\n      Module[\"abort\"]();\n    }\n\n    function _clock() {\n      if (_clock.start === undefined) _clock.start = Date.now();\n      return (Date.now() - _clock.start) * (1e6 / 1e3) | 0;\n    }\n\n    function _emscripten_get_heap_size() {\n      return TOTAL_MEMORY;\n    }\n\n    function abortOnCannotGrowMemory(requestedSize) {\n      abort(\"OOM\");\n    }\n\n    function emscripten_realloc_buffer(size) {\n      var PAGE_MULTIPLE = 65536;\n      size = alignUp(size, PAGE_MULTIPLE);\n      var old = Module[\"buffer\"];\n      var oldSize = old.byteLength;\n\n      try {\n        var result = wasmMemory.grow((size - oldSize) / 65536);\n\n        if (result !== (-1 | 0)) {\n          return Module[\"buffer\"] = wasmMemory.buffer;\n        } else {\n          return null;\n        }\n      } catch (e) {\n        return null;\n      }\n    }\n\n    function _emscripten_resize_heap(requestedSize) {\n      var oldSize = _emscripten_get_heap_size();\n\n      var PAGE_MULTIPLE = 65536;\n      var LIMIT = 2147483648 - PAGE_MULTIPLE;\n\n      if (requestedSize > LIMIT) {\n        return false;\n      }\n\n      var MIN_TOTAL_MEMORY = 16777216;\n      var newSize = Math.max(oldSize, MIN_TOTAL_MEMORY);\n\n      while (newSize < requestedSize) {\n        if (newSize <= 536870912) {\n          newSize = alignUp(2 * newSize, PAGE_MULTIPLE);\n        } else {\n          newSize = Math.min(alignUp((3 * newSize + 2147483648) / 4, PAGE_MULTIPLE), LIMIT);\n        }\n      }\n\n      var replacement = emscripten_realloc_buffer(newSize);\n\n      if (!replacement || replacement.byteLength != newSize) {\n        return false;\n      }\n\n      updateGlobalBuffer(replacement);\n      updateGlobalBufferViews();\n      TOTAL_MEMORY = newSize;\n      return true;\n    }\n\n    var ENV = {};\n\n    function _getenv(name) {\n      if (name === 0) return 0;\n      name = UTF8ToString(name);\n      if (!ENV.hasOwnProperty(name)) return 0;\n      if (_getenv.ret) _free(_getenv.ret);\n      _getenv.ret = allocateUTF8(ENV[name]);\n      return _getenv.ret;\n    }\n\n    function _llvm_stackrestore(p) {\n      var self = _llvm_stacksave;\n      var ret = self.LLVM_SAVEDSTACKS[p];\n      self.LLVM_SAVEDSTACKS.splice(p, 1);\n      stackRestore(ret);\n    }\n\n    function _llvm_stacksave() {\n      var self = _llvm_stacksave;\n\n      if (!self.LLVM_SAVEDSTACKS) {\n        self.LLVM_SAVEDSTACKS = [];\n      }\n\n      self.LLVM_SAVEDSTACKS.push(stackSave());\n      return self.LLVM_SAVEDSTACKS.length - 1;\n    }\n\n    function _llvm_trap() {\n      abort(\"trap!\");\n    }\n\n    function _emscripten_memcpy_big(dest, src, num) {\n      HEAPU8.set(HEAPU8.subarray(src, src + num), dest);\n    }\n\n    function _pthread_cond_wait() {\n      return 0;\n    }\n\n    function __isLeapYear(year) {\n      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n    }\n\n    function __arraySum(array, index) {\n      var sum = 0;\n\n      for (var i = 0; i <= index; sum += array[i++]);\n\n      return sum;\n    }\n\n    var __MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    var __MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n    function __addDays(date, days) {\n      var newDate = new Date(date.getTime());\n\n      while (days > 0) {\n        var leap = __isLeapYear(newDate.getFullYear());\n\n        var currentMonth = newDate.getMonth();\n        var daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth];\n\n        if (days > daysInCurrentMonth - newDate.getDate()) {\n          days -= daysInCurrentMonth - newDate.getDate() + 1;\n          newDate.setDate(1);\n\n          if (currentMonth < 11) {\n            newDate.setMonth(currentMonth + 1);\n          } else {\n            newDate.setMonth(0);\n            newDate.setFullYear(newDate.getFullYear() + 1);\n          }\n        } else {\n          newDate.setDate(newDate.getDate() + days);\n          return newDate;\n        }\n      }\n\n      return newDate;\n    }\n\n    function _strftime(s, maxsize, format, tm) {\n      var tm_zone = HEAP32[tm + 40 >> 2];\n      var date = {\n        tm_sec: HEAP32[tm >> 2],\n        tm_min: HEAP32[tm + 4 >> 2],\n        tm_hour: HEAP32[tm + 8 >> 2],\n        tm_mday: HEAP32[tm + 12 >> 2],\n        tm_mon: HEAP32[tm + 16 >> 2],\n        tm_year: HEAP32[tm + 20 >> 2],\n        tm_wday: HEAP32[tm + 24 >> 2],\n        tm_yday: HEAP32[tm + 28 >> 2],\n        tm_isdst: HEAP32[tm + 32 >> 2],\n        tm_gmtoff: HEAP32[tm + 36 >> 2],\n        tm_zone: tm_zone ? UTF8ToString(tm_zone) : \"\"\n      };\n      var pattern = UTF8ToString(format);\n      var EXPANSION_RULES_1 = {\n        \"%c\": \"%a %b %d %H:%M:%S %Y\",\n        \"%D\": \"%m/%d/%y\",\n        \"%F\": \"%Y-%m-%d\",\n        \"%h\": \"%b\",\n        \"%r\": \"%I:%M:%S %p\",\n        \"%R\": \"%H:%M\",\n        \"%T\": \"%H:%M:%S\",\n        \"%x\": \"%m/%d/%y\",\n        \"%X\": \"%H:%M:%S\"\n      };\n\n      for (var rule in EXPANSION_RULES_1) {\n        pattern = pattern.replace(new RegExp(rule, \"g\"), EXPANSION_RULES_1[rule]);\n      }\n\n      var WEEKDAYS = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"];\n      var MONTHS = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"];\n\n      function leadingSomething(value, digits, character) {\n        var str = typeof value === \"number\" ? value.toString() : value || \"\";\n\n        while (str.length < digits) {\n          str = character[0] + str;\n        }\n\n        return str;\n      }\n\n      function leadingNulls(value, digits) {\n        return leadingSomething(value, digits, \"0\");\n      }\n\n      function compareByDay(date1, date2) {\n        function sgn(value) {\n          return value < 0 ? -1 : value > 0 ? 1 : 0;\n        }\n\n        var compare;\n\n        if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {\n          if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {\n            compare = sgn(date1.getDate() - date2.getDate());\n          }\n        }\n\n        return compare;\n      }\n\n      function getFirstWeekStartDate(janFourth) {\n        switch (janFourth.getDay()) {\n          case 0:\n            return new Date(janFourth.getFullYear() - 1, 11, 29);\n\n          case 1:\n            return janFourth;\n\n          case 2:\n            return new Date(janFourth.getFullYear(), 0, 3);\n\n          case 3:\n            return new Date(janFourth.getFullYear(), 0, 2);\n\n          case 4:\n            return new Date(janFourth.getFullYear(), 0, 1);\n\n          case 5:\n            return new Date(janFourth.getFullYear() - 1, 11, 31);\n\n          case 6:\n            return new Date(janFourth.getFullYear() - 1, 11, 30);\n        }\n      }\n\n      function getWeekBasedYear(date) {\n        var thisDate = __addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday);\n\n        var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);\n        var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);\n        var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);\n        var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);\n\n        if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {\n          if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {\n            return thisDate.getFullYear() + 1;\n          } else {\n            return thisDate.getFullYear();\n          }\n        } else {\n          return thisDate.getFullYear() - 1;\n        }\n      }\n\n      var EXPANSION_RULES_2 = {\n        \"%a\": function (date) {\n          return WEEKDAYS[date.tm_wday].substring(0, 3);\n        },\n        \"%A\": function (date) {\n          return WEEKDAYS[date.tm_wday];\n        },\n        \"%b\": function (date) {\n          return MONTHS[date.tm_mon].substring(0, 3);\n        },\n        \"%B\": function (date) {\n          return MONTHS[date.tm_mon];\n        },\n        \"%C\": function (date) {\n          var year = date.tm_year + 1900;\n          return leadingNulls(year / 100 | 0, 2);\n        },\n        \"%d\": function (date) {\n          return leadingNulls(date.tm_mday, 2);\n        },\n        \"%e\": function (date) {\n          return leadingSomething(date.tm_mday, 2, \" \");\n        },\n        \"%g\": function (date) {\n          return getWeekBasedYear(date).toString().substring(2);\n        },\n        \"%G\": function (date) {\n          return getWeekBasedYear(date);\n        },\n        \"%H\": function (date) {\n          return leadingNulls(date.tm_hour, 2);\n        },\n        \"%I\": function (date) {\n          var twelveHour = date.tm_hour;\n          if (twelveHour == 0) twelveHour = 12;else if (twelveHour > 12) twelveHour -= 12;\n          return leadingNulls(twelveHour, 2);\n        },\n        \"%j\": function (date) {\n          return leadingNulls(date.tm_mday + __arraySum(__isLeapYear(date.tm_year + 1900) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, date.tm_mon - 1), 3);\n        },\n        \"%m\": function (date) {\n          return leadingNulls(date.tm_mon + 1, 2);\n        },\n        \"%M\": function (date) {\n          return leadingNulls(date.tm_min, 2);\n        },\n        \"%n\": function () {\n          return \"\\n\";\n        },\n        \"%p\": function (date) {\n          if (date.tm_hour >= 0 && date.tm_hour < 12) {\n            return \"AM\";\n          } else {\n            return \"PM\";\n          }\n        },\n        \"%S\": function (date) {\n          return leadingNulls(date.tm_sec, 2);\n        },\n        \"%t\": function () {\n          return \"\\t\";\n        },\n        \"%u\": function (date) {\n          var day = new Date(date.tm_year + 1900, date.tm_mon + 1, date.tm_mday, 0, 0, 0, 0);\n          return day.getDay() || 7;\n        },\n        \"%U\": function (date) {\n          var janFirst = new Date(date.tm_year + 1900, 0, 1);\n          var firstSunday = janFirst.getDay() === 0 ? janFirst : __addDays(janFirst, 7 - janFirst.getDay());\n          var endDate = new Date(date.tm_year + 1900, date.tm_mon, date.tm_mday);\n\n          if (compareByDay(firstSunday, endDate) < 0) {\n            var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;\n            var firstSundayUntilEndJanuary = 31 - firstSunday.getDate();\n            var days = firstSundayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();\n            return leadingNulls(Math.ceil(days / 7), 2);\n          }\n\n          return compareByDay(firstSunday, janFirst) === 0 ? \"01\" : \"00\";\n        },\n        \"%V\": function (date) {\n          var janFourthThisYear = new Date(date.tm_year + 1900, 0, 4);\n          var janFourthNextYear = new Date(date.tm_year + 1901, 0, 4);\n          var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);\n          var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);\n\n          var endDate = __addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday);\n\n          if (compareByDay(endDate, firstWeekStartThisYear) < 0) {\n            return \"53\";\n          }\n\n          if (compareByDay(firstWeekStartNextYear, endDate) <= 0) {\n            return \"01\";\n          }\n\n          var daysDifference;\n\n          if (firstWeekStartThisYear.getFullYear() < date.tm_year + 1900) {\n            daysDifference = date.tm_yday + 32 - firstWeekStartThisYear.getDate();\n          } else {\n            daysDifference = date.tm_yday + 1 - firstWeekStartThisYear.getDate();\n          }\n\n          return leadingNulls(Math.ceil(daysDifference / 7), 2);\n        },\n        \"%w\": function (date) {\n          var day = new Date(date.tm_year + 1900, date.tm_mon + 1, date.tm_mday, 0, 0, 0, 0);\n          return day.getDay();\n        },\n        \"%W\": function (date) {\n          var janFirst = new Date(date.tm_year, 0, 1);\n          var firstMonday = janFirst.getDay() === 1 ? janFirst : __addDays(janFirst, janFirst.getDay() === 0 ? 1 : 7 - janFirst.getDay() + 1);\n          var endDate = new Date(date.tm_year + 1900, date.tm_mon, date.tm_mday);\n\n          if (compareByDay(firstMonday, endDate) < 0) {\n            var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;\n            var firstMondayUntilEndJanuary = 31 - firstMonday.getDate();\n            var days = firstMondayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();\n            return leadingNulls(Math.ceil(days / 7), 2);\n          }\n\n          return compareByDay(firstMonday, janFirst) === 0 ? \"01\" : \"00\";\n        },\n        \"%y\": function (date) {\n          return (date.tm_year + 1900).toString().substring(2);\n        },\n        \"%Y\": function (date) {\n          return date.tm_year + 1900;\n        },\n        \"%z\": function (date) {\n          var off = date.tm_gmtoff;\n          var ahead = off >= 0;\n          off = Math.abs(off) / 60;\n          off = off / 60 * 100 + off % 60;\n          return (ahead ? \"+\" : \"-\") + String(\"0000\" + off).slice(-4);\n        },\n        \"%Z\": function (date) {\n          return date.tm_zone;\n        },\n        \"%%\": function () {\n          return \"%\";\n        }\n      };\n\n      for (var rule in EXPANSION_RULES_2) {\n        if (pattern.indexOf(rule) >= 0) {\n          pattern = pattern.replace(new RegExp(rule, \"g\"), EXPANSION_RULES_2[rule](date));\n        }\n      }\n\n      var bytes = intArrayFromString(pattern, false);\n\n      if (bytes.length > maxsize) {\n        return 0;\n      }\n\n      writeArrayToMemory(bytes, s);\n      return bytes.length - 1;\n    }\n\n    function _strftime_l(s, maxsize, format, tm) {\n      return _strftime(s, maxsize, format, tm);\n    }\n\n    FS.staticInit();\n\n    if (ENVIRONMENT_IS_NODE) {\n      var fs = require(\"fs\");\n\n      var NODEJS_PATH = require(\"path\");\n\n      NODEFS.staticInit();\n    }\n\n    function intArrayFromString(stringy, dontAddNull, length) {\n      var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\n      var u8array = new Array(len);\n      var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n      if (dontAddNull) u8array.length = numBytesWritten;\n      return u8array;\n    }\n\n    var asmGlobalArg = {};\n    var asmLibraryArg = {\n      \"f\": abort,\n      \"b\": ___assert_fail,\n      \"c\": ___cxa_allocate_exception,\n      \"r\": ___cxa_pure_virtual,\n      \"d\": ___cxa_throw,\n      \"q\": ___cxa_uncaught_exception,\n      \"p\": ___lock,\n      \"o\": ___map_file,\n      \"k\": ___setErrNo,\n      \"n\": ___syscall140,\n      \"m\": ___syscall146,\n      \"A\": ___syscall6,\n      \"z\": ___syscall91,\n      \"l\": ___unlock,\n      \"e\": _abort,\n      \"y\": _clock,\n      \"x\": _emscripten_get_heap_size,\n      \"w\": _emscripten_memcpy_big,\n      \"v\": _emscripten_resize_heap,\n      \"i\": _getenv,\n      \"h\": _llvm_stackrestore,\n      \"g\": _llvm_stacksave,\n      \"j\": _llvm_trap,\n      \"u\": _pthread_cond_wait,\n      \"t\": _strftime_l,\n      \"s\": abortOnCannotGrowMemory,\n      \"a\": DYNAMICTOP_PTR\n    };\n    var asm = Module[\"asm\"](asmGlobalArg, asmLibraryArg, buffer);\n    Module[\"asm\"] = asm;\n\n    var __ZSt18uncaught_exceptionv = Module[\"__ZSt18uncaught_exceptionv\"] = function () {\n      return Module[\"asm\"][\"B\"].apply(null, arguments);\n    };\n\n    var ___errno_location = Module[\"___errno_location\"] = function () {\n      return Module[\"asm\"][\"C\"].apply(null, arguments);\n    };\n\n    var _emscripten_bind_CornucopiaExport_AddPoint_2 = Module[\"_emscripten_bind_CornucopiaExport_AddPoint_2\"] = function () {\n      return Module[\"asm\"][\"D\"].apply(null, arguments);\n    };\n\n    var _emscripten_bind_CornucopiaExport_BeginCurve_0 = Module[\"_emscripten_bind_CornucopiaExport_BeginCurve_0\"] = function () {\n      return Module[\"asm\"][\"E\"].apply(null, arguments);\n    };\n\n    var _emscripten_bind_CornucopiaExport_CornucopiaExport_0 = Module[\"_emscripten_bind_CornucopiaExport_CornucopiaExport_0\"] = function () {\n      return Module[\"asm\"][\"F\"].apply(null, arguments);\n    };\n\n    var _emscripten_bind_CornucopiaExport_FitCurve_0 = Module[\"_emscripten_bind_CornucopiaExport_FitCurve_0\"] = function () {\n      return Module[\"asm\"][\"G\"].apply(null, arguments);\n    };\n\n    var _emscripten_bind_CornucopiaExport_GetPointX_1 = Module[\"_emscripten_bind_CornucopiaExport_GetPointX_1\"] = function () {\n      return Module[\"asm\"][\"H\"].apply(null, arguments);\n    };\n\n    var _emscripten_bind_CornucopiaExport_GetPointY_1 = Module[\"_emscripten_bind_CornucopiaExport_GetPointY_1\"] = function () {\n      return Module[\"asm\"][\"I\"].apply(null, arguments);\n    };\n\n    var _emscripten_bind_CornucopiaExport_NextBezier_0 = Module[\"_emscripten_bind_CornucopiaExport_NextBezier_0\"] = function () {\n      return Module[\"asm\"][\"J\"].apply(null, arguments);\n    };\n\n    var _emscripten_bind_CornucopiaExport___destroy___0 = Module[\"_emscripten_bind_CornucopiaExport___destroy___0\"] = function () {\n      return Module[\"asm\"][\"K\"].apply(null, arguments);\n    };\n\n    var _emscripten_bind_VoidPtr___destroy___0 = Module[\"_emscripten_bind_VoidPtr___destroy___0\"] = function () {\n      return Module[\"asm\"][\"L\"].apply(null, arguments);\n    };\n\n    var _free = Module[\"_free\"] = function () {\n      return Module[\"asm\"][\"M\"].apply(null, arguments);\n    };\n\n    var _malloc = Module[\"_malloc\"] = function () {\n      return Module[\"asm\"][\"N\"].apply(null, arguments);\n    };\n\n    var globalCtors = Module[\"globalCtors\"] = function () {\n      return Module[\"asm\"][\"Q\"].apply(null, arguments);\n    };\n\n    var stackAlloc = Module[\"stackAlloc\"] = function () {\n      return Module[\"asm\"][\"R\"].apply(null, arguments);\n    };\n\n    var stackRestore = Module[\"stackRestore\"] = function () {\n      return Module[\"asm\"][\"S\"].apply(null, arguments);\n    };\n\n    var stackSave = Module[\"stackSave\"] = function () {\n      return Module[\"asm\"][\"T\"].apply(null, arguments);\n    };\n\n    var dynCall_v = Module[\"dynCall_v\"] = function () {\n      return Module[\"asm\"][\"O\"].apply(null, arguments);\n    };\n\n    var dynCall_vi = Module[\"dynCall_vi\"] = function () {\n      return Module[\"asm\"][\"P\"].apply(null, arguments);\n    };\n\n    Module[\"asm\"] = asm;\n    Module[\"setValue\"] = setValue;\n    Module[\"getValue\"] = getValue;\n\n    Module[\"then\"] = function (func) {\n      if (Module[\"calledRun\"]) {\n        func(Module);\n      } else {\n        var old = Module[\"onRuntimeInitialized\"];\n\n        Module[\"onRuntimeInitialized\"] = function () {\n          if (old) old();\n          func(Module);\n        };\n      }\n\n      return Module;\n    };\n\n    function ExitStatus(status) {\n      this.name = \"ExitStatus\";\n      this.message = \"Program terminated with exit(\" + status + \")\";\n      this.status = status;\n    }\n\n    ExitStatus.prototype = new Error();\n    ExitStatus.prototype.constructor = ExitStatus;\n\n    dependenciesFulfilled = function runCaller() {\n      if (!Module[\"calledRun\"]) run();\n      if (!Module[\"calledRun\"]) dependenciesFulfilled = runCaller;\n    };\n\n    function run(args) {\n      args = args || Module[\"arguments\"];\n\n      if (runDependencies > 0) {\n        return;\n      }\n\n      preRun();\n      if (runDependencies > 0) return;\n      if (Module[\"calledRun\"]) return;\n\n      function doRun() {\n        if (Module[\"calledRun\"]) return;\n        Module[\"calledRun\"] = true;\n        if (ABORT) return;\n        ensureInitRuntime();\n        preMain();\n        if (Module[\"onRuntimeInitialized\"]) Module[\"onRuntimeInitialized\"]();\n        postRun();\n      }\n\n      if (Module[\"setStatus\"]) {\n        Module[\"setStatus\"](\"Running...\");\n        setTimeout(function () {\n          setTimeout(function () {\n            Module[\"setStatus\"](\"\");\n          }, 1);\n          doRun();\n        }, 1);\n      } else {\n        doRun();\n      }\n    }\n\n    Module[\"run\"] = run;\n\n    function abort(what) {\n      if (Module[\"onAbort\"]) {\n        Module[\"onAbort\"](what);\n      }\n\n      if (what !== undefined) {\n        out(what);\n        err(what);\n        what = JSON.stringify(what);\n      } else {\n        what = \"\";\n      }\n\n      ABORT = true;\n      EXITSTATUS = 1;\n      throw \"abort(\" + what + \"). Build with -s ASSERTIONS=1 for more info.\";\n    }\n\n    Module[\"abort\"] = abort;\n\n    if (Module[\"preInit\"]) {\n      if (typeof Module[\"preInit\"] == \"function\") Module[\"preInit\"] = [Module[\"preInit\"]];\n\n      while (Module[\"preInit\"].length > 0) {\n        Module[\"preInit\"].pop()();\n      }\n    }\n\n    Module[\"noExitRuntime\"] = true;\n    run();\n\n    function WrapperObject() {}\n\n    WrapperObject.prototype = Object.create(WrapperObject.prototype);\n    WrapperObject.prototype.constructor = WrapperObject;\n    WrapperObject.prototype.__class__ = WrapperObject;\n    WrapperObject.__cache__ = {};\n    Module[\"WrapperObject\"] = WrapperObject;\n\n    function getCache(__class__) {\n      return (__class__ || WrapperObject).__cache__;\n    }\n\n    Module[\"getCache\"] = getCache;\n\n    function wrapPointer(ptr, __class__) {\n      var cache = getCache(__class__);\n      var ret = cache[ptr];\n      if (ret) return ret;\n      ret = Object.create((__class__ || WrapperObject).prototype);\n      ret.ptr = ptr;\n      return cache[ptr] = ret;\n    }\n\n    Module[\"wrapPointer\"] = wrapPointer;\n\n    function castObject(obj, __class__) {\n      return wrapPointer(obj.ptr, __class__);\n    }\n\n    Module[\"castObject\"] = castObject;\n    Module[\"NULL\"] = wrapPointer(0);\n\n    function destroy(obj) {\n      if (!obj[\"__destroy__\"]) throw \"Error: Cannot destroy object. (Did you create it yourself?)\";\n      obj[\"__destroy__\"]();\n      delete getCache(obj.__class__)[obj.ptr];\n    }\n\n    Module[\"destroy\"] = destroy;\n\n    function compare(obj1, obj2) {\n      return obj1.ptr === obj2.ptr;\n    }\n\n    Module[\"compare\"] = compare;\n\n    function getPointer(obj) {\n      return obj.ptr;\n    }\n\n    Module[\"getPointer\"] = getPointer;\n\n    function getClass(obj) {\n      return obj.__class__;\n    }\n\n    Module[\"getClass\"] = getClass;\n    var ensureCache = {\n      buffer: 0,\n      size: 0,\n      pos: 0,\n      temps: [],\n      needed: 0,\n      prepare: function () {\n        if (ensureCache.needed) {\n          for (var i = 0; i < ensureCache.temps.length; i++) {\n            Module[\"_free\"](ensureCache.temps[i]);\n          }\n\n          ensureCache.temps.length = 0;\n          Module[\"_free\"](ensureCache.buffer);\n          ensureCache.buffer = 0;\n          ensureCache.size += ensureCache.needed;\n          ensureCache.needed = 0;\n        }\n\n        if (!ensureCache.buffer) {\n          ensureCache.size += 128;\n          ensureCache.buffer = Module[\"_malloc\"](ensureCache.size);\n          assert(ensureCache.buffer);\n        }\n\n        ensureCache.pos = 0;\n      },\n      alloc: function (array, view) {\n        assert(ensureCache.buffer);\n        var bytes = view.BYTES_PER_ELEMENT;\n        var len = array.length * bytes;\n        len = len + 7 & -8;\n        var ret;\n\n        if (ensureCache.pos + len >= ensureCache.size) {\n          assert(len > 0);\n          ensureCache.needed += len;\n          ret = Module[\"_malloc\"](len);\n          ensureCache.temps.push(ret);\n        } else {\n          ret = ensureCache.buffer + ensureCache.pos;\n          ensureCache.pos += len;\n        }\n\n        return ret;\n      },\n      copy: function (array, view, offset) {\n        var offsetShifted = offset;\n        var bytes = view.BYTES_PER_ELEMENT;\n\n        switch (bytes) {\n          case 2:\n            offsetShifted >>= 1;\n            break;\n\n          case 4:\n            offsetShifted >>= 2;\n            break;\n\n          case 8:\n            offsetShifted >>= 3;\n            break;\n        }\n\n        for (var i = 0; i < array.length; i++) {\n          view[offsetShifted + i] = array[i];\n        }\n      }\n    };\n\n    function VoidPtr() {\n      throw \"cannot construct a VoidPtr, no constructor in IDL\";\n    }\n\n    VoidPtr.prototype = Object.create(WrapperObject.prototype);\n    VoidPtr.prototype.constructor = VoidPtr;\n    VoidPtr.prototype.__class__ = VoidPtr;\n    VoidPtr.__cache__ = {};\n    Module[\"VoidPtr\"] = VoidPtr;\n\n    VoidPtr.prototype[\"__destroy__\"] = VoidPtr.prototype.__destroy__ = function () {\n      var self = this.ptr;\n\n      _emscripten_bind_VoidPtr___destroy___0(self);\n    };\n\n    function CornucopiaExport() {\n      this.ptr = _emscripten_bind_CornucopiaExport_CornucopiaExport_0();\n      getCache(CornucopiaExport)[this.ptr] = this;\n    }\n\n    CornucopiaExport.prototype = Object.create(WrapperObject.prototype);\n    CornucopiaExport.prototype.constructor = CornucopiaExport;\n    CornucopiaExport.prototype.__class__ = CornucopiaExport;\n    CornucopiaExport.__cache__ = {};\n    Module[\"CornucopiaExport\"] = CornucopiaExport;\n\n    CornucopiaExport.prototype[\"BeginCurve\"] = CornucopiaExport.prototype.BeginCurve = function () {\n      var self = this.ptr;\n\n      _emscripten_bind_CornucopiaExport_BeginCurve_0(self);\n    };\n\n    CornucopiaExport.prototype[\"AddPoint\"] = CornucopiaExport.prototype.AddPoint = function (arg0, arg1) {\n      var self = this.ptr;\n      if (arg0 && typeof arg0 === \"object\") arg0 = arg0.ptr;\n      if (arg1 && typeof arg1 === \"object\") arg1 = arg1.ptr;\n\n      _emscripten_bind_CornucopiaExport_AddPoint_2(self, arg0, arg1);\n    };\n\n    CornucopiaExport.prototype[\"FitCurve\"] = CornucopiaExport.prototype.FitCurve = function () {\n      var self = this.ptr;\n      return _emscripten_bind_CornucopiaExport_FitCurve_0(self);\n    };\n\n    CornucopiaExport.prototype[\"NextBezier\"] = CornucopiaExport.prototype.NextBezier = function () {\n      var self = this.ptr;\n      return !!_emscripten_bind_CornucopiaExport_NextBezier_0(self);\n    };\n\n    CornucopiaExport.prototype[\"GetPointX\"] = CornucopiaExport.prototype.GetPointX = function (arg0) {\n      var self = this.ptr;\n      if (arg0 && typeof arg0 === \"object\") arg0 = arg0.ptr;\n      return _emscripten_bind_CornucopiaExport_GetPointX_1(self, arg0);\n    };\n\n    CornucopiaExport.prototype[\"GetPointY\"] = CornucopiaExport.prototype.GetPointY = function (arg0) {\n      var self = this.ptr;\n      if (arg0 && typeof arg0 === \"object\") arg0 = arg0.ptr;\n      return _emscripten_bind_CornucopiaExport_GetPointY_1(self, arg0);\n    };\n\n    CornucopiaExport.prototype[\"__destroy__\"] = CornucopiaExport.prototype.__destroy__ = function () {\n      var self = this.ptr;\n\n      _emscripten_bind_CornucopiaExport___destroy___0(self);\n    };\n\n    (function () {\n      function setupEnums() {}\n\n      if (runtimeInitialized) setupEnums();else addOnPreMain(setupEnums);\n    })();\n\n    return Module;\n  };\n}();\n\nif (true) module.exports = Module;else {}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../process/browser.js */ \"./node_modules/process/browser.js\"), \"/\", __webpack_require__(/*! ./../../../../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/@capture/shape-core/src/cornucopia/CornucopiaCore.js?");

/***/ }),

/***/ "./node_modules/@capture/shape-core/src/cornucopia/CornucopiaCore.wasm":
/*!*****************************************************************************!*\
  !*** ./node_modules/@capture/shape-core/src/cornucopia/CornucopiaCore.wasm ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"resources/CornucopiaCore.wasm\";\n\n//# sourceURL=webpack:///./node_modules/@capture/shape-core/src/cornucopia/CornucopiaCore.wasm?");

/***/ }),

/***/ "./node_modules/@capture/shape-core/src/helpers/SVGHelper.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@capture/shape-core/src/helpers/SVGHelper.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nclass SVGHelper {\n  /**\n   * function called to start creating svg data for shape\n   * @function beginShape\n   * @param {number} width the width of image data\n   * @param {number} height the height of image data\n   * @returns {string} the svg header data\n   */\n  static beginShape(width, height) {\n    var svgString = '';\n    svgString += '<?xml version=\"1.0\" encoding=\"utf-8\"?>';\n    svgString += '<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">';\n    svgString += '<svg version=\"1.1\" id=\"Contours\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"' + width + 'px\" height=\"' + height + 'px\" viewBox=\"0.0 0.0 ' + width + ' ' + height + '\" enable-background=\"new 0 0 ' + width + ' ' + height + '\" xml:space=\"preserve\" stroke=\"none\" fill=\"black\">';\n    svgString += '<desc xmlns:shape=\"http://adobe.com/products/shape\"><shape:appName>Capture Extension</shape:appName><shape:platform>Extension</shape:platform></desc>';\n    return svgString;\n  }\n  /**\n   * function called to add svg footer\n   * @function endShape\n   * @returns {string} the svg footer\n   */\n\n\n  static endShape() {\n    var svgString = '</svg>';\n    return svgString;\n  }\n  /**\n   * function called to start creating svg data for a path\n   * @function beginPath\n   * @returns {string} the svg path header data\n   */\n\n\n  static beginPath() {\n    var pathString = '';\n    pathString += '<path class=\"selected\" fill=\"#000000\" opacity=\"1.000000\" stroke=\"none\" d=\"';\n    return pathString;\n  }\n  /**\n   * function called to add a path to the data\n   * @function addPath\n   * @param {Array} verts the array of vertices for this path\n   * @param {boolean} isCurve whether the path is a curve or not\n   * @param {number} height the height of image data\n   * @returns {string} the svg path data\n   */\n\n\n  static addPath(verts, isCurve, height) {\n    // depending on the path type, add the path correctly\n    if (isCurve) {\n      return this._addCurve(verts, height);\n    } else {\n      return this._addPolyline(verts, height);\n    }\n  }\n  /**\n   * function called to add path footer\n   * @function endPath\n   * @returns {string} the svg path footer\n   */\n\n\n  static endPath() {\n    var pathEndString = 'z\"/>';\n    return pathEndString;\n  }\n  /**\n   * function called to add a curve to the path\n   * @function _addCurve\n   * @param {Array} verts the array of vertices for this path\n   * @param {number} height the height of image data\n   * @returns {string} the svg path data\n   */\n\n\n  static _addCurve(verts, height) {\n    var subPathString = '';\n    var vertLength = verts.length / 2;\n\n    for (var i = 0; i < vertLength; i++) {\n      // first vertex\n      if (i === 0) {\n        subPathString += 'M' + verts[0] + ' ' + (height - verts[1]) + ' ';\n      } else if (i % 3 === 1) {\n        subPathString += 'C' + verts[2 * i] + ' ' + (height - verts[2 * i + 1]) + ' ';\n      } else {\n        subPathString += verts[2 * i] + ' ' + (height - verts[2 * i + 1]) + ' ';\n      }\n    }\n\n    return subPathString;\n  }\n  /**\n   * function called to add a line path to the data\n   * @function _addPolyline\n   * @param {Array} verts the array of vertices for this path\n   * @param {number} height the height of image data\n   * @returns {string} the svg path data\n   */\n\n\n  static _addPolyline(verts, height) {\n    var subPathString = '';\n    var vertLength = verts.length / 2;\n\n    for (var i = 0; i < vertLength; i++) {\n      // first vertex\n      if (i === 0) {\n        subPathString += 'M' + verts[0] + ' ' + (height - verts[1]) + ' ';\n      } else {\n        subPathString += 'L' + verts[2 * i] + ' ' + (height - verts[2 * i + 1]) + ' ';\n      }\n    }\n\n    return subPathString;\n  }\n\n}\n\nexports.default = SVGHelper;\n\n//# sourceURL=webpack:///./node_modules/@capture/shape-core/src/helpers/SVGHelper.js?");

/***/ }),

/***/ "./node_modules/@capture/shape-core/src/vectorize/Vectorize.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@capture/shape-core/src/vectorize/Vectorize.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _SVGHelper = _interopRequireDefault(__webpack_require__(/*! ../helpers/SVGHelper */ \"./node_modules/@capture/shape-core/src/helpers/SVGHelper.js\"));\n\nvar _VectorizeCore = _interopRequireDefault(__webpack_require__(/*! ./VectorizeCore */ \"./node_modules/@capture/shape-core/src/vectorize/VectorizeCore.js\"));\n\nvar _VectorizeCore2 = _interopRequireDefault(__webpack_require__(/*! ./VectorizeCore.wasm */ \"./node_modules/@capture/shape-core/src/vectorize/VectorizeCore.wasm\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst vectorizeCore = (0, _VectorizeCore.default)({\n  locateFile: path => {\n    return path === 'VectorizeCore.wasm' ? _VectorizeCore2.default : path;\n  },\n  readBinary: () => {\n    var arrayBuffer = new ArrayBuffer(_VectorizeCore2.default.data.length);\n    var view = new Uint8Array(arrayBuffer);\n\n    for (var i = 0; i < _VectorizeCore2.default.data.length; ++i) {\n      view[i] = _VectorizeCore2.default.data[i];\n    }\n\n    return arrayBuffer;\n  }\n});\n\nvectorizeCore.onRuntimeInitialized = () => {\n  Vectorize.available = true;\n};\n\nclass Vectorize {\n  // the following parameters help in deciding if a path should be allowed or not (based on it's screen coverage)\n  static process(imageData, width, height, fitCurve = true) {\n    if (!this.available) {\n      return null;\n    } // sanity checks on data\n\n\n    if (typeof imageData === 'undefined' || typeof width !== 'number' || typeof height !== 'number' || typeof imageData.length !== 'number' || imageData.length !== 4 * width * height) {\n      return null;\n    } // allocate memory on emscripten heap and set image data in that heap\n\n\n    var data = vectorizeCore._malloc(imageData.length / 4);\n\n    for (var i = 0; i < imageData.length / 4; i++) {\n      vectorizeCore.setValue(data + i, imageData[4 * i], 'i8');\n    } // vectorize image to data (create object which handles that)\n\n\n    const vectorizeExport = new vectorizeCore.VectorizeExport(); // run the vectorize operation\n\n    vectorizeExport.VectorizeToData(data, width, height, fitCurve ? this._vectorizeParams.CURVES : this._vectorizeParams.POLYLINES); // get the vectors count\n\n    var nVectors = vectorizeExport.VectorCount();\n    var paths = []; // begin SVG data\n\n    var svg = _SVGHelper.default.beginShape(width, height); // iterate over the number of vectors\n\n\n    for (i = 0; i < nVectors; i++) {\n      // get the data for this vector\n      var vectorPath = vectorizeExport.GetVector(i); // get the number of paths in this vector\n\n      var nSubPaths = vectorPath.PathCount(); // this array will keep together all the paths in the current vector\n\n      var subPaths = []; // begin svg path\n\n      var svgPath = _SVGHelper.default.beginPath(); // iterate over the number of paths in each vectors\n\n\n      for (var j = 0; j < nSubPaths; j++) {\n        // get the data for this path\n        var subPath = vectorPath.GetPath(j); // get the number of points in this path\n\n        var nPoints = subPath.get_nPoints(); // if points count is 0 then do nothing\n\n        if (nPoints === 0) {\n          continue;\n        } // array which will store the vertices data for this path\n\n\n        var vertexData = [];\n\n        for (var k = 0; k < nPoints; k++) {\n          // add the points in an array\n          var point = subPath.get_pPoints(k);\n          vertexData.push(point.get_x(), point.get_y());\n        }\n\n        if (!this._allowPath(vertexData)) {\n          continue;\n        } // here we make a choice whether this path is a polyline or a curve\n        // get the path type\n\n\n        var isCurvePath = subPath.get_bIsCurve(); // we add an additinal property in the vertex data array to indicate just that\n\n        if (subPath.get_bIsCurve()) {\n          vertexData.pathType = this._vectorizeParams.CURVES;\n        } else {\n          vertexData.pathType = this._vectorizeParams.POLYLINES;\n        }\n\n        svgPath += _SVGHelper.default.addPath(vertexData, isCurvePath, height); // add this vertex data to the path array\n\n        subPaths.push(vertexData);\n      } // end svg path and the this path\n\n\n      svgPath += _SVGHelper.default.endPath();\n\n      if (subPaths.length > 0) {\n        // if there was atleast one path in the array then add this path in the paths array and in the svg\n        svg += svgPath;\n        paths.push(subPaths);\n      }\n    }\n\n    svg += _SVGHelper.default.endShape(); // release module's memory\n\n    vectorizeCore.destroy(vectorizeExport);\n\n    vectorizeCore._free(data);\n\n    return {\n      paths,\n      svg\n    };\n  }\n  /**\n  * this function will calculate the bounding box for a path and decide if this path is worth processing further or not\n  * @function allowPath\n  * @param {Array} vertices the vertex data for the path\n  * @returns {boolean} flag to indicate if the path should be allowed further or not\n  */\n\n\n  static _allowPath(vertices) {\n    // santiy check\n    if (vertices.length === undefined || vertices.length === 0) {\n      return false;\n    } // initialize the bounding box from first vertex\n\n\n    var minX = vertices[0];\n    var minY = vertices[1];\n    var maxX = vertices[0];\n    var maxY = vertices[1]; // now iterate on the rest of the points and updated the bounding box\n\n    for (var i = 0; i < vertices.length; i += 2) {\n      if (vertices[i] < minX) {\n        minX = vertices[i];\n      } else if (vertices[i] > maxX) {\n        maxX = vertices[i];\n      }\n\n      if (vertices[i + 1] < minY) {\n        minY = vertices[i + 1];\n      } else if (vertices[i + 1] > maxY) {\n        maxY = vertices[i + 1];\n      }\n    }\n\n    maxX -= minX;\n    maxY -= minY;\n    return maxX * maxY > this._areaThreshhold;\n  }\n\n}\n\nexports.default = Vectorize;\nVectorize.available = false;\nVectorize._vectorizeParams = {\n  POLYLINES: 0,\n  // option used to fit polyline from vectorize library\n  CURVES: 3 // option used to fit curve from vectorize library\n\n};\nVectorize._areaThreshhold = 4.0;\n\n//# sourceURL=webpack:///./node_modules/@capture/shape-core/src/vectorize/Vectorize.js?");

/***/ }),

/***/ "./node_modules/@capture/shape-core/src/vectorize/VectorizeCore.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@capture/shape-core/src/vectorize/VectorizeCore.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process, __dirname, Buffer) {var require;\n\n/* eslint-disable */\nvar Module = function () {\n  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;\n\n  return function (Module) {\n    Module = Module || {};\n\n    if (typeof window === 'undefined') {\n      var window = self;\n    }\n\n    require = window.nodeRequire;\n    var Module = typeof Module !== \"undefined\" ? Module : {};\n    var moduleOverrides = {};\n    var key;\n\n    for (key in Module) {\n      if (Module.hasOwnProperty(key)) {\n        moduleOverrides[key] = Module[key];\n      }\n    }\n\n    Module[\"arguments\"] = [];\n    Module[\"thisProgram\"] = \"./this.program\";\n\n    Module[\"quit\"] = function (status, toThrow) {\n      throw toThrow;\n    };\n\n    Module[\"preRun\"] = [];\n    Module[\"postRun\"] = [];\n    var ENVIRONMENT_IS_WEB = false;\n    var ENVIRONMENT_IS_WORKER = false;\n    var ENVIRONMENT_IS_NODE = false;\n    var ENVIRONMENT_IS_SHELL = false;\n    ENVIRONMENT_IS_WEB = typeof window === \"object\";\n    ENVIRONMENT_IS_WORKER = typeof importScripts === \"function\";\n    ENVIRONMENT_IS_NODE = typeof process === \"object\" && typeof require === \"function\" && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;\n    ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\n    var scriptDirectory = \"\";\n\n    function locateFile(path) {\n      if (Module[\"locateFile\"]) {\n        return Module[\"locateFile\"](path, scriptDirectory);\n      } else {\n        return scriptDirectory + path;\n      }\n    }\n\n    if (ENVIRONMENT_IS_NODE) {\n      scriptDirectory = __dirname + \"/\";\n      var nodeFS;\n      var nodePath;\n\n      Module[\"read\"] = function shell_read(filename, binary) {\n        var ret;\n        if (!nodeFS) nodeFS = require(\"fs\");\n        if (!nodePath) nodePath = require(\"path\");\n        filename = nodePath[\"normalize\"](filename);\n        ret = nodeFS[\"readFileSync\"](filename);\n        return binary ? ret : ret.toString();\n      };\n\n      Module[\"readBinary\"] = function readBinary(filename) {\n        var ret = Module[\"read\"](filename, true);\n\n        if (!ret.buffer) {\n          ret = new Uint8Array(ret);\n        }\n\n        assert(ret.buffer);\n        return ret;\n      };\n\n      if (process[\"argv\"].length > 1) {\n        Module[\"thisProgram\"] = process[\"argv\"][1].replace(/\\\\/g, \"/\");\n      }\n\n      Module[\"arguments\"] = process[\"argv\"].slice(2);\n      process[\"on\"](\"uncaughtException\", function (ex) {\n        if (!(ex instanceof ExitStatus)) {\n          throw ex;\n        }\n      });\n      process[\"on\"](\"unhandledRejection\", abort);\n\n      Module[\"quit\"] = function (status) {\n        process[\"exit\"](status);\n      };\n\n      Module[\"inspect\"] = function () {\n        return \"[Emscripten Module object]\";\n      };\n    } else if (ENVIRONMENT_IS_SHELL) {\n      if (typeof read != \"undefined\") {\n        Module[\"read\"] = function shell_read(f) {\n          return read(f);\n        };\n      }\n\n      Module[\"readBinary\"] = function readBinary(f) {\n        var data;\n\n        if (typeof readbuffer === \"function\") {\n          return new Uint8Array(readbuffer(f));\n        }\n\n        data = read(f, \"binary\");\n        assert(typeof data === \"object\");\n        return data;\n      };\n\n      if (typeof scriptArgs != \"undefined\") {\n        Module[\"arguments\"] = scriptArgs;\n      } else if (typeof arguments != \"undefined\") {\n        Module[\"arguments\"] = arguments;\n      }\n\n      if (typeof quit === \"function\") {\n        Module[\"quit\"] = function (status) {\n          quit(status);\n        };\n      }\n    } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n      if (ENVIRONMENT_IS_WORKER) {\n        scriptDirectory = self.location.href;\n      } else if (document.currentScript) {\n        scriptDirectory = document.currentScript.src;\n      }\n\n      if (_scriptDir) {\n        scriptDirectory = _scriptDir;\n      }\n\n      if (scriptDirectory.indexOf(\"blob:\") !== 0) {\n        scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf(\"/\") + 1);\n      } else {\n        scriptDirectory = \"\";\n      }\n\n      Module[\"read\"] = function shell_read(url) {\n        var xhr = new XMLHttpRequest();\n        xhr.open(\"GET\", url, false);\n        xhr.send(null);\n        return xhr.responseText;\n      };\n\n      if (ENVIRONMENT_IS_WORKER) {\n        Module[\"readBinary\"] = function readBinary(url) {\n          var xhr = new XMLHttpRequest();\n          xhr.open(\"GET\", url, false);\n          xhr.responseType = \"arraybuffer\";\n          xhr.send(null);\n          return new Uint8Array(xhr.response);\n        };\n      }\n\n      Module[\"readAsync\"] = function readAsync(url, onload, onerror) {\n        var xhr = new XMLHttpRequest();\n        xhr.open(\"GET\", url, true);\n        xhr.responseType = \"arraybuffer\";\n\n        xhr.onload = function xhr_onload() {\n          if (xhr.status == 200 || xhr.status == 0 && xhr.response) {\n            onload(xhr.response);\n            return;\n          }\n\n          onerror();\n        };\n\n        xhr.onerror = onerror;\n        xhr.send(null);\n      };\n\n      Module[\"setWindowTitle\"] = function (title) {\n        document.title = title;\n      };\n    } else {}\n\n    var out = Module[\"print\"] || (typeof console !== \"undefined\" ? console.log.bind(console) : typeof print !== \"undefined\" ? print : null);\n    var err = Module[\"printErr\"] || (typeof printErr !== \"undefined\" ? printErr : typeof console !== \"undefined\" && console.warn.bind(console) || out);\n\n    for (key in moduleOverrides) {\n      if (moduleOverrides.hasOwnProperty(key)) {\n        Module[key] = moduleOverrides[key];\n      }\n    }\n\n    moduleOverrides = undefined;\n\n    function dynamicAlloc(size) {\n      var ret = HEAP32[DYNAMICTOP_PTR >> 2];\n      var end = ret + size + 15 & -16;\n\n      if (end <= _emscripten_get_heap_size()) {\n        HEAP32[DYNAMICTOP_PTR >> 2] = end;\n      } else {\n        var success = _emscripten_resize_heap(end);\n\n        if (!success) return 0;\n      }\n\n      return ret;\n    }\n\n    function getNativeTypeSize(type) {\n      switch (type) {\n        case \"i1\":\n        case \"i8\":\n          return 1;\n\n        case \"i16\":\n          return 2;\n\n        case \"i32\":\n          return 4;\n\n        case \"i64\":\n          return 8;\n\n        case \"float\":\n          return 4;\n\n        case \"double\":\n          return 8;\n\n        default:\n          {\n            if (type[type.length - 1] === \"*\") {\n              return 4;\n            } else if (type[0] === \"i\") {\n              var bits = parseInt(type.substr(1));\n              assert(bits % 8 === 0, \"getNativeTypeSize invalid bits \" + bits + \", type \" + type);\n              return bits / 8;\n            } else {\n              return 0;\n            }\n          }\n      }\n    }\n\n    var asm2wasmImports = {\n      \"f64-rem\": function (x, y) {\n        return x % y;\n      },\n      \"debugger\": function () {\n        debugger;\n      }\n    };\n    var functionPointers = new Array(0);\n\n    if (typeof WebAssembly !== \"object\") {\n      err(\"no native wasm support detected\");\n    }\n\n    function getValue(ptr, type, noSafe) {\n      type = type || \"i8\";\n      if (type.charAt(type.length - 1) === \"*\") type = \"i32\";\n\n      switch (type) {\n        case \"i1\":\n          return HEAP8[ptr >> 0];\n\n        case \"i8\":\n          return HEAP8[ptr >> 0];\n\n        case \"i16\":\n          return HEAP16[ptr >> 1];\n\n        case \"i32\":\n          return HEAP32[ptr >> 2];\n\n        case \"i64\":\n          return HEAP32[ptr >> 2];\n\n        case \"float\":\n          return HEAPF32[ptr >> 2];\n\n        case \"double\":\n          return HEAPF64[ptr >> 3];\n\n        default:\n          abort(\"invalid type for getValue: \" + type);\n      }\n\n      return null;\n    }\n\n    var wasmMemory;\n    var wasmTable;\n    var ABORT = false;\n    var EXITSTATUS = 0;\n\n    function assert(condition, text) {\n      if (!condition) {\n        abort(\"Assertion failed: \" + text);\n      }\n    }\n\n    function setValue(ptr, value, type, noSafe) {\n      type = type || \"i8\";\n      if (type.charAt(type.length - 1) === \"*\") type = \"i32\";\n\n      switch (type) {\n        case \"i1\":\n          HEAP8[ptr >> 0] = value;\n          break;\n\n        case \"i8\":\n          HEAP8[ptr >> 0] = value;\n          break;\n\n        case \"i16\":\n          HEAP16[ptr >> 1] = value;\n          break;\n\n        case \"i32\":\n          HEAP32[ptr >> 2] = value;\n          break;\n\n        case \"i64\":\n          tempI64 = [value >>> 0, (tempDouble = value, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];\n          break;\n\n        case \"float\":\n          HEAPF32[ptr >> 2] = value;\n          break;\n\n        case \"double\":\n          HEAPF64[ptr >> 3] = value;\n          break;\n\n        default:\n          abort(\"invalid type for setValue: \" + type);\n      }\n    }\n\n    var ALLOC_NONE = 3;\n\n    function allocate(slab, types, allocator, ptr) {\n      var zeroinit, size;\n\n      if (typeof slab === \"number\") {\n        zeroinit = true;\n        size = slab;\n      } else {\n        zeroinit = false;\n        size = slab.length;\n      }\n\n      var singleType = typeof types === \"string\" ? types : null;\n      var ret;\n\n      if (allocator == ALLOC_NONE) {\n        ret = ptr;\n      } else {\n        ret = [_malloc, stackAlloc, dynamicAlloc][allocator](Math.max(size, singleType ? 1 : types.length));\n      }\n\n      if (zeroinit) {\n        var stop;\n        ptr = ret;\n        assert((ret & 3) == 0);\n        stop = ret + (size & ~3);\n\n        for (; ptr < stop; ptr += 4) {\n          HEAP32[ptr >> 2] = 0;\n        }\n\n        stop = ret + size;\n\n        while (ptr < stop) {\n          HEAP8[ptr++ >> 0] = 0;\n        }\n\n        return ret;\n      }\n\n      if (singleType === \"i8\") {\n        if (slab.subarray || slab.slice) {\n          HEAPU8.set(slab, ret);\n        } else {\n          HEAPU8.set(new Uint8Array(slab), ret);\n        }\n\n        return ret;\n      }\n\n      var i = 0,\n          type,\n          typeSize,\n          previousType;\n\n      while (i < size) {\n        var curr = slab[i];\n        type = singleType || types[i];\n\n        if (type === 0) {\n          i++;\n          continue;\n        }\n\n        if (type == \"i64\") type = \"i32\";\n        setValue(ret + i, curr, type);\n\n        if (previousType !== type) {\n          typeSize = getNativeTypeSize(type);\n          previousType = type;\n        }\n\n        i += typeSize;\n      }\n\n      return ret;\n    }\n\n    var UTF8Decoder = typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf8\") : undefined;\n\n    function UTF8ArrayToString(u8Array, idx, maxBytesToRead) {\n      var endIdx = idx + maxBytesToRead;\n      var endPtr = idx;\n\n      while (u8Array[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n\n      if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {\n        return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));\n      } else {\n        var str = \"\";\n\n        while (idx < endPtr) {\n          var u0 = u8Array[idx++];\n\n          if (!(u0 & 128)) {\n            str += String.fromCharCode(u0);\n            continue;\n          }\n\n          var u1 = u8Array[idx++] & 63;\n\n          if ((u0 & 224) == 192) {\n            str += String.fromCharCode((u0 & 31) << 6 | u1);\n            continue;\n          }\n\n          var u2 = u8Array[idx++] & 63;\n\n          if ((u0 & 240) == 224) {\n            u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n          } else {\n            u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | u8Array[idx++] & 63;\n          }\n\n          if (u0 < 65536) {\n            str += String.fromCharCode(u0);\n          } else {\n            var ch = u0 - 65536;\n            str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n          }\n        }\n      }\n\n      return str;\n    }\n\n    function UTF8ToString(ptr, maxBytesToRead) {\n      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : \"\";\n    }\n\n    function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {\n      if (!(maxBytesToWrite > 0)) return 0;\n      var startIdx = outIdx;\n      var endIdx = outIdx + maxBytesToWrite - 1;\n\n      for (var i = 0; i < str.length; ++i) {\n        var u = str.charCodeAt(i);\n\n        if (u >= 55296 && u <= 57343) {\n          var u1 = str.charCodeAt(++i);\n          u = 65536 + ((u & 1023) << 10) | u1 & 1023;\n        }\n\n        if (u <= 127) {\n          if (outIdx >= endIdx) break;\n          outU8Array[outIdx++] = u;\n        } else if (u <= 2047) {\n          if (outIdx + 1 >= endIdx) break;\n          outU8Array[outIdx++] = 192 | u >> 6;\n          outU8Array[outIdx++] = 128 | u & 63;\n        } else if (u <= 65535) {\n          if (outIdx + 2 >= endIdx) break;\n          outU8Array[outIdx++] = 224 | u >> 12;\n          outU8Array[outIdx++] = 128 | u >> 6 & 63;\n          outU8Array[outIdx++] = 128 | u & 63;\n        } else {\n          if (outIdx + 3 >= endIdx) break;\n          outU8Array[outIdx++] = 240 | u >> 18;\n          outU8Array[outIdx++] = 128 | u >> 12 & 63;\n          outU8Array[outIdx++] = 128 | u >> 6 & 63;\n          outU8Array[outIdx++] = 128 | u & 63;\n        }\n      }\n\n      outU8Array[outIdx] = 0;\n      return outIdx - startIdx;\n    }\n\n    function stringToUTF8(str, outPtr, maxBytesToWrite) {\n      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n    }\n\n    function lengthBytesUTF8(str) {\n      var len = 0;\n\n      for (var i = 0; i < str.length; ++i) {\n        var u = str.charCodeAt(i);\n        if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;\n        if (u <= 127) ++len;else if (u <= 2047) len += 2;else if (u <= 65535) len += 3;else len += 4;\n      }\n\n      return len;\n    }\n\n    var UTF16Decoder = typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf-16le\") : undefined;\n\n    function demangle(func) {\n      return func;\n    }\n\n    function demangleAll(text) {\n      var regex = /__Z[\\w\\d_]+/g;\n      return text.replace(regex, function (x) {\n        var y = demangle(x);\n        return x === y ? x : y + \" [\" + x + \"]\";\n      });\n    }\n\n    function jsStackTrace() {\n      var err = new Error();\n\n      if (!err.stack) {\n        try {\n          throw new Error(0);\n        } catch (e) {\n          err = e;\n        }\n\n        if (!err.stack) {\n          return \"(no stack trace available)\";\n        }\n      }\n\n      return err.stack.toString();\n    }\n\n    function stackTrace() {\n      var js = jsStackTrace();\n      if (Module[\"extraStackTrace\"]) js += \"\\n\" + Module[\"extraStackTrace\"]();\n      return demangleAll(js);\n    }\n\n    var WASM_PAGE_SIZE = 65536;\n\n    function alignUp(x, multiple) {\n      if (x % multiple > 0) {\n        x += multiple - x % multiple;\n      }\n\n      return x;\n    }\n\n    var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\n\n    function updateGlobalBuffer(buf) {\n      Module[\"buffer\"] = buffer = buf;\n    }\n\n    function updateGlobalBufferViews() {\n      Module[\"HEAP8\"] = HEAP8 = new Int8Array(buffer);\n      Module[\"HEAP16\"] = HEAP16 = new Int16Array(buffer);\n      Module[\"HEAP32\"] = HEAP32 = new Int32Array(buffer);\n      Module[\"HEAPU8\"] = HEAPU8 = new Uint8Array(buffer);\n      Module[\"HEAPU16\"] = HEAPU16 = new Uint16Array(buffer);\n      Module[\"HEAPU32\"] = HEAPU32 = new Uint32Array(buffer);\n      Module[\"HEAPF32\"] = HEAPF32 = new Float32Array(buffer);\n      Module[\"HEAPF64\"] = HEAPF64 = new Float64Array(buffer);\n    }\n\n    var DYNAMIC_BASE = 5269984,\n        DYNAMICTOP_PTR = 26848;\n    var TOTAL_STACK = 5242880;\n    var TOTAL_MEMORY = Module[\"TOTAL_MEMORY\"] || 16777216;\n    if (TOTAL_MEMORY < TOTAL_STACK) err(\"TOTAL_MEMORY should be larger than TOTAL_STACK, was \" + TOTAL_MEMORY + \"! (TOTAL_STACK=\" + TOTAL_STACK + \")\");\n\n    if (Module[\"buffer\"]) {\n      buffer = Module[\"buffer\"];\n    } else {\n      if (typeof WebAssembly === \"object\" && typeof WebAssembly.Memory === \"function\") {\n        wasmMemory = new WebAssembly.Memory({\n          \"initial\": TOTAL_MEMORY / WASM_PAGE_SIZE\n        });\n        buffer = wasmMemory.buffer;\n      } else {\n        buffer = new ArrayBuffer(TOTAL_MEMORY);\n      }\n\n      Module[\"buffer\"] = buffer;\n    }\n\n    updateGlobalBufferViews();\n    HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;\n\n    function callRuntimeCallbacks(callbacks) {\n      while (callbacks.length > 0) {\n        var callback = callbacks.shift();\n\n        if (typeof callback == \"function\") {\n          callback();\n          continue;\n        }\n\n        var func = callback.func;\n\n        if (typeof func === \"number\") {\n          if (callback.arg === undefined) {\n            Module[\"dynCall_v\"](func);\n          } else {\n            Module[\"dynCall_vi\"](func, callback.arg);\n          }\n        } else {\n          func(callback.arg === undefined ? null : callback.arg);\n        }\n      }\n    }\n\n    var __ATPRERUN__ = [];\n    var __ATINIT__ = [];\n    var __ATMAIN__ = [];\n    var __ATPOSTRUN__ = [];\n    var runtimeInitialized = false;\n\n    function preRun() {\n      if (Module[\"preRun\"]) {\n        if (typeof Module[\"preRun\"] == \"function\") Module[\"preRun\"] = [Module[\"preRun\"]];\n\n        while (Module[\"preRun\"].length) {\n          addOnPreRun(Module[\"preRun\"].shift());\n        }\n      }\n\n      callRuntimeCallbacks(__ATPRERUN__);\n    }\n\n    function ensureInitRuntime() {\n      if (runtimeInitialized) return;\n      runtimeInitialized = true;\n      if (!Module[\"noFSInit\"] && !FS.init.initialized) FS.init();\n      TTY.init();\n      callRuntimeCallbacks(__ATINIT__);\n    }\n\n    function preMain() {\n      FS.ignorePermissions = false;\n      callRuntimeCallbacks(__ATMAIN__);\n    }\n\n    function postRun() {\n      if (Module[\"postRun\"]) {\n        if (typeof Module[\"postRun\"] == \"function\") Module[\"postRun\"] = [Module[\"postRun\"]];\n\n        while (Module[\"postRun\"].length) {\n          addOnPostRun(Module[\"postRun\"].shift());\n        }\n      }\n\n      callRuntimeCallbacks(__ATPOSTRUN__);\n    }\n\n    function addOnPreRun(cb) {\n      __ATPRERUN__.unshift(cb);\n    }\n\n    function addOnPreMain(cb) {\n      __ATMAIN__.unshift(cb);\n    }\n\n    function addOnPostRun(cb) {\n      __ATPOSTRUN__.unshift(cb);\n    }\n\n    var Math_abs = Math.abs;\n    var Math_cos = Math.cos;\n    var Math_sin = Math.sin;\n    var Math_ceil = Math.ceil;\n    var Math_floor = Math.floor;\n    var Math_min = Math.min;\n    var runDependencies = 0;\n    var runDependencyWatcher = null;\n    var dependenciesFulfilled = null;\n\n    function getUniqueRunDependency(id) {\n      return id;\n    }\n\n    function addRunDependency(id) {\n      runDependencies++;\n\n      if (Module[\"monitorRunDependencies\"]) {\n        Module[\"monitorRunDependencies\"](runDependencies);\n      }\n    }\n\n    function removeRunDependency(id) {\n      runDependencies--;\n\n      if (Module[\"monitorRunDependencies\"]) {\n        Module[\"monitorRunDependencies\"](runDependencies);\n      }\n\n      if (runDependencies == 0) {\n        if (runDependencyWatcher !== null) {\n          clearInterval(runDependencyWatcher);\n          runDependencyWatcher = null;\n        }\n\n        if (dependenciesFulfilled) {\n          var callback = dependenciesFulfilled;\n          dependenciesFulfilled = null;\n          callback();\n        }\n      }\n    }\n\n    Module[\"preloadedImages\"] = {};\n    Module[\"preloadedAudios\"] = {};\n    var dataURIPrefix = \"data:application/octet-stream;base64,\";\n\n    function isDataURI(filename) {\n      return String.prototype.startsWith ? filename.startsWith(dataURIPrefix) : filename.indexOf(dataURIPrefix) === 0;\n    }\n\n    var wasmBinaryFile = \"VectorizeCore.wasm\";\n\n    if (!isDataURI(wasmBinaryFile)) {\n      wasmBinaryFile = locateFile(wasmBinaryFile);\n    }\n\n    function getBinary() {\n      try {\n        if (Module[\"wasmBinary\"]) {\n          return new Uint8Array(Module[\"wasmBinary\"]);\n        }\n\n        if (Module[\"readBinary\"]) {\n          return Module[\"readBinary\"](wasmBinaryFile);\n        } else {\n          throw \"both async and sync fetching of the wasm failed\";\n        }\n      } catch (err) {\n        abort(err);\n      }\n    }\n\n    function getBinaryPromise() {\n      if (!Module[\"wasmBinary\"] && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === 'function') {\n        if (window.location.protocol !== 'file:') {\n          return fetch(wasmBinaryFile, {\n            credentials: \"same-origin\"\n          }).then(function (response) {\n            if (!response[\"ok\"]) {\n              throw \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\";\n            }\n\n            return response[\"arrayBuffer\"]();\n          }).catch(function () {\n            return getBinary();\n          });\n        } else {\n          return new Promise(resolve => {\n            Module['readAsync'](wasmBinaryFile, src => {\n              resolve(src);\n            });\n          });\n        }\n      }\n\n      return new Promise(function (resolve, reject) {\n        resolve(getBinary());\n      });\n    }\n\n    function createWasm(env) {\n      var info = {\n        \"env\": env,\n        \"global\": {\n          \"NaN\": NaN,\n          Infinity: Infinity\n        },\n        \"global.Math\": Math,\n        \"asm2wasm\": asm2wasmImports\n      };\n\n      function receiveInstance(instance, module) {\n        var exports = instance.exports;\n        Module[\"asm\"] = exports;\n        removeRunDependency(\"wasm-instantiate\");\n      }\n\n      addRunDependency(\"wasm-instantiate\");\n\n      if (Module[\"instantiateWasm\"]) {\n        try {\n          return Module[\"instantiateWasm\"](info, receiveInstance);\n        } catch (e) {\n          err(\"Module.instantiateWasm callback failed with error: \" + e);\n          return false;\n        }\n      }\n\n      function receiveInstantiatedSource(output) {\n        receiveInstance(output[\"instance\"]);\n      }\n\n      function instantiateArrayBuffer(receiver) {\n        getBinaryPromise().then(function (binary) {\n          return WebAssembly.instantiate(binary, info);\n        }).then(receiver, function (reason) {\n          err(\"failed to asynchronously prepare wasm: \" + reason);\n          abort(reason);\n        });\n      }\n\n      if (!Module[\"wasmBinary\"] && typeof WebAssembly.instantiateStreaming === \"function\" && !isDataURI(wasmBinaryFile) && typeof fetch === \"function\" && window.location.protocol !== 'file:') {\n        WebAssembly.instantiateStreaming(fetch(wasmBinaryFile, {\n          credentials: \"same-origin\"\n        }), info).then(receiveInstantiatedSource, function (reason) {\n          err(\"wasm streaming compile failed: \" + reason);\n          err(\"falling back to ArrayBuffer instantiation\");\n          instantiateArrayBuffer(receiveInstantiatedSource);\n        });\n      } else {\n        instantiateArrayBuffer(receiveInstantiatedSource);\n      }\n\n      return {};\n    }\n\n    Module[\"asm\"] = function (global, env, providedBuffer) {\n      env[\"memory\"] = wasmMemory;\n      env[\"table\"] = wasmTable = new WebAssembly.Table({\n        \"initial\": 186,\n        \"maximum\": 186,\n        \"element\": \"anyfunc\"\n      });\n      env[\"__memory_base\"] = 1024;\n      env[\"__table_base\"] = 0;\n      var exports = createWasm(env);\n      return exports;\n    };\n\n    __ATINIT__.push({\n      func: function () {\n        __GLOBAL__sub_I_CubicSolver_cpp();\n      }\n    });\n\n    function ___assert_fail(condition, filename, line, func) {\n      abort(\"Assertion failed: \" + UTF8ToString(condition) + \", at: \" + [filename ? UTF8ToString(filename) : \"unknown filename\", line, func ? UTF8ToString(func) : \"unknown function\"]);\n    }\n\n    function ___cxa_allocate_exception(size) {\n      return _malloc(size);\n    }\n\n    function __ZSt18uncaught_exceptionv() {\n      return !!__ZSt18uncaught_exceptionv.uncaught_exception;\n    }\n\n    function ___cxa_free_exception(ptr) {\n      try {\n        return _free(ptr);\n      } catch (e) {}\n    }\n\n    var EXCEPTIONS = {\n      last: 0,\n      caught: [],\n      infos: {},\n      deAdjust: function (adjusted) {\n        if (!adjusted || EXCEPTIONS.infos[adjusted]) return adjusted;\n\n        for (var key in EXCEPTIONS.infos) {\n          var ptr = +key;\n          var adj = EXCEPTIONS.infos[ptr].adjusted;\n          var len = adj.length;\n\n          for (var i = 0; i < len; i++) {\n            if (adj[i] === adjusted) {\n              return ptr;\n            }\n          }\n        }\n\n        return adjusted;\n      },\n      addRef: function (ptr) {\n        if (!ptr) return;\n        var info = EXCEPTIONS.infos[ptr];\n        info.refcount++;\n      },\n      decRef: function (ptr) {\n        if (!ptr) return;\n        var info = EXCEPTIONS.infos[ptr];\n        assert(info.refcount > 0);\n        info.refcount--;\n\n        if (info.refcount === 0 && !info.rethrown) {\n          if (info.destructor) {\n            Module[\"dynCall_vi\"](info.destructor, ptr);\n          }\n\n          delete EXCEPTIONS.infos[ptr];\n\n          ___cxa_free_exception(ptr);\n        }\n      },\n      clearRef: function (ptr) {\n        if (!ptr) return;\n        var info = EXCEPTIONS.infos[ptr];\n        info.refcount = 0;\n      }\n    };\n\n    function ___cxa_pure_virtual() {\n      ABORT = true;\n      throw \"Pure virtual function called!\";\n    }\n\n    function ___cxa_throw(ptr, type, destructor) {\n      EXCEPTIONS.infos[ptr] = {\n        ptr: ptr,\n        adjusted: [ptr],\n        type: type,\n        destructor: destructor,\n        refcount: 0,\n        caught: false,\n        rethrown: false\n      };\n      EXCEPTIONS.last = ptr;\n\n      if (!(\"uncaught_exception\" in __ZSt18uncaught_exceptionv)) {\n        __ZSt18uncaught_exceptionv.uncaught_exception = 1;\n      } else {\n        __ZSt18uncaught_exceptionv.uncaught_exception++;\n      }\n\n      throw ptr;\n    }\n\n    function ___lock() {}\n\n    function ___setErrNo(value) {\n      if (Module[\"___errno_location\"]) HEAP32[Module[\"___errno_location\"]() >> 2] = value;\n      return value;\n    }\n\n    var PATH = {\n      splitPath: function (filename) {\n        var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n        return splitPathRe.exec(filename).slice(1);\n      },\n      normalizeArray: function (parts, allowAboveRoot) {\n        var up = 0;\n\n        for (var i = parts.length - 1; i >= 0; i--) {\n          var last = parts[i];\n\n          if (last === \".\") {\n            parts.splice(i, 1);\n          } else if (last === \"..\") {\n            parts.splice(i, 1);\n            up++;\n          } else if (up) {\n            parts.splice(i, 1);\n            up--;\n          }\n        }\n\n        if (allowAboveRoot) {\n          for (; up; up--) {\n            parts.unshift(\"..\");\n          }\n        }\n\n        return parts;\n      },\n      normalize: function (path) {\n        var isAbsolute = path.charAt(0) === \"/\",\n            trailingSlash = path.substr(-1) === \"/\";\n        path = PATH.normalizeArray(path.split(\"/\").filter(function (p) {\n          return !!p;\n        }), !isAbsolute).join(\"/\");\n\n        if (!path && !isAbsolute) {\n          path = \".\";\n        }\n\n        if (path && trailingSlash) {\n          path += \"/\";\n        }\n\n        return (isAbsolute ? \"/\" : \"\") + path;\n      },\n      dirname: function (path) {\n        var result = PATH.splitPath(path),\n            root = result[0],\n            dir = result[1];\n\n        if (!root && !dir) {\n          return \".\";\n        }\n\n        if (dir) {\n          dir = dir.substr(0, dir.length - 1);\n        }\n\n        return root + dir;\n      },\n      basename: function (path) {\n        if (path === \"/\") return \"/\";\n        var lastSlash = path.lastIndexOf(\"/\");\n        if (lastSlash === -1) return path;\n        return path.substr(lastSlash + 1);\n      },\n      extname: function (path) {\n        return PATH.splitPath(path)[3];\n      },\n      join: function () {\n        var paths = Array.prototype.slice.call(arguments, 0);\n        return PATH.normalize(paths.join(\"/\"));\n      },\n      join2: function (l, r) {\n        return PATH.normalize(l + \"/\" + r);\n      },\n      resolve: function () {\n        var resolvedPath = \"\",\n            resolvedAbsolute = false;\n\n        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n          var path = i >= 0 ? arguments[i] : FS.cwd();\n\n          if (typeof path !== \"string\") {\n            throw new TypeError(\"Arguments to path.resolve must be strings\");\n          } else if (!path) {\n            return \"\";\n          }\n\n          resolvedPath = path + \"/\" + resolvedPath;\n          resolvedAbsolute = path.charAt(0) === \"/\";\n        }\n\n        resolvedPath = PATH.normalizeArray(resolvedPath.split(\"/\").filter(function (p) {\n          return !!p;\n        }), !resolvedAbsolute).join(\"/\");\n        return (resolvedAbsolute ? \"/\" : \"\") + resolvedPath || \".\";\n      },\n      relative: function (from, to) {\n        from = PATH.resolve(from).substr(1);\n        to = PATH.resolve(to).substr(1);\n\n        function trim(arr) {\n          var start = 0;\n\n          for (; start < arr.length; start++) {\n            if (arr[start] !== \"\") break;\n          }\n\n          var end = arr.length - 1;\n\n          for (; end >= 0; end--) {\n            if (arr[end] !== \"\") break;\n          }\n\n          if (start > end) return [];\n          return arr.slice(start, end - start + 1);\n        }\n\n        var fromParts = trim(from.split(\"/\"));\n        var toParts = trim(to.split(\"/\"));\n        var length = Math.min(fromParts.length, toParts.length);\n        var samePartsLength = length;\n\n        for (var i = 0; i < length; i++) {\n          if (fromParts[i] !== toParts[i]) {\n            samePartsLength = i;\n            break;\n          }\n        }\n\n        var outputParts = [];\n\n        for (var i = samePartsLength; i < fromParts.length; i++) {\n          outputParts.push(\"..\");\n        }\n\n        outputParts = outputParts.concat(toParts.slice(samePartsLength));\n        return outputParts.join(\"/\");\n      }\n    };\n    var TTY = {\n      ttys: [],\n      init: function () {},\n      shutdown: function () {},\n      register: function (dev, ops) {\n        TTY.ttys[dev] = {\n          input: [],\n          output: [],\n          ops: ops\n        };\n        FS.registerDevice(dev, TTY.stream_ops);\n      },\n      stream_ops: {\n        open: function (stream) {\n          var tty = TTY.ttys[stream.node.rdev];\n\n          if (!tty) {\n            throw new FS.ErrnoError(ERRNO_CODES.ENODEV);\n          }\n\n          stream.tty = tty;\n          stream.seekable = false;\n        },\n        close: function (stream) {\n          stream.tty.ops.flush(stream.tty);\n        },\n        flush: function (stream) {\n          stream.tty.ops.flush(stream.tty);\n        },\n        read: function (stream, buffer, offset, length, pos) {\n          if (!stream.tty || !stream.tty.ops.get_char) {\n            throw new FS.ErrnoError(ERRNO_CODES.ENXIO);\n          }\n\n          var bytesRead = 0;\n\n          for (var i = 0; i < length; i++) {\n            var result;\n\n            try {\n              result = stream.tty.ops.get_char(stream.tty);\n            } catch (e) {\n              throw new FS.ErrnoError(ERRNO_CODES.EIO);\n            }\n\n            if (result === undefined && bytesRead === 0) {\n              throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);\n            }\n\n            if (result === null || result === undefined) break;\n            bytesRead++;\n            buffer[offset + i] = result;\n          }\n\n          if (bytesRead) {\n            stream.node.timestamp = Date.now();\n          }\n\n          return bytesRead;\n        },\n        write: function (stream, buffer, offset, length, pos) {\n          if (!stream.tty || !stream.tty.ops.put_char) {\n            throw new FS.ErrnoError(ERRNO_CODES.ENXIO);\n          }\n\n          try {\n            for (var i = 0; i < length; i++) {\n              stream.tty.ops.put_char(stream.tty, buffer[offset + i]);\n            }\n          } catch (e) {\n            throw new FS.ErrnoError(ERRNO_CODES.EIO);\n          }\n\n          if (length) {\n            stream.node.timestamp = Date.now();\n          }\n\n          return i;\n        }\n      },\n      default_tty_ops: {\n        get_char: function (tty) {\n          if (!tty.input.length) {\n            var result = null;\n\n            if (ENVIRONMENT_IS_NODE) {\n              var BUFSIZE = 256;\n              var buf = new Buffer(BUFSIZE);\n              var bytesRead = 0;\n              var isPosixPlatform = process.platform != \"win32\";\n              var fd = process.stdin.fd;\n\n              if (isPosixPlatform) {\n                var usingDevice = false;\n\n                try {\n                  fd = fs.openSync(\"/dev/stdin\", \"r\");\n                  usingDevice = true;\n                } catch (e) {}\n              }\n\n              try {\n                bytesRead = fs.readSync(fd, buf, 0, BUFSIZE, null);\n              } catch (e) {\n                if (e.toString().indexOf(\"EOF\") != -1) bytesRead = 0;else throw e;\n              }\n\n              if (usingDevice) {\n                fs.closeSync(fd);\n              }\n\n              if (bytesRead > 0) {\n                result = buf.slice(0, bytesRead).toString(\"utf-8\");\n              } else {\n                result = null;\n              }\n            } else if (typeof window != \"undefined\" && typeof window.prompt == \"function\") {\n              result = window.prompt(\"Input: \");\n\n              if (result !== null) {\n                result += \"\\n\";\n              }\n            } else if (typeof readline == \"function\") {\n              result = readline();\n\n              if (result !== null) {\n                result += \"\\n\";\n              }\n            }\n\n            if (!result) {\n              return null;\n            }\n\n            tty.input = intArrayFromString(result, true);\n          }\n\n          return tty.input.shift();\n        },\n        put_char: function (tty, val) {\n          if (val === null || val === 10) {\n            out(UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          } else {\n            if (val != 0) tty.output.push(val);\n          }\n        },\n        flush: function (tty) {\n          if (tty.output && tty.output.length > 0) {\n            out(UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          }\n        }\n      },\n      default_tty1_ops: {\n        put_char: function (tty, val) {\n          if (val === null || val === 10) {\n            err(UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          } else {\n            if (val != 0) tty.output.push(val);\n          }\n        },\n        flush: function (tty) {\n          if (tty.output && tty.output.length > 0) {\n            err(UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          }\n        }\n      }\n    };\n    var MEMFS = {\n      ops_table: null,\n      mount: function (mount) {\n        return MEMFS.createNode(null, \"/\", 16384 | 511, 0);\n      },\n      createNode: function (parent, name, mode, dev) {\n        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        }\n\n        if (!MEMFS.ops_table) {\n          MEMFS.ops_table = {\n            dir: {\n              node: {\n                getattr: MEMFS.node_ops.getattr,\n                setattr: MEMFS.node_ops.setattr,\n                lookup: MEMFS.node_ops.lookup,\n                mknod: MEMFS.node_ops.mknod,\n                rename: MEMFS.node_ops.rename,\n                unlink: MEMFS.node_ops.unlink,\n                rmdir: MEMFS.node_ops.rmdir,\n                readdir: MEMFS.node_ops.readdir,\n                symlink: MEMFS.node_ops.symlink\n              },\n              stream: {\n                llseek: MEMFS.stream_ops.llseek\n              }\n            },\n            file: {\n              node: {\n                getattr: MEMFS.node_ops.getattr,\n                setattr: MEMFS.node_ops.setattr\n              },\n              stream: {\n                llseek: MEMFS.stream_ops.llseek,\n                read: MEMFS.stream_ops.read,\n                write: MEMFS.stream_ops.write,\n                allocate: MEMFS.stream_ops.allocate,\n                mmap: MEMFS.stream_ops.mmap,\n                msync: MEMFS.stream_ops.msync\n              }\n            },\n            link: {\n              node: {\n                getattr: MEMFS.node_ops.getattr,\n                setattr: MEMFS.node_ops.setattr,\n                readlink: MEMFS.node_ops.readlink\n              },\n              stream: {}\n            },\n            chrdev: {\n              node: {\n                getattr: MEMFS.node_ops.getattr,\n                setattr: MEMFS.node_ops.setattr\n              },\n              stream: FS.chrdev_stream_ops\n            }\n          };\n        }\n\n        var node = FS.createNode(parent, name, mode, dev);\n\n        if (FS.isDir(node.mode)) {\n          node.node_ops = MEMFS.ops_table.dir.node;\n          node.stream_ops = MEMFS.ops_table.dir.stream;\n          node.contents = {};\n        } else if (FS.isFile(node.mode)) {\n          node.node_ops = MEMFS.ops_table.file.node;\n          node.stream_ops = MEMFS.ops_table.file.stream;\n          node.usedBytes = 0;\n          node.contents = null;\n        } else if (FS.isLink(node.mode)) {\n          node.node_ops = MEMFS.ops_table.link.node;\n          node.stream_ops = MEMFS.ops_table.link.stream;\n        } else if (FS.isChrdev(node.mode)) {\n          node.node_ops = MEMFS.ops_table.chrdev.node;\n          node.stream_ops = MEMFS.ops_table.chrdev.stream;\n        }\n\n        node.timestamp = Date.now();\n\n        if (parent) {\n          parent.contents[name] = node;\n        }\n\n        return node;\n      },\n      getFileDataAsRegularArray: function (node) {\n        if (node.contents && node.contents.subarray) {\n          var arr = [];\n\n          for (var i = 0; i < node.usedBytes; ++i) arr.push(node.contents[i]);\n\n          return arr;\n        }\n\n        return node.contents;\n      },\n      getFileDataAsTypedArray: function (node) {\n        if (!node.contents) return new Uint8Array();\n        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes);\n        return new Uint8Array(node.contents);\n      },\n      expandFileStorage: function (node, newCapacity) {\n        var prevCapacity = node.contents ? node.contents.length : 0;\n        if (prevCapacity >= newCapacity) return;\n        var CAPACITY_DOUBLING_MAX = 1024 * 1024;\n        newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) | 0);\n        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);\n        var oldContents = node.contents;\n        node.contents = new Uint8Array(newCapacity);\n        if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0);\n        return;\n      },\n      resizeFileStorage: function (node, newSize) {\n        if (node.usedBytes == newSize) return;\n\n        if (newSize == 0) {\n          node.contents = null;\n          node.usedBytes = 0;\n          return;\n        }\n\n        if (!node.contents || node.contents.subarray) {\n          var oldContents = node.contents;\n          node.contents = new Uint8Array(new ArrayBuffer(newSize));\n\n          if (oldContents) {\n            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));\n          }\n\n          node.usedBytes = newSize;\n          return;\n        }\n\n        if (!node.contents) node.contents = [];\n        if (node.contents.length > newSize) node.contents.length = newSize;else while (node.contents.length < newSize) node.contents.push(0);\n        node.usedBytes = newSize;\n      },\n      node_ops: {\n        getattr: function (node) {\n          var attr = {};\n          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\n          attr.ino = node.id;\n          attr.mode = node.mode;\n          attr.nlink = 1;\n          attr.uid = 0;\n          attr.gid = 0;\n          attr.rdev = node.rdev;\n\n          if (FS.isDir(node.mode)) {\n            attr.size = 4096;\n          } else if (FS.isFile(node.mode)) {\n            attr.size = node.usedBytes;\n          } else if (FS.isLink(node.mode)) {\n            attr.size = node.link.length;\n          } else {\n            attr.size = 0;\n          }\n\n          attr.atime = new Date(node.timestamp);\n          attr.mtime = new Date(node.timestamp);\n          attr.ctime = new Date(node.timestamp);\n          attr.blksize = 4096;\n          attr.blocks = Math.ceil(attr.size / attr.blksize);\n          return attr;\n        },\n        setattr: function (node, attr) {\n          if (attr.mode !== undefined) {\n            node.mode = attr.mode;\n          }\n\n          if (attr.timestamp !== undefined) {\n            node.timestamp = attr.timestamp;\n          }\n\n          if (attr.size !== undefined) {\n            MEMFS.resizeFileStorage(node, attr.size);\n          }\n        },\n        lookup: function (parent, name) {\n          throw FS.genericErrors[ERRNO_CODES.ENOENT];\n        },\n        mknod: function (parent, name, mode, dev) {\n          return MEMFS.createNode(parent, name, mode, dev);\n        },\n        rename: function (old_node, new_dir, new_name) {\n          if (FS.isDir(old_node.mode)) {\n            var new_node;\n\n            try {\n              new_node = FS.lookupNode(new_dir, new_name);\n            } catch (e) {}\n\n            if (new_node) {\n              for (var i in new_node.contents) {\n                throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);\n              }\n            }\n          }\n\n          delete old_node.parent.contents[old_node.name];\n          old_node.name = new_name;\n          new_dir.contents[new_name] = old_node;\n          old_node.parent = new_dir;\n        },\n        unlink: function (parent, name) {\n          delete parent.contents[name];\n        },\n        rmdir: function (parent, name) {\n          var node = FS.lookupNode(parent, name);\n\n          for (var i in node.contents) {\n            throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);\n          }\n\n          delete parent.contents[name];\n        },\n        readdir: function (node) {\n          var entries = [\".\", \"..\"];\n\n          for (var key in node.contents) {\n            if (!node.contents.hasOwnProperty(key)) {\n              continue;\n            }\n\n            entries.push(key);\n          }\n\n          return entries;\n        },\n        symlink: function (parent, newname, oldpath) {\n          var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);\n          node.link = oldpath;\n          return node;\n        },\n        readlink: function (node) {\n          if (!FS.isLink(node.mode)) {\n            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n          }\n\n          return node.link;\n        }\n      },\n      stream_ops: {\n        read: function (stream, buffer, offset, length, position) {\n          var contents = stream.node.contents;\n          if (position >= stream.node.usedBytes) return 0;\n          var size = Math.min(stream.node.usedBytes - position, length);\n\n          if (size > 8 && contents.subarray) {\n            buffer.set(contents.subarray(position, position + size), offset);\n          } else {\n            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];\n          }\n\n          return size;\n        },\n        write: function (stream, buffer, offset, length, position, canOwn) {\n          canOwn = false;\n          if (!length) return 0;\n          var node = stream.node;\n          node.timestamp = Date.now();\n\n          if (buffer.subarray && (!node.contents || node.contents.subarray)) {\n            if (canOwn) {\n              node.contents = buffer.subarray(offset, offset + length);\n              node.usedBytes = length;\n              return length;\n            } else if (node.usedBytes === 0 && position === 0) {\n              node.contents = new Uint8Array(buffer.subarray(offset, offset + length));\n              node.usedBytes = length;\n              return length;\n            } else if (position + length <= node.usedBytes) {\n              node.contents.set(buffer.subarray(offset, offset + length), position);\n              return length;\n            }\n          }\n\n          MEMFS.expandFileStorage(node, position + length);\n          if (node.contents.subarray && buffer.subarray) node.contents.set(buffer.subarray(offset, offset + length), position);else {\n            for (var i = 0; i < length; i++) {\n              node.contents[position + i] = buffer[offset + i];\n            }\n          }\n          node.usedBytes = Math.max(node.usedBytes, position + length);\n          return length;\n        },\n        llseek: function (stream, offset, whence) {\n          var position = offset;\n\n          if (whence === 1) {\n            position += stream.position;\n          } else if (whence === 2) {\n            if (FS.isFile(stream.node.mode)) {\n              position += stream.node.usedBytes;\n            }\n          }\n\n          if (position < 0) {\n            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n          }\n\n          return position;\n        },\n        allocate: function (stream, offset, length) {\n          MEMFS.expandFileStorage(stream.node, offset + length);\n          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);\n        },\n        mmap: function (stream, buffer, offset, length, position, prot, flags) {\n          if (!FS.isFile(stream.node.mode)) {\n            throw new FS.ErrnoError(ERRNO_CODES.ENODEV);\n          }\n\n          var ptr;\n          var allocated;\n          var contents = stream.node.contents;\n\n          if (!(flags & 2) && (contents.buffer === buffer || contents.buffer === buffer.buffer)) {\n            allocated = false;\n            ptr = contents.byteOffset;\n          } else {\n            if (position > 0 || position + length < stream.node.usedBytes) {\n              if (contents.subarray) {\n                contents = contents.subarray(position, position + length);\n              } else {\n                contents = Array.prototype.slice.call(contents, position, position + length);\n              }\n            }\n\n            allocated = true;\n            ptr = _malloc(length);\n\n            if (!ptr) {\n              throw new FS.ErrnoError(ERRNO_CODES.ENOMEM);\n            }\n\n            buffer.set(contents, ptr);\n          }\n\n          return {\n            ptr: ptr,\n            allocated: allocated\n          };\n        },\n        msync: function (stream, buffer, offset, length, mmapFlags) {\n          if (!FS.isFile(stream.node.mode)) {\n            throw new FS.ErrnoError(ERRNO_CODES.ENODEV);\n          }\n\n          if (mmapFlags & 2) {\n            return 0;\n          }\n\n          var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\n          return 0;\n        }\n      }\n    };\n    var IDBFS = {\n      dbs: {},\n      indexedDB: function () {\n        if (typeof indexedDB !== \"undefined\") return indexedDB;\n        var ret = null;\n        if (typeof window === \"object\") ret = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\n        assert(ret, \"IDBFS used, but indexedDB not supported\");\n        return ret;\n      },\n      DB_VERSION: 21,\n      DB_STORE_NAME: \"FILE_DATA\",\n      mount: function (mount) {\n        return MEMFS.mount.apply(null, arguments);\n      },\n      syncfs: function (mount, populate, callback) {\n        IDBFS.getLocalSet(mount, function (err, local) {\n          if (err) return callback(err);\n          IDBFS.getRemoteSet(mount, function (err, remote) {\n            if (err) return callback(err);\n            var src = populate ? remote : local;\n            var dst = populate ? local : remote;\n            IDBFS.reconcile(src, dst, callback);\n          });\n        });\n      },\n      getDB: function (name, callback) {\n        var db = IDBFS.dbs[name];\n\n        if (db) {\n          return callback(null, db);\n        }\n\n        var req;\n\n        try {\n          req = IDBFS.indexedDB().open(name, IDBFS.DB_VERSION);\n        } catch (e) {\n          return callback(e);\n        }\n\n        if (!req) {\n          return callback(\"Unable to connect to IndexedDB\");\n        }\n\n        req.onupgradeneeded = function (e) {\n          var db = e.target.result;\n          var transaction = e.target.transaction;\n          var fileStore;\n\n          if (db.objectStoreNames.contains(IDBFS.DB_STORE_NAME)) {\n            fileStore = transaction.objectStore(IDBFS.DB_STORE_NAME);\n          } else {\n            fileStore = db.createObjectStore(IDBFS.DB_STORE_NAME);\n          }\n\n          if (!fileStore.indexNames.contains(\"timestamp\")) {\n            fileStore.createIndex(\"timestamp\", \"timestamp\", {\n              unique: false\n            });\n          }\n        };\n\n        req.onsuccess = function () {\n          db = req.result;\n          IDBFS.dbs[name] = db;\n          callback(null, db);\n        };\n\n        req.onerror = function (e) {\n          callback(this.error);\n          e.preventDefault();\n        };\n      },\n      getLocalSet: function (mount, callback) {\n        var entries = {};\n\n        function isRealDir(p) {\n          return p !== \".\" && p !== \"..\";\n        }\n\n        function toAbsolute(root) {\n          return function (p) {\n            return PATH.join2(root, p);\n          };\n        }\n\n        var check = FS.readdir(mount.mountpoint).filter(isRealDir).map(toAbsolute(mount.mountpoint));\n\n        while (check.length) {\n          var path = check.pop();\n          var stat;\n\n          try {\n            stat = FS.stat(path);\n          } catch (e) {\n            return callback(e);\n          }\n\n          if (FS.isDir(stat.mode)) {\n            check.push.apply(check, FS.readdir(path).filter(isRealDir).map(toAbsolute(path)));\n          }\n\n          entries[path] = {\n            timestamp: stat.mtime\n          };\n        }\n\n        return callback(null, {\n          type: \"local\",\n          entries: entries\n        });\n      },\n      getRemoteSet: function (mount, callback) {\n        var entries = {};\n        IDBFS.getDB(mount.mountpoint, function (err, db) {\n          if (err) return callback(err);\n\n          try {\n            var transaction = db.transaction([IDBFS.DB_STORE_NAME], \"readonly\");\n\n            transaction.onerror = function (e) {\n              callback(this.error);\n              e.preventDefault();\n            };\n\n            var store = transaction.objectStore(IDBFS.DB_STORE_NAME);\n            var index = store.index(\"timestamp\");\n\n            index.openKeyCursor().onsuccess = function (event) {\n              var cursor = event.target.result;\n\n              if (!cursor) {\n                return callback(null, {\n                  type: \"remote\",\n                  db: db,\n                  entries: entries\n                });\n              }\n\n              entries[cursor.primaryKey] = {\n                timestamp: cursor.key\n              };\n              cursor.continue();\n            };\n          } catch (e) {\n            return callback(e);\n          }\n        });\n      },\n      loadLocalEntry: function (path, callback) {\n        var stat, node;\n\n        try {\n          var lookup = FS.lookupPath(path);\n          node = lookup.node;\n          stat = FS.stat(path);\n        } catch (e) {\n          return callback(e);\n        }\n\n        if (FS.isDir(stat.mode)) {\n          return callback(null, {\n            timestamp: stat.mtime,\n            mode: stat.mode\n          });\n        } else if (FS.isFile(stat.mode)) {\n          node.contents = MEMFS.getFileDataAsTypedArray(node);\n          return callback(null, {\n            timestamp: stat.mtime,\n            mode: stat.mode,\n            contents: node.contents\n          });\n        } else {\n          return callback(new Error(\"node type not supported\"));\n        }\n      },\n      storeLocalEntry: function (path, entry, callback) {\n        try {\n          if (FS.isDir(entry.mode)) {\n            FS.mkdir(path, entry.mode);\n          } else if (FS.isFile(entry.mode)) {\n            FS.writeFile(path, entry.contents, {\n              canOwn: true\n            });\n          } else {\n            return callback(new Error(\"node type not supported\"));\n          }\n\n          FS.chmod(path, entry.mode);\n          FS.utime(path, entry.timestamp, entry.timestamp);\n        } catch (e) {\n          return callback(e);\n        }\n\n        callback(null);\n      },\n      removeLocalEntry: function (path, callback) {\n        try {\n          var lookup = FS.lookupPath(path);\n          var stat = FS.stat(path);\n\n          if (FS.isDir(stat.mode)) {\n            FS.rmdir(path);\n          } else if (FS.isFile(stat.mode)) {\n            FS.unlink(path);\n          }\n        } catch (e) {\n          return callback(e);\n        }\n\n        callback(null);\n      },\n      loadRemoteEntry: function (store, path, callback) {\n        var req = store.get(path);\n\n        req.onsuccess = function (event) {\n          callback(null, event.target.result);\n        };\n\n        req.onerror = function (e) {\n          callback(this.error);\n          e.preventDefault();\n        };\n      },\n      storeRemoteEntry: function (store, path, entry, callback) {\n        var req = store.put(entry, path);\n\n        req.onsuccess = function () {\n          callback(null);\n        };\n\n        req.onerror = function (e) {\n          callback(this.error);\n          e.preventDefault();\n        };\n      },\n      removeRemoteEntry: function (store, path, callback) {\n        var req = store.delete(path);\n\n        req.onsuccess = function () {\n          callback(null);\n        };\n\n        req.onerror = function (e) {\n          callback(this.error);\n          e.preventDefault();\n        };\n      },\n      reconcile: function (src, dst, callback) {\n        var total = 0;\n        var create = [];\n        Object.keys(src.entries).forEach(function (key) {\n          var e = src.entries[key];\n          var e2 = dst.entries[key];\n\n          if (!e2 || e.timestamp > e2.timestamp) {\n            create.push(key);\n            total++;\n          }\n        });\n        var remove = [];\n        Object.keys(dst.entries).forEach(function (key) {\n          var e = dst.entries[key];\n          var e2 = src.entries[key];\n\n          if (!e2) {\n            remove.push(key);\n            total++;\n          }\n        });\n\n        if (!total) {\n          return callback(null);\n        }\n\n        var errored = false;\n        var completed = 0;\n        var db = src.type === \"remote\" ? src.db : dst.db;\n        var transaction = db.transaction([IDBFS.DB_STORE_NAME], \"readwrite\");\n        var store = transaction.objectStore(IDBFS.DB_STORE_NAME);\n\n        function done(err) {\n          if (err) {\n            if (!done.errored) {\n              done.errored = true;\n              return callback(err);\n            }\n\n            return;\n          }\n\n          if (++completed >= total) {\n            return callback(null);\n          }\n        }\n\n        transaction.onerror = function (e) {\n          done(this.error);\n          e.preventDefault();\n        };\n\n        create.sort().forEach(function (path) {\n          if (dst.type === \"local\") {\n            IDBFS.loadRemoteEntry(store, path, function (err, entry) {\n              if (err) return done(err);\n              IDBFS.storeLocalEntry(path, entry, done);\n            });\n          } else {\n            IDBFS.loadLocalEntry(path, function (err, entry) {\n              if (err) return done(err);\n              IDBFS.storeRemoteEntry(store, path, entry, done);\n            });\n          }\n        });\n        remove.sort().reverse().forEach(function (path) {\n          if (dst.type === \"local\") {\n            IDBFS.removeLocalEntry(path, done);\n          } else {\n            IDBFS.removeRemoteEntry(store, path, done);\n          }\n        });\n      }\n    };\n    var NODEFS = {\n      isWindows: false,\n      staticInit: function () {\n        NODEFS.isWindows = !!process.platform.match(/^win/);\n        var flags = process[\"binding\"](\"constants\");\n\n        if (flags[\"fs\"]) {\n          flags = flags[\"fs\"];\n        }\n\n        NODEFS.flagsForNodeMap = {\n          1024: flags[\"O_APPEND\"],\n          64: flags[\"O_CREAT\"],\n          128: flags[\"O_EXCL\"],\n          0: flags[\"O_RDONLY\"],\n          2: flags[\"O_RDWR\"],\n          4096: flags[\"O_SYNC\"],\n          512: flags[\"O_TRUNC\"],\n          1: flags[\"O_WRONLY\"]\n        };\n      },\n      bufferFrom: function (arrayBuffer) {\n        return Buffer.alloc ? Buffer.from(arrayBuffer) : new Buffer(arrayBuffer);\n      },\n      mount: function (mount) {\n        assert(ENVIRONMENT_IS_NODE);\n        return NODEFS.createNode(null, \"/\", NODEFS.getMode(mount.opts.root), 0);\n      },\n      createNode: function (parent, name, mode, dev) {\n        if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n        }\n\n        var node = FS.createNode(parent, name, mode);\n        node.node_ops = NODEFS.node_ops;\n        node.stream_ops = NODEFS.stream_ops;\n        return node;\n      },\n      getMode: function (path) {\n        var stat;\n\n        try {\n          stat = fs.lstatSync(path);\n\n          if (NODEFS.isWindows) {\n            stat.mode = stat.mode | (stat.mode & 292) >> 2;\n          }\n        } catch (e) {\n          if (!e.code) throw e;\n          throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n        }\n\n        return stat.mode;\n      },\n      realPath: function (node) {\n        var parts = [];\n\n        while (node.parent !== node) {\n          parts.push(node.name);\n          node = node.parent;\n        }\n\n        parts.push(node.mount.opts.root);\n        parts.reverse();\n        return PATH.join.apply(null, parts);\n      },\n      flagsForNode: function (flags) {\n        flags &= ~2097152;\n        flags &= ~2048;\n        flags &= ~32768;\n        flags &= ~524288;\n        var newFlags = 0;\n\n        for (var k in NODEFS.flagsForNodeMap) {\n          if (flags & k) {\n            newFlags |= NODEFS.flagsForNodeMap[k];\n            flags ^= k;\n          }\n        }\n\n        if (!flags) {\n          return newFlags;\n        } else {\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n        }\n      },\n      node_ops: {\n        getattr: function (node) {\n          var path = NODEFS.realPath(node);\n          var stat;\n\n          try {\n            stat = fs.lstatSync(path);\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n\n          if (NODEFS.isWindows && !stat.blksize) {\n            stat.blksize = 4096;\n          }\n\n          if (NODEFS.isWindows && !stat.blocks) {\n            stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;\n          }\n\n          return {\n            dev: stat.dev,\n            ino: stat.ino,\n            mode: stat.mode,\n            nlink: stat.nlink,\n            uid: stat.uid,\n            gid: stat.gid,\n            rdev: stat.rdev,\n            size: stat.size,\n            atime: stat.atime,\n            mtime: stat.mtime,\n            ctime: stat.ctime,\n            blksize: stat.blksize,\n            blocks: stat.blocks\n          };\n        },\n        setattr: function (node, attr) {\n          var path = NODEFS.realPath(node);\n\n          try {\n            if (attr.mode !== undefined) {\n              fs.chmodSync(path, attr.mode);\n              node.mode = attr.mode;\n            }\n\n            if (attr.timestamp !== undefined) {\n              var date = new Date(attr.timestamp);\n              fs.utimesSync(path, date, date);\n            }\n\n            if (attr.size !== undefined) {\n              fs.truncateSync(path, attr.size);\n            }\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n        },\n        lookup: function (parent, name) {\n          var path = PATH.join2(NODEFS.realPath(parent), name);\n          var mode = NODEFS.getMode(path);\n          return NODEFS.createNode(parent, name, mode);\n        },\n        mknod: function (parent, name, mode, dev) {\n          var node = NODEFS.createNode(parent, name, mode, dev);\n          var path = NODEFS.realPath(node);\n\n          try {\n            if (FS.isDir(node.mode)) {\n              fs.mkdirSync(path, node.mode);\n            } else {\n              fs.writeFileSync(path, \"\", {\n                mode: node.mode\n              });\n            }\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n\n          return node;\n        },\n        rename: function (oldNode, newDir, newName) {\n          var oldPath = NODEFS.realPath(oldNode);\n          var newPath = PATH.join2(NODEFS.realPath(newDir), newName);\n\n          try {\n            fs.renameSync(oldPath, newPath);\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n        },\n        unlink: function (parent, name) {\n          var path = PATH.join2(NODEFS.realPath(parent), name);\n\n          try {\n            fs.unlinkSync(path);\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n        },\n        rmdir: function (parent, name) {\n          var path = PATH.join2(NODEFS.realPath(parent), name);\n\n          try {\n            fs.rmdirSync(path);\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n        },\n        readdir: function (node) {\n          var path = NODEFS.realPath(node);\n\n          try {\n            return fs.readdirSync(path);\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n        },\n        symlink: function (parent, newName, oldPath) {\n          var newPath = PATH.join2(NODEFS.realPath(parent), newName);\n\n          try {\n            fs.symlinkSync(oldPath, newPath);\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n        },\n        readlink: function (node) {\n          var path = NODEFS.realPath(node);\n\n          try {\n            path = fs.readlinkSync(path);\n            path = NODEJS_PATH.relative(NODEJS_PATH.resolve(node.mount.opts.root), path);\n            return path;\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n        }\n      },\n      stream_ops: {\n        open: function (stream) {\n          var path = NODEFS.realPath(stream.node);\n\n          try {\n            if (FS.isFile(stream.node.mode)) {\n              stream.nfd = fs.openSync(path, NODEFS.flagsForNode(stream.flags));\n            }\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n        },\n        close: function (stream) {\n          try {\n            if (FS.isFile(stream.node.mode) && stream.nfd) {\n              fs.closeSync(stream.nfd);\n            }\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n        },\n        read: function (stream, buffer, offset, length, position) {\n          if (length === 0) return 0;\n\n          try {\n            return fs.readSync(stream.nfd, NODEFS.bufferFrom(buffer.buffer), offset, length, position);\n          } catch (e) {\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n        },\n        write: function (stream, buffer, offset, length, position) {\n          try {\n            return fs.writeSync(stream.nfd, NODEFS.bufferFrom(buffer.buffer), offset, length, position);\n          } catch (e) {\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n        },\n        llseek: function (stream, offset, whence) {\n          var position = offset;\n\n          if (whence === 1) {\n            position += stream.position;\n          } else if (whence === 2) {\n            if (FS.isFile(stream.node.mode)) {\n              try {\n                var stat = fs.fstatSync(stream.nfd);\n                position += stat.size;\n              } catch (e) {\n                throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n              }\n            }\n          }\n\n          if (position < 0) {\n            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n          }\n\n          return position;\n        }\n      }\n    };\n    var WORKERFS = {\n      DIR_MODE: 16895,\n      FILE_MODE: 33279,\n      reader: null,\n      mount: function (mount) {\n        assert(ENVIRONMENT_IS_WORKER);\n        if (!WORKERFS.reader) WORKERFS.reader = new FileReaderSync();\n        var root = WORKERFS.createNode(null, \"/\", WORKERFS.DIR_MODE, 0);\n        var createdParents = {};\n\n        function ensureParent(path) {\n          var parts = path.split(\"/\");\n          var parent = root;\n\n          for (var i = 0; i < parts.length - 1; i++) {\n            var curr = parts.slice(0, i + 1).join(\"/\");\n\n            if (!createdParents[curr]) {\n              createdParents[curr] = WORKERFS.createNode(parent, parts[i], WORKERFS.DIR_MODE, 0);\n            }\n\n            parent = createdParents[curr];\n          }\n\n          return parent;\n        }\n\n        function base(path) {\n          var parts = path.split(\"/\");\n          return parts[parts.length - 1];\n        }\n\n        Array.prototype.forEach.call(mount.opts[\"files\"] || [], function (file) {\n          WORKERFS.createNode(ensureParent(file.name), base(file.name), WORKERFS.FILE_MODE, 0, file, file.lastModifiedDate);\n        });\n        (mount.opts[\"blobs\"] || []).forEach(function (obj) {\n          WORKERFS.createNode(ensureParent(obj[\"name\"]), base(obj[\"name\"]), WORKERFS.FILE_MODE, 0, obj[\"data\"]);\n        });\n        (mount.opts[\"packages\"] || []).forEach(function (pack) {\n          pack[\"metadata\"].files.forEach(function (file) {\n            var name = file.filename.substr(1);\n            WORKERFS.createNode(ensureParent(name), base(name), WORKERFS.FILE_MODE, 0, pack[\"blob\"].slice(file.start, file.end));\n          });\n        });\n        return root;\n      },\n      createNode: function (parent, name, mode, dev, contents, mtime) {\n        var node = FS.createNode(parent, name, mode);\n        node.mode = mode;\n        node.node_ops = WORKERFS.node_ops;\n        node.stream_ops = WORKERFS.stream_ops;\n        node.timestamp = (mtime || new Date()).getTime();\n        assert(WORKERFS.FILE_MODE !== WORKERFS.DIR_MODE);\n\n        if (mode === WORKERFS.FILE_MODE) {\n          node.size = contents.size;\n          node.contents = contents;\n        } else {\n          node.size = 4096;\n          node.contents = {};\n        }\n\n        if (parent) {\n          parent.contents[name] = node;\n        }\n\n        return node;\n      },\n      node_ops: {\n        getattr: function (node) {\n          return {\n            dev: 1,\n            ino: undefined,\n            mode: node.mode,\n            nlink: 1,\n            uid: 0,\n            gid: 0,\n            rdev: undefined,\n            size: node.size,\n            atime: new Date(node.timestamp),\n            mtime: new Date(node.timestamp),\n            ctime: new Date(node.timestamp),\n            blksize: 4096,\n            blocks: Math.ceil(node.size / 4096)\n          };\n        },\n        setattr: function (node, attr) {\n          if (attr.mode !== undefined) {\n            node.mode = attr.mode;\n          }\n\n          if (attr.timestamp !== undefined) {\n            node.timestamp = attr.timestamp;\n          }\n        },\n        lookup: function (parent, name) {\n          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);\n        },\n        mknod: function (parent, name, mode, dev) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        },\n        rename: function (oldNode, newDir, newName) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        },\n        unlink: function (parent, name) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        },\n        rmdir: function (parent, name) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        },\n        readdir: function (node) {\n          var entries = [\".\", \"..\"];\n\n          for (var key in node.contents) {\n            if (!node.contents.hasOwnProperty(key)) {\n              continue;\n            }\n\n            entries.push(key);\n          }\n\n          return entries;\n        },\n        symlink: function (parent, newName, oldPath) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        },\n        readlink: function (node) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        }\n      },\n      stream_ops: {\n        read: function (stream, buffer, offset, length, position) {\n          if (position >= stream.node.size) return 0;\n          var chunk = stream.node.contents.slice(position, position + length);\n          var ab = WORKERFS.reader.readAsArrayBuffer(chunk);\n          buffer.set(new Uint8Array(ab), offset);\n          return chunk.size;\n        },\n        write: function (stream, buffer, offset, length, position) {\n          throw new FS.ErrnoError(ERRNO_CODES.EIO);\n        },\n        llseek: function (stream, offset, whence) {\n          var position = offset;\n\n          if (whence === 1) {\n            position += stream.position;\n          } else if (whence === 2) {\n            if (FS.isFile(stream.node.mode)) {\n              position += stream.node.size;\n            }\n          }\n\n          if (position < 0) {\n            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n          }\n\n          return position;\n        }\n      }\n    };\n    var FS = {\n      root: null,\n      mounts: [],\n      devices: {},\n      streams: [],\n      nextInode: 1,\n      nameTable: null,\n      currentPath: \"/\",\n      initialized: false,\n      ignorePermissions: true,\n      trackingDelegate: {},\n      tracking: {\n        openFlags: {\n          READ: 1,\n          WRITE: 2\n        }\n      },\n      ErrnoError: null,\n      genericErrors: {},\n      filesystems: null,\n      syncFSRequests: 0,\n      handleFSError: function (e) {\n        if (!(e instanceof FS.ErrnoError)) throw e + \" : \" + stackTrace();\n        return ___setErrNo(e.errno);\n      },\n      lookupPath: function (path, opts) {\n        path = PATH.resolve(FS.cwd(), path);\n        opts = opts || {};\n        if (!path) return {\n          path: \"\",\n          node: null\n        };\n        var defaults = {\n          follow_mount: true,\n          recurse_count: 0\n        };\n\n        for (var key in defaults) {\n          if (opts[key] === undefined) {\n            opts[key] = defaults[key];\n          }\n        }\n\n        if (opts.recurse_count > 8) {\n          throw new FS.ErrnoError(40);\n        }\n\n        var parts = PATH.normalizeArray(path.split(\"/\").filter(function (p) {\n          return !!p;\n        }), false);\n        var current = FS.root;\n        var current_path = \"/\";\n\n        for (var i = 0; i < parts.length; i++) {\n          var islast = i === parts.length - 1;\n\n          if (islast && opts.parent) {\n            break;\n          }\n\n          current = FS.lookupNode(current, parts[i]);\n          current_path = PATH.join2(current_path, parts[i]);\n\n          if (FS.isMountpoint(current)) {\n            if (!islast || islast && opts.follow_mount) {\n              current = current.mounted.root;\n            }\n          }\n\n          if (!islast || opts.follow) {\n            var count = 0;\n\n            while (FS.isLink(current.mode)) {\n              var link = FS.readlink(current_path);\n              current_path = PATH.resolve(PATH.dirname(current_path), link);\n              var lookup = FS.lookupPath(current_path, {\n                recurse_count: opts.recurse_count\n              });\n              current = lookup.node;\n\n              if (count++ > 40) {\n                throw new FS.ErrnoError(40);\n              }\n            }\n          }\n        }\n\n        return {\n          path: current_path,\n          node: current\n        };\n      },\n      getPath: function (node) {\n        var path;\n\n        while (true) {\n          if (FS.isRoot(node)) {\n            var mount = node.mount.mountpoint;\n            if (!path) return mount;\n            return mount[mount.length - 1] !== \"/\" ? mount + \"/\" + path : mount + path;\n          }\n\n          path = path ? node.name + \"/\" + path : node.name;\n          node = node.parent;\n        }\n      },\n      hashName: function (parentid, name) {\n        var hash = 0;\n\n        for (var i = 0; i < name.length; i++) {\n          hash = (hash << 5) - hash + name.charCodeAt(i) | 0;\n        }\n\n        return (parentid + hash >>> 0) % FS.nameTable.length;\n      },\n      hashAddNode: function (node) {\n        var hash = FS.hashName(node.parent.id, node.name);\n        node.name_next = FS.nameTable[hash];\n        FS.nameTable[hash] = node;\n      },\n      hashRemoveNode: function (node) {\n        var hash = FS.hashName(node.parent.id, node.name);\n\n        if (FS.nameTable[hash] === node) {\n          FS.nameTable[hash] = node.name_next;\n        } else {\n          var current = FS.nameTable[hash];\n\n          while (current) {\n            if (current.name_next === node) {\n              current.name_next = node.name_next;\n              break;\n            }\n\n            current = current.name_next;\n          }\n        }\n      },\n      lookupNode: function (parent, name) {\n        var err = FS.mayLookup(parent);\n\n        if (err) {\n          throw new FS.ErrnoError(err, parent);\n        }\n\n        var hash = FS.hashName(parent.id, name);\n\n        for (var node = FS.nameTable[hash]; node; node = node.name_next) {\n          var nodeName = node.name;\n\n          if (node.parent.id === parent.id && nodeName === name) {\n            return node;\n          }\n        }\n\n        return FS.lookup(parent, name);\n      },\n      createNode: function (parent, name, mode, rdev) {\n        if (!FS.FSNode) {\n          FS.FSNode = function (parent, name, mode, rdev) {\n            if (!parent) {\n              parent = this;\n            }\n\n            this.parent = parent;\n            this.mount = parent.mount;\n            this.mounted = null;\n            this.id = FS.nextInode++;\n            this.name = name;\n            this.mode = mode;\n            this.node_ops = {};\n            this.stream_ops = {};\n            this.rdev = rdev;\n          };\n\n          FS.FSNode.prototype = {};\n          var readMode = 292 | 73;\n          var writeMode = 146;\n          Object.defineProperties(FS.FSNode.prototype, {\n            read: {\n              get: function () {\n                return (this.mode & readMode) === readMode;\n              },\n              set: function (val) {\n                val ? this.mode |= readMode : this.mode &= ~readMode;\n              }\n            },\n            write: {\n              get: function () {\n                return (this.mode & writeMode) === writeMode;\n              },\n              set: function (val) {\n                val ? this.mode |= writeMode : this.mode &= ~writeMode;\n              }\n            },\n            isFolder: {\n              get: function () {\n                return FS.isDir(this.mode);\n              }\n            },\n            isDevice: {\n              get: function () {\n                return FS.isChrdev(this.mode);\n              }\n            }\n          });\n        }\n\n        var node = new FS.FSNode(parent, name, mode, rdev);\n        FS.hashAddNode(node);\n        return node;\n      },\n      destroyNode: function (node) {\n        FS.hashRemoveNode(node);\n      },\n      isRoot: function (node) {\n        return node === node.parent;\n      },\n      isMountpoint: function (node) {\n        return !!node.mounted;\n      },\n      isFile: function (mode) {\n        return (mode & 61440) === 32768;\n      },\n      isDir: function (mode) {\n        return (mode & 61440) === 16384;\n      },\n      isLink: function (mode) {\n        return (mode & 61440) === 40960;\n      },\n      isChrdev: function (mode) {\n        return (mode & 61440) === 8192;\n      },\n      isBlkdev: function (mode) {\n        return (mode & 61440) === 24576;\n      },\n      isFIFO: function (mode) {\n        return (mode & 61440) === 4096;\n      },\n      isSocket: function (mode) {\n        return (mode & 49152) === 49152;\n      },\n      flagModes: {\n        \"r\": 0,\n        \"rs\": 1052672,\n        \"r+\": 2,\n        \"w\": 577,\n        \"wx\": 705,\n        \"xw\": 705,\n        \"w+\": 578,\n        \"wx+\": 706,\n        \"xw+\": 706,\n        \"a\": 1089,\n        \"ax\": 1217,\n        \"xa\": 1217,\n        \"a+\": 1090,\n        \"ax+\": 1218,\n        \"xa+\": 1218\n      },\n      modeStringToFlags: function (str) {\n        var flags = FS.flagModes[str];\n\n        if (typeof flags === \"undefined\") {\n          throw new Error(\"Unknown file open mode: \" + str);\n        }\n\n        return flags;\n      },\n      flagsToPermissionString: function (flag) {\n        var perms = [\"r\", \"w\", \"rw\"][flag & 3];\n\n        if (flag & 512) {\n          perms += \"w\";\n        }\n\n        return perms;\n      },\n      nodePermissions: function (node, perms) {\n        if (FS.ignorePermissions) {\n          return 0;\n        }\n\n        if (perms.indexOf(\"r\") !== -1 && !(node.mode & 292)) {\n          return 13;\n        } else if (perms.indexOf(\"w\") !== -1 && !(node.mode & 146)) {\n          return 13;\n        } else if (perms.indexOf(\"x\") !== -1 && !(node.mode & 73)) {\n          return 13;\n        }\n\n        return 0;\n      },\n      mayLookup: function (dir) {\n        var err = FS.nodePermissions(dir, \"x\");\n        if (err) return err;\n        if (!dir.node_ops.lookup) return 13;\n        return 0;\n      },\n      mayCreate: function (dir, name) {\n        try {\n          var node = FS.lookupNode(dir, name);\n          return 17;\n        } catch (e) {}\n\n        return FS.nodePermissions(dir, \"wx\");\n      },\n      mayDelete: function (dir, name, isdir) {\n        var node;\n\n        try {\n          node = FS.lookupNode(dir, name);\n        } catch (e) {\n          return e.errno;\n        }\n\n        var err = FS.nodePermissions(dir, \"wx\");\n\n        if (err) {\n          return err;\n        }\n\n        if (isdir) {\n          if (!FS.isDir(node.mode)) {\n            return 20;\n          }\n\n          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\n            return 16;\n          }\n        } else {\n          if (FS.isDir(node.mode)) {\n            return 21;\n          }\n        }\n\n        return 0;\n      },\n      mayOpen: function (node, flags) {\n        if (!node) {\n          return 2;\n        }\n\n        if (FS.isLink(node.mode)) {\n          return 40;\n        } else if (FS.isDir(node.mode)) {\n          if (FS.flagsToPermissionString(flags) !== \"r\" || flags & 512) {\n            return 21;\n          }\n        }\n\n        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\n      },\n      MAX_OPEN_FDS: 4096,\n      nextfd: function (fd_start, fd_end) {\n        fd_start = fd_start || 0;\n        fd_end = fd_end || FS.MAX_OPEN_FDS;\n\n        for (var fd = fd_start; fd <= fd_end; fd++) {\n          if (!FS.streams[fd]) {\n            return fd;\n          }\n        }\n\n        throw new FS.ErrnoError(24);\n      },\n      getStream: function (fd) {\n        return FS.streams[fd];\n      },\n      createStream: function (stream, fd_start, fd_end) {\n        if (!FS.FSStream) {\n          FS.FSStream = function () {};\n\n          FS.FSStream.prototype = {};\n          Object.defineProperties(FS.FSStream.prototype, {\n            object: {\n              get: function () {\n                return this.node;\n              },\n              set: function (val) {\n                this.node = val;\n              }\n            },\n            isRead: {\n              get: function () {\n                return (this.flags & 2097155) !== 1;\n              }\n            },\n            isWrite: {\n              get: function () {\n                return (this.flags & 2097155) !== 0;\n              }\n            },\n            isAppend: {\n              get: function () {\n                return this.flags & 1024;\n              }\n            }\n          });\n        }\n\n        var newStream = new FS.FSStream();\n\n        for (var p in stream) {\n          newStream[p] = stream[p];\n        }\n\n        stream = newStream;\n        var fd = FS.nextfd(fd_start, fd_end);\n        stream.fd = fd;\n        FS.streams[fd] = stream;\n        return stream;\n      },\n      closeStream: function (fd) {\n        FS.streams[fd] = null;\n      },\n      chrdev_stream_ops: {\n        open: function (stream) {\n          var device = FS.getDevice(stream.node.rdev);\n          stream.stream_ops = device.stream_ops;\n\n          if (stream.stream_ops.open) {\n            stream.stream_ops.open(stream);\n          }\n        },\n        llseek: function () {\n          throw new FS.ErrnoError(29);\n        }\n      },\n      major: function (dev) {\n        return dev >> 8;\n      },\n      minor: function (dev) {\n        return dev & 255;\n      },\n      makedev: function (ma, mi) {\n        return ma << 8 | mi;\n      },\n      registerDevice: function (dev, ops) {\n        FS.devices[dev] = {\n          stream_ops: ops\n        };\n      },\n      getDevice: function (dev) {\n        return FS.devices[dev];\n      },\n      getMounts: function (mount) {\n        var mounts = [];\n        var check = [mount];\n\n        while (check.length) {\n          var m = check.pop();\n          mounts.push(m);\n          check.push.apply(check, m.mounts);\n        }\n\n        return mounts;\n      },\n      syncfs: function (populate, callback) {\n        if (typeof populate === \"function\") {\n          callback = populate;\n          populate = false;\n        }\n\n        FS.syncFSRequests++;\n\n        if (FS.syncFSRequests > 1) {\n          console.log(\"warning: \" + FS.syncFSRequests + \" FS.syncfs operations in flight at once, probably just doing extra work\");\n        }\n\n        var mounts = FS.getMounts(FS.root.mount);\n        var completed = 0;\n\n        function doCallback(err) {\n          FS.syncFSRequests--;\n          return callback(err);\n        }\n\n        function done(err) {\n          if (err) {\n            if (!done.errored) {\n              done.errored = true;\n              return doCallback(err);\n            }\n\n            return;\n          }\n\n          if (++completed >= mounts.length) {\n            doCallback(null);\n          }\n        }\n\n        mounts.forEach(function (mount) {\n          if (!mount.type.syncfs) {\n            return done(null);\n          }\n\n          mount.type.syncfs(mount, populate, done);\n        });\n      },\n      mount: function (type, opts, mountpoint) {\n        var root = mountpoint === \"/\";\n        var pseudo = !mountpoint;\n        var node;\n\n        if (root && FS.root) {\n          throw new FS.ErrnoError(16);\n        } else if (!root && !pseudo) {\n          var lookup = FS.lookupPath(mountpoint, {\n            follow_mount: false\n          });\n          mountpoint = lookup.path;\n          node = lookup.node;\n\n          if (FS.isMountpoint(node)) {\n            throw new FS.ErrnoError(16);\n          }\n\n          if (!FS.isDir(node.mode)) {\n            throw new FS.ErrnoError(20);\n          }\n        }\n\n        var mount = {\n          type: type,\n          opts: opts,\n          mountpoint: mountpoint,\n          mounts: []\n        };\n        var mountRoot = type.mount(mount);\n        mountRoot.mount = mount;\n        mount.root = mountRoot;\n\n        if (root) {\n          FS.root = mountRoot;\n        } else if (node) {\n          node.mounted = mount;\n\n          if (node.mount) {\n            node.mount.mounts.push(mount);\n          }\n        }\n\n        return mountRoot;\n      },\n      unmount: function (mountpoint) {\n        var lookup = FS.lookupPath(mountpoint, {\n          follow_mount: false\n        });\n\n        if (!FS.isMountpoint(lookup.node)) {\n          throw new FS.ErrnoError(22);\n        }\n\n        var node = lookup.node;\n        var mount = node.mounted;\n        var mounts = FS.getMounts(mount);\n        Object.keys(FS.nameTable).forEach(function (hash) {\n          var current = FS.nameTable[hash];\n\n          while (current) {\n            var next = current.name_next;\n\n            if (mounts.indexOf(current.mount) !== -1) {\n              FS.destroyNode(current);\n            }\n\n            current = next;\n          }\n        });\n        node.mounted = null;\n        var idx = node.mount.mounts.indexOf(mount);\n        node.mount.mounts.splice(idx, 1);\n      },\n      lookup: function (parent, name) {\n        return parent.node_ops.lookup(parent, name);\n      },\n      mknod: function (path, mode, dev) {\n        var lookup = FS.lookupPath(path, {\n          parent: true\n        });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n\n        if (!name || name === \".\" || name === \"..\") {\n          throw new FS.ErrnoError(22);\n        }\n\n        var err = FS.mayCreate(parent, name);\n\n        if (err) {\n          throw new FS.ErrnoError(err);\n        }\n\n        if (!parent.node_ops.mknod) {\n          throw new FS.ErrnoError(1);\n        }\n\n        return parent.node_ops.mknod(parent, name, mode, dev);\n      },\n      create: function (path, mode) {\n        mode = mode !== undefined ? mode : 438;\n        mode &= 4095;\n        mode |= 32768;\n        return FS.mknod(path, mode, 0);\n      },\n      mkdir: function (path, mode) {\n        mode = mode !== undefined ? mode : 511;\n        mode &= 511 | 512;\n        mode |= 16384;\n        return FS.mknod(path, mode, 0);\n      },\n      mkdirTree: function (path, mode) {\n        var dirs = path.split(\"/\");\n        var d = \"\";\n\n        for (var i = 0; i < dirs.length; ++i) {\n          if (!dirs[i]) continue;\n          d += \"/\" + dirs[i];\n\n          try {\n            FS.mkdir(d, mode);\n          } catch (e) {\n            if (e.errno != 17) throw e;\n          }\n        }\n      },\n      mkdev: function (path, mode, dev) {\n        if (typeof dev === \"undefined\") {\n          dev = mode;\n          mode = 438;\n        }\n\n        mode |= 8192;\n        return FS.mknod(path, mode, dev);\n      },\n      symlink: function (oldpath, newpath) {\n        if (!PATH.resolve(oldpath)) {\n          throw new FS.ErrnoError(2);\n        }\n\n        var lookup = FS.lookupPath(newpath, {\n          parent: true\n        });\n        var parent = lookup.node;\n\n        if (!parent) {\n          throw new FS.ErrnoError(2);\n        }\n\n        var newname = PATH.basename(newpath);\n        var err = FS.mayCreate(parent, newname);\n\n        if (err) {\n          throw new FS.ErrnoError(err);\n        }\n\n        if (!parent.node_ops.symlink) {\n          throw new FS.ErrnoError(1);\n        }\n\n        return parent.node_ops.symlink(parent, newname, oldpath);\n      },\n      rename: function (old_path, new_path) {\n        var old_dirname = PATH.dirname(old_path);\n        var new_dirname = PATH.dirname(new_path);\n        var old_name = PATH.basename(old_path);\n        var new_name = PATH.basename(new_path);\n        var lookup, old_dir, new_dir;\n\n        try {\n          lookup = FS.lookupPath(old_path, {\n            parent: true\n          });\n          old_dir = lookup.node;\n          lookup = FS.lookupPath(new_path, {\n            parent: true\n          });\n          new_dir = lookup.node;\n        } catch (e) {\n          throw new FS.ErrnoError(16);\n        }\n\n        if (!old_dir || !new_dir) throw new FS.ErrnoError(2);\n\n        if (old_dir.mount !== new_dir.mount) {\n          throw new FS.ErrnoError(18);\n        }\n\n        var old_node = FS.lookupNode(old_dir, old_name);\n        var relative = PATH.relative(old_path, new_dirname);\n\n        if (relative.charAt(0) !== \".\") {\n          throw new FS.ErrnoError(22);\n        }\n\n        relative = PATH.relative(new_path, old_dirname);\n\n        if (relative.charAt(0) !== \".\") {\n          throw new FS.ErrnoError(39);\n        }\n\n        var new_node;\n\n        try {\n          new_node = FS.lookupNode(new_dir, new_name);\n        } catch (e) {}\n\n        if (old_node === new_node) {\n          return;\n        }\n\n        var isdir = FS.isDir(old_node.mode);\n        var err = FS.mayDelete(old_dir, old_name, isdir);\n\n        if (err) {\n          throw new FS.ErrnoError(err);\n        }\n\n        err = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);\n\n        if (err) {\n          throw new FS.ErrnoError(err);\n        }\n\n        if (!old_dir.node_ops.rename) {\n          throw new FS.ErrnoError(1);\n        }\n\n        if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {\n          throw new FS.ErrnoError(16);\n        }\n\n        if (new_dir !== old_dir) {\n          err = FS.nodePermissions(old_dir, \"w\");\n\n          if (err) {\n            throw new FS.ErrnoError(err);\n          }\n        }\n\n        try {\n          if (FS.trackingDelegate[\"willMovePath\"]) {\n            FS.trackingDelegate[\"willMovePath\"](old_path, new_path);\n          }\n        } catch (e) {\n          console.log(\"FS.trackingDelegate['willMovePath']('\" + old_path + \"', '\" + new_path + \"') threw an exception: \" + e.message);\n        }\n\n        FS.hashRemoveNode(old_node);\n\n        try {\n          old_dir.node_ops.rename(old_node, new_dir, new_name);\n        } catch (e) {\n          throw e;\n        } finally {\n          FS.hashAddNode(old_node);\n        }\n\n        try {\n          if (FS.trackingDelegate[\"onMovePath\"]) FS.trackingDelegate[\"onMovePath\"](old_path, new_path);\n        } catch (e) {\n          console.log(\"FS.trackingDelegate['onMovePath']('\" + old_path + \"', '\" + new_path + \"') threw an exception: \" + e.message);\n        }\n      },\n      rmdir: function (path) {\n        var lookup = FS.lookupPath(path, {\n          parent: true\n        });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        var node = FS.lookupNode(parent, name);\n        var err = FS.mayDelete(parent, name, true);\n\n        if (err) {\n          throw new FS.ErrnoError(err);\n        }\n\n        if (!parent.node_ops.rmdir) {\n          throw new FS.ErrnoError(1);\n        }\n\n        if (FS.isMountpoint(node)) {\n          throw new FS.ErrnoError(16);\n        }\n\n        try {\n          if (FS.trackingDelegate[\"willDeletePath\"]) {\n            FS.trackingDelegate[\"willDeletePath\"](path);\n          }\n        } catch (e) {\n          console.log(\"FS.trackingDelegate['willDeletePath']('\" + path + \"') threw an exception: \" + e.message);\n        }\n\n        parent.node_ops.rmdir(parent, name);\n        FS.destroyNode(node);\n\n        try {\n          if (FS.trackingDelegate[\"onDeletePath\"]) FS.trackingDelegate[\"onDeletePath\"](path);\n        } catch (e) {\n          console.log(\"FS.trackingDelegate['onDeletePath']('\" + path + \"') threw an exception: \" + e.message);\n        }\n      },\n      readdir: function (path) {\n        var lookup = FS.lookupPath(path, {\n          follow: true\n        });\n        var node = lookup.node;\n\n        if (!node.node_ops.readdir) {\n          throw new FS.ErrnoError(20);\n        }\n\n        return node.node_ops.readdir(node);\n      },\n      unlink: function (path) {\n        var lookup = FS.lookupPath(path, {\n          parent: true\n        });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        var node = FS.lookupNode(parent, name);\n        var err = FS.mayDelete(parent, name, false);\n\n        if (err) {\n          throw new FS.ErrnoError(err);\n        }\n\n        if (!parent.node_ops.unlink) {\n          throw new FS.ErrnoError(1);\n        }\n\n        if (FS.isMountpoint(node)) {\n          throw new FS.ErrnoError(16);\n        }\n\n        try {\n          if (FS.trackingDelegate[\"willDeletePath\"]) {\n            FS.trackingDelegate[\"willDeletePath\"](path);\n          }\n        } catch (e) {\n          console.log(\"FS.trackingDelegate['willDeletePath']('\" + path + \"') threw an exception: \" + e.message);\n        }\n\n        parent.node_ops.unlink(parent, name);\n        FS.destroyNode(node);\n\n        try {\n          if (FS.trackingDelegate[\"onDeletePath\"]) FS.trackingDelegate[\"onDeletePath\"](path);\n        } catch (e) {\n          console.log(\"FS.trackingDelegate['onDeletePath']('\" + path + \"') threw an exception: \" + e.message);\n        }\n      },\n      readlink: function (path) {\n        var lookup = FS.lookupPath(path);\n        var link = lookup.node;\n\n        if (!link) {\n          throw new FS.ErrnoError(2);\n        }\n\n        if (!link.node_ops.readlink) {\n          throw new FS.ErrnoError(22);\n        }\n\n        return PATH.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));\n      },\n      stat: function (path, dontFollow) {\n        var lookup = FS.lookupPath(path, {\n          follow: !dontFollow\n        });\n        var node = lookup.node;\n\n        if (!node) {\n          throw new FS.ErrnoError(2);\n        }\n\n        if (!node.node_ops.getattr) {\n          throw new FS.ErrnoError(1);\n        }\n\n        return node.node_ops.getattr(node);\n      },\n      lstat: function (path) {\n        return FS.stat(path, true);\n      },\n      chmod: function (path, mode, dontFollow) {\n        var node;\n\n        if (typeof path === \"string\") {\n          var lookup = FS.lookupPath(path, {\n            follow: !dontFollow\n          });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(1);\n        }\n\n        node.node_ops.setattr(node, {\n          mode: mode & 4095 | node.mode & ~4095,\n          timestamp: Date.now()\n        });\n      },\n      lchmod: function (path, mode) {\n        FS.chmod(path, mode, true);\n      },\n      fchmod: function (fd, mode) {\n        var stream = FS.getStream(fd);\n\n        if (!stream) {\n          throw new FS.ErrnoError(9);\n        }\n\n        FS.chmod(stream.node, mode);\n      },\n      chown: function (path, uid, gid, dontFollow) {\n        var node;\n\n        if (typeof path === \"string\") {\n          var lookup = FS.lookupPath(path, {\n            follow: !dontFollow\n          });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(1);\n        }\n\n        node.node_ops.setattr(node, {\n          timestamp: Date.now()\n        });\n      },\n      lchown: function (path, uid, gid) {\n        FS.chown(path, uid, gid, true);\n      },\n      fchown: function (fd, uid, gid) {\n        var stream = FS.getStream(fd);\n\n        if (!stream) {\n          throw new FS.ErrnoError(9);\n        }\n\n        FS.chown(stream.node, uid, gid);\n      },\n      truncate: function (path, len) {\n        if (len < 0) {\n          throw new FS.ErrnoError(22);\n        }\n\n        var node;\n\n        if (typeof path === \"string\") {\n          var lookup = FS.lookupPath(path, {\n            follow: true\n          });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(1);\n        }\n\n        if (FS.isDir(node.mode)) {\n          throw new FS.ErrnoError(21);\n        }\n\n        if (!FS.isFile(node.mode)) {\n          throw new FS.ErrnoError(22);\n        }\n\n        var err = FS.nodePermissions(node, \"w\");\n\n        if (err) {\n          throw new FS.ErrnoError(err);\n        }\n\n        node.node_ops.setattr(node, {\n          size: len,\n          timestamp: Date.now()\n        });\n      },\n      ftruncate: function (fd, len) {\n        var stream = FS.getStream(fd);\n\n        if (!stream) {\n          throw new FS.ErrnoError(9);\n        }\n\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(22);\n        }\n\n        FS.truncate(stream.node, len);\n      },\n      utime: function (path, atime, mtime) {\n        var lookup = FS.lookupPath(path, {\n          follow: true\n        });\n        var node = lookup.node;\n        node.node_ops.setattr(node, {\n          timestamp: Math.max(atime, mtime)\n        });\n      },\n      open: function (path, flags, mode, fd_start, fd_end) {\n        if (path === \"\") {\n          throw new FS.ErrnoError(2);\n        }\n\n        flags = typeof flags === \"string\" ? FS.modeStringToFlags(flags) : flags;\n        mode = typeof mode === \"undefined\" ? 438 : mode;\n\n        if (flags & 64) {\n          mode = mode & 4095 | 32768;\n        } else {\n          mode = 0;\n        }\n\n        var node;\n\n        if (typeof path === \"object\") {\n          node = path;\n        } else {\n          path = PATH.normalize(path);\n\n          try {\n            var lookup = FS.lookupPath(path, {\n              follow: !(flags & 131072)\n            });\n            node = lookup.node;\n          } catch (e) {}\n        }\n\n        var created = false;\n\n        if (flags & 64) {\n          if (node) {\n            if (flags & 128) {\n              throw new FS.ErrnoError(17);\n            }\n          } else {\n            node = FS.mknod(path, mode, 0);\n            created = true;\n          }\n        }\n\n        if (!node) {\n          throw new FS.ErrnoError(2);\n        }\n\n        if (FS.isChrdev(node.mode)) {\n          flags &= ~512;\n        }\n\n        if (flags & 65536 && !FS.isDir(node.mode)) {\n          throw new FS.ErrnoError(20);\n        }\n\n        if (!created) {\n          var err = FS.mayOpen(node, flags);\n\n          if (err) {\n            throw new FS.ErrnoError(err);\n          }\n        }\n\n        if (flags & 512) {\n          FS.truncate(node, 0);\n        }\n\n        flags &= ~(128 | 512);\n        var stream = FS.createStream({\n          node: node,\n          path: FS.getPath(node),\n          flags: flags,\n          seekable: true,\n          position: 0,\n          stream_ops: node.stream_ops,\n          ungotten: [],\n          error: false\n        }, fd_start, fd_end);\n\n        if (stream.stream_ops.open) {\n          stream.stream_ops.open(stream);\n        }\n\n        if (Module[\"logReadFiles\"] && !(flags & 1)) {\n          if (!FS.readFiles) FS.readFiles = {};\n\n          if (!(path in FS.readFiles)) {\n            FS.readFiles[path] = 1;\n            console.log(\"FS.trackingDelegate error on read file: \" + path);\n          }\n        }\n\n        try {\n          if (FS.trackingDelegate[\"onOpenFile\"]) {\n            var trackingFlags = 0;\n\n            if ((flags & 2097155) !== 1) {\n              trackingFlags |= FS.tracking.openFlags.READ;\n            }\n\n            if ((flags & 2097155) !== 0) {\n              trackingFlags |= FS.tracking.openFlags.WRITE;\n            }\n\n            FS.trackingDelegate[\"onOpenFile\"](path, trackingFlags);\n          }\n        } catch (e) {\n          console.log(\"FS.trackingDelegate['onOpenFile']('\" + path + \"', flags) threw an exception: \" + e.message);\n        }\n\n        return stream;\n      },\n      close: function (stream) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(9);\n        }\n\n        if (stream.getdents) stream.getdents = null;\n\n        try {\n          if (stream.stream_ops.close) {\n            stream.stream_ops.close(stream);\n          }\n        } catch (e) {\n          throw e;\n        } finally {\n          FS.closeStream(stream.fd);\n        }\n\n        stream.fd = null;\n      },\n      isClosed: function (stream) {\n        return stream.fd === null;\n      },\n      llseek: function (stream, offset, whence) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(9);\n        }\n\n        if (!stream.seekable || !stream.stream_ops.llseek) {\n          throw new FS.ErrnoError(29);\n        }\n\n        if (whence != 0 && whence != 1 && whence != 2) {\n          throw new FS.ErrnoError(22);\n        }\n\n        stream.position = stream.stream_ops.llseek(stream, offset, whence);\n        stream.ungotten = [];\n        return stream.position;\n      },\n      read: function (stream, buffer, offset, length, position) {\n        if (length < 0 || position < 0) {\n          throw new FS.ErrnoError(22);\n        }\n\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(9);\n        }\n\n        if ((stream.flags & 2097155) === 1) {\n          throw new FS.ErrnoError(9);\n        }\n\n        if (FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(21);\n        }\n\n        if (!stream.stream_ops.read) {\n          throw new FS.ErrnoError(22);\n        }\n\n        var seeking = typeof position !== \"undefined\";\n\n        if (!seeking) {\n          position = stream.position;\n        } else if (!stream.seekable) {\n          throw new FS.ErrnoError(29);\n        }\n\n        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);\n        if (!seeking) stream.position += bytesRead;\n        return bytesRead;\n      },\n      write: function (stream, buffer, offset, length, position, canOwn) {\n        if (length < 0 || position < 0) {\n          throw new FS.ErrnoError(22);\n        }\n\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(9);\n        }\n\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(9);\n        }\n\n        if (FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(21);\n        }\n\n        if (!stream.stream_ops.write) {\n          throw new FS.ErrnoError(22);\n        }\n\n        if (stream.flags & 1024) {\n          FS.llseek(stream, 0, 2);\n        }\n\n        var seeking = typeof position !== \"undefined\";\n\n        if (!seeking) {\n          position = stream.position;\n        } else if (!stream.seekable) {\n          throw new FS.ErrnoError(29);\n        }\n\n        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);\n        if (!seeking) stream.position += bytesWritten;\n\n        try {\n          if (stream.path && FS.trackingDelegate[\"onWriteToFile\"]) FS.trackingDelegate[\"onWriteToFile\"](stream.path);\n        } catch (e) {\n          console.log(\"FS.trackingDelegate['onWriteToFile']('\" + stream.path + \"') threw an exception: \" + e.message);\n        }\n\n        return bytesWritten;\n      },\n      allocate: function (stream, offset, length) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(9);\n        }\n\n        if (offset < 0 || length <= 0) {\n          throw new FS.ErrnoError(22);\n        }\n\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(9);\n        }\n\n        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(19);\n        }\n\n        if (!stream.stream_ops.allocate) {\n          throw new FS.ErrnoError(95);\n        }\n\n        stream.stream_ops.allocate(stream, offset, length);\n      },\n      mmap: function (stream, buffer, offset, length, position, prot, flags) {\n        if ((stream.flags & 2097155) === 1) {\n          throw new FS.ErrnoError(13);\n        }\n\n        if (!stream.stream_ops.mmap) {\n          throw new FS.ErrnoError(19);\n        }\n\n        return stream.stream_ops.mmap(stream, buffer, offset, length, position, prot, flags);\n      },\n      msync: function (stream, buffer, offset, length, mmapFlags) {\n        if (!stream || !stream.stream_ops.msync) {\n          return 0;\n        }\n\n        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);\n      },\n      munmap: function (stream) {\n        return 0;\n      },\n      ioctl: function (stream, cmd, arg) {\n        if (!stream.stream_ops.ioctl) {\n          throw new FS.ErrnoError(25);\n        }\n\n        return stream.stream_ops.ioctl(stream, cmd, arg);\n      },\n      readFile: function (path, opts) {\n        opts = opts || {};\n        opts.flags = opts.flags || \"r\";\n        opts.encoding = opts.encoding || \"binary\";\n\n        if (opts.encoding !== \"utf8\" && opts.encoding !== \"binary\") {\n          throw new Error('Invalid encoding type \"' + opts.encoding + '\"');\n        }\n\n        var ret;\n        var stream = FS.open(path, opts.flags);\n        var stat = FS.stat(path);\n        var length = stat.size;\n        var buf = new Uint8Array(length);\n        FS.read(stream, buf, 0, length, 0);\n\n        if (opts.encoding === \"utf8\") {\n          ret = UTF8ArrayToString(buf, 0);\n        } else if (opts.encoding === \"binary\") {\n          ret = buf;\n        }\n\n        FS.close(stream);\n        return ret;\n      },\n      writeFile: function (path, data, opts) {\n        opts = opts || {};\n        opts.flags = opts.flags || \"w\";\n        var stream = FS.open(path, opts.flags, opts.mode);\n\n        if (typeof data === \"string\") {\n          var buf = new Uint8Array(lengthBytesUTF8(data) + 1);\n          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\n          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);\n        } else if (ArrayBuffer.isView(data)) {\n          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);\n        } else {\n          throw new Error(\"Unsupported data type\");\n        }\n\n        FS.close(stream);\n      },\n      cwd: function () {\n        return FS.currentPath;\n      },\n      chdir: function (path) {\n        var lookup = FS.lookupPath(path, {\n          follow: true\n        });\n\n        if (lookup.node === null) {\n          throw new FS.ErrnoError(2);\n        }\n\n        if (!FS.isDir(lookup.node.mode)) {\n          throw new FS.ErrnoError(20);\n        }\n\n        var err = FS.nodePermissions(lookup.node, \"x\");\n\n        if (err) {\n          throw new FS.ErrnoError(err);\n        }\n\n        FS.currentPath = lookup.path;\n      },\n      createDefaultDirectories: function () {\n        FS.mkdir(\"/tmp\");\n        FS.mkdir(\"/home\");\n        FS.mkdir(\"/home/web_user\");\n      },\n      createDefaultDevices: function () {\n        FS.mkdir(\"/dev\");\n        FS.registerDevice(FS.makedev(1, 3), {\n          read: function () {\n            return 0;\n          },\n          write: function (stream, buffer, offset, length, pos) {\n            return length;\n          }\n        });\n        FS.mkdev(\"/dev/null\", FS.makedev(1, 3));\n        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\n        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\n        FS.mkdev(\"/dev/tty\", FS.makedev(5, 0));\n        FS.mkdev(\"/dev/tty1\", FS.makedev(6, 0));\n        var random_device;\n\n        if (typeof crypto === \"object\" && typeof crypto[\"getRandomValues\"] === \"function\") {\n          var randomBuffer = new Uint8Array(1);\n\n          random_device = function () {\n            crypto.getRandomValues(randomBuffer);\n            return randomBuffer[0];\n          };\n        } else if (ENVIRONMENT_IS_NODE) {\n          try {\n            var crypto_module = require(\"crypto\");\n\n            random_device = function () {\n              return crypto_module[\"randomBytes\"](1)[0];\n            };\n          } catch (e) {}\n        } else {}\n\n        if (!random_device) {\n          random_device = function () {\n            abort(\"random_device\");\n          };\n        }\n\n        FS.createDevice(\"/dev\", \"random\", random_device);\n        FS.createDevice(\"/dev\", \"urandom\", random_device);\n        FS.mkdir(\"/dev/shm\");\n        FS.mkdir(\"/dev/shm/tmp\");\n      },\n      createSpecialDirectories: function () {\n        FS.mkdir(\"/proc\");\n        FS.mkdir(\"/proc/self\");\n        FS.mkdir(\"/proc/self/fd\");\n        FS.mount({\n          mount: function () {\n            var node = FS.createNode(\"/proc/self\", \"fd\", 16384 | 511, 73);\n            node.node_ops = {\n              lookup: function (parent, name) {\n                var fd = +name;\n                var stream = FS.getStream(fd);\n                if (!stream) throw new FS.ErrnoError(9);\n                var ret = {\n                  parent: null,\n                  mount: {\n                    mountpoint: \"fake\"\n                  },\n                  node_ops: {\n                    readlink: function () {\n                      return stream.path;\n                    }\n                  }\n                };\n                ret.parent = ret;\n                return ret;\n              }\n            };\n            return node;\n          }\n        }, {}, \"/proc/self/fd\");\n      },\n      createStandardStreams: function () {\n        if (Module[\"stdin\"]) {\n          FS.createDevice(\"/dev\", \"stdin\", Module[\"stdin\"]);\n        } else {\n          FS.symlink(\"/dev/tty\", \"/dev/stdin\");\n        }\n\n        if (Module[\"stdout\"]) {\n          FS.createDevice(\"/dev\", \"stdout\", null, Module[\"stdout\"]);\n        } else {\n          FS.symlink(\"/dev/tty\", \"/dev/stdout\");\n        }\n\n        if (Module[\"stderr\"]) {\n          FS.createDevice(\"/dev\", \"stderr\", null, Module[\"stderr\"]);\n        } else {\n          FS.symlink(\"/dev/tty1\", \"/dev/stderr\");\n        }\n\n        var stdin = FS.open(\"/dev/stdin\", \"r\");\n        var stdout = FS.open(\"/dev/stdout\", \"w\");\n        var stderr = FS.open(\"/dev/stderr\", \"w\");\n      },\n      ensureErrnoError: function () {\n        if (FS.ErrnoError) return;\n\n        FS.ErrnoError = function ErrnoError(errno, node) {\n          this.node = node;\n\n          this.setErrno = function (errno) {\n            this.errno = errno;\n          };\n\n          this.setErrno(errno);\n          this.message = \"FS error\";\n          if (this.stack) Object.defineProperty(this, \"stack\", {\n            value: new Error().stack,\n            writable: true\n          });\n        };\n\n        FS.ErrnoError.prototype = new Error();\n        FS.ErrnoError.prototype.constructor = FS.ErrnoError;\n        [2].forEach(function (code) {\n          FS.genericErrors[code] = new FS.ErrnoError(code);\n          FS.genericErrors[code].stack = \"<generic error, no stack>\";\n        });\n      },\n      staticInit: function () {\n        FS.ensureErrnoError();\n        FS.nameTable = new Array(4096);\n        FS.mount(MEMFS, {}, \"/\");\n        FS.createDefaultDirectories();\n        FS.createDefaultDevices();\n        FS.createSpecialDirectories();\n        FS.filesystems = {\n          \"MEMFS\": MEMFS,\n          \"IDBFS\": IDBFS,\n          \"NODEFS\": NODEFS,\n          \"WORKERFS\": WORKERFS\n        };\n      },\n      init: function (input, output, error) {\n        FS.init.initialized = true;\n        FS.ensureErrnoError();\n        Module[\"stdin\"] = input || Module[\"stdin\"];\n        Module[\"stdout\"] = output || Module[\"stdout\"];\n        Module[\"stderr\"] = error || Module[\"stderr\"];\n        FS.createStandardStreams();\n      },\n      quit: function () {\n        FS.init.initialized = false;\n        var fflush = Module[\"_fflush\"];\n        if (fflush) fflush(0);\n\n        for (var i = 0; i < FS.streams.length; i++) {\n          var stream = FS.streams[i];\n\n          if (!stream) {\n            continue;\n          }\n\n          FS.close(stream);\n        }\n      },\n      getMode: function (canRead, canWrite) {\n        var mode = 0;\n        if (canRead) mode |= 292 | 73;\n        if (canWrite) mode |= 146;\n        return mode;\n      },\n      joinPath: function (parts, forceRelative) {\n        var path = PATH.join.apply(null, parts);\n        if (forceRelative && path[0] == \"/\") path = path.substr(1);\n        return path;\n      },\n      absolutePath: function (relative, base) {\n        return PATH.resolve(base, relative);\n      },\n      standardizePath: function (path) {\n        return PATH.normalize(path);\n      },\n      findObject: function (path, dontResolveLastLink) {\n        var ret = FS.analyzePath(path, dontResolveLastLink);\n\n        if (ret.exists) {\n          return ret.object;\n        } else {\n          ___setErrNo(ret.error);\n\n          return null;\n        }\n      },\n      analyzePath: function (path, dontResolveLastLink) {\n        try {\n          var lookup = FS.lookupPath(path, {\n            follow: !dontResolveLastLink\n          });\n          path = lookup.path;\n        } catch (e) {}\n\n        var ret = {\n          isRoot: false,\n          exists: false,\n          error: 0,\n          name: null,\n          path: null,\n          object: null,\n          parentExists: false,\n          parentPath: null,\n          parentObject: null\n        };\n\n        try {\n          var lookup = FS.lookupPath(path, {\n            parent: true\n          });\n          ret.parentExists = true;\n          ret.parentPath = lookup.path;\n          ret.parentObject = lookup.node;\n          ret.name = PATH.basename(path);\n          lookup = FS.lookupPath(path, {\n            follow: !dontResolveLastLink\n          });\n          ret.exists = true;\n          ret.path = lookup.path;\n          ret.object = lookup.node;\n          ret.name = lookup.node.name;\n          ret.isRoot = lookup.path === \"/\";\n        } catch (e) {\n          ret.error = e.errno;\n        }\n\n        return ret;\n      },\n      createFolder: function (parent, name, canRead, canWrite) {\n        var path = PATH.join2(typeof parent === \"string\" ? parent : FS.getPath(parent), name);\n        var mode = FS.getMode(canRead, canWrite);\n        return FS.mkdir(path, mode);\n      },\n      createPath: function (parent, path, canRead, canWrite) {\n        parent = typeof parent === \"string\" ? parent : FS.getPath(parent);\n        var parts = path.split(\"/\").reverse();\n\n        while (parts.length) {\n          var part = parts.pop();\n          if (!part) continue;\n          var current = PATH.join2(parent, part);\n\n          try {\n            FS.mkdir(current);\n          } catch (e) {}\n\n          parent = current;\n        }\n\n        return current;\n      },\n      createFile: function (parent, name, properties, canRead, canWrite) {\n        var path = PATH.join2(typeof parent === \"string\" ? parent : FS.getPath(parent), name);\n        var mode = FS.getMode(canRead, canWrite);\n        return FS.create(path, mode);\n      },\n      createDataFile: function (parent, name, data, canRead, canWrite, canOwn) {\n        var path = name ? PATH.join2(typeof parent === \"string\" ? parent : FS.getPath(parent), name) : parent;\n        var mode = FS.getMode(canRead, canWrite);\n        var node = FS.create(path, mode);\n\n        if (data) {\n          if (typeof data === \"string\") {\n            var arr = new Array(data.length);\n\n            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);\n\n            data = arr;\n          }\n\n          FS.chmod(node, mode | 146);\n          var stream = FS.open(node, \"w\");\n          FS.write(stream, data, 0, data.length, 0, canOwn);\n          FS.close(stream);\n          FS.chmod(node, mode);\n        }\n\n        return node;\n      },\n      createDevice: function (parent, name, input, output) {\n        var path = PATH.join2(typeof parent === \"string\" ? parent : FS.getPath(parent), name);\n        var mode = FS.getMode(!!input, !!output);\n        if (!FS.createDevice.major) FS.createDevice.major = 64;\n        var dev = FS.makedev(FS.createDevice.major++, 0);\n        FS.registerDevice(dev, {\n          open: function (stream) {\n            stream.seekable = false;\n          },\n          close: function (stream) {\n            if (output && output.buffer && output.buffer.length) {\n              output(10);\n            }\n          },\n          read: function (stream, buffer, offset, length, pos) {\n            var bytesRead = 0;\n\n            for (var i = 0; i < length; i++) {\n              var result;\n\n              try {\n                result = input();\n              } catch (e) {\n                throw new FS.ErrnoError(5);\n              }\n\n              if (result === undefined && bytesRead === 0) {\n                throw new FS.ErrnoError(11);\n              }\n\n              if (result === null || result === undefined) break;\n              bytesRead++;\n              buffer[offset + i] = result;\n            }\n\n            if (bytesRead) {\n              stream.node.timestamp = Date.now();\n            }\n\n            return bytesRead;\n          },\n          write: function (stream, buffer, offset, length, pos) {\n            for (var i = 0; i < length; i++) {\n              try {\n                output(buffer[offset + i]);\n              } catch (e) {\n                throw new FS.ErrnoError(5);\n              }\n            }\n\n            if (length) {\n              stream.node.timestamp = Date.now();\n            }\n\n            return i;\n          }\n        });\n        return FS.mkdev(path, mode, dev);\n      },\n      createLink: function (parent, name, target, canRead, canWrite) {\n        var path = PATH.join2(typeof parent === \"string\" ? parent : FS.getPath(parent), name);\n        return FS.symlink(target, path);\n      },\n      forceLoadFile: function (obj) {\n        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;\n        var success = true;\n\n        if (typeof XMLHttpRequest !== \"undefined\") {\n          throw new Error(\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\");\n        } else if (Module[\"read\"]) {\n          try {\n            obj.contents = intArrayFromString(Module[\"read\"](obj.url), true);\n            obj.usedBytes = obj.contents.length;\n          } catch (e) {\n            success = false;\n          }\n        } else {\n          throw new Error(\"Cannot load without read() or XMLHttpRequest.\");\n        }\n\n        if (!success) ___setErrNo(5);\n        return success;\n      },\n      createLazyFile: function (parent, name, url, canRead, canWrite) {\n        function LazyUint8Array() {\n          this.lengthKnown = false;\n          this.chunks = [];\n        }\n\n        LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {\n          if (idx > this.length - 1 || idx < 0) {\n            return undefined;\n          }\n\n          var chunkOffset = idx % this.chunkSize;\n          var chunkNum = idx / this.chunkSize | 0;\n          return this.getter(chunkNum)[chunkOffset];\n        };\n\n        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {\n          this.getter = getter;\n        };\n\n        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {\n          var xhr = new XMLHttpRequest();\n          xhr.open(\"HEAD\", url, false);\n          xhr.send(null);\n          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n          var datalength = Number(xhr.getResponseHeader(\"Content-length\"));\n          var header;\n          var hasByteServing = (header = xhr.getResponseHeader(\"Accept-Ranges\")) && header === \"bytes\";\n          var usesGzip = (header = xhr.getResponseHeader(\"Content-Encoding\")) && header === \"gzip\";\n          var chunkSize = 1024 * 1024;\n          if (!hasByteServing) chunkSize = datalength;\n\n          var doXHR = function (from, to) {\n            if (from > to) throw new Error(\"invalid range (\" + from + \", \" + to + \") or no bytes requested!\");\n            if (to > datalength - 1) throw new Error(\"only \" + datalength + \" bytes available! programmer error!\");\n            var xhr = new XMLHttpRequest();\n            xhr.open(\"GET\", url, false);\n            if (datalength !== chunkSize) xhr.setRequestHeader(\"Range\", \"bytes=\" + from + \"-\" + to);\n            if (typeof Uint8Array != \"undefined\") xhr.responseType = \"arraybuffer\";\n\n            if (xhr.overrideMimeType) {\n              xhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\n            }\n\n            xhr.send(null);\n            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n\n            if (xhr.response !== undefined) {\n              return new Uint8Array(xhr.response || []);\n            } else {\n              return intArrayFromString(xhr.responseText || \"\", true);\n            }\n          };\n\n          var lazyArray = this;\n          lazyArray.setDataGetter(function (chunkNum) {\n            var start = chunkNum * chunkSize;\n            var end = (chunkNum + 1) * chunkSize - 1;\n            end = Math.min(end, datalength - 1);\n\n            if (typeof lazyArray.chunks[chunkNum] === \"undefined\") {\n              lazyArray.chunks[chunkNum] = doXHR(start, end);\n            }\n\n            if (typeof lazyArray.chunks[chunkNum] === \"undefined\") throw new Error(\"doXHR failed!\");\n            return lazyArray.chunks[chunkNum];\n          });\n\n          if (usesGzip || !datalength) {\n            chunkSize = datalength = 1;\n            datalength = this.getter(0).length;\n            chunkSize = datalength;\n            console.log(\"LazyFiles on gzip forces download of the whole file when length is accessed\");\n          }\n\n          this._length = datalength;\n          this._chunkSize = chunkSize;\n          this.lengthKnown = true;\n        };\n\n        if (typeof XMLHttpRequest !== \"undefined\") {\n          if (!ENVIRONMENT_IS_WORKER) throw \"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc\";\n          var lazyArray = new LazyUint8Array();\n          Object.defineProperties(lazyArray, {\n            length: {\n              get: function () {\n                if (!this.lengthKnown) {\n                  this.cacheLength();\n                }\n\n                return this._length;\n              }\n            },\n            chunkSize: {\n              get: function () {\n                if (!this.lengthKnown) {\n                  this.cacheLength();\n                }\n\n                return this._chunkSize;\n              }\n            }\n          });\n          var properties = {\n            isDevice: false,\n            contents: lazyArray\n          };\n        } else {\n          var properties = {\n            isDevice: false,\n            url: url\n          };\n        }\n\n        var node = FS.createFile(parent, name, properties, canRead, canWrite);\n\n        if (properties.contents) {\n          node.contents = properties.contents;\n        } else if (properties.url) {\n          node.contents = null;\n          node.url = properties.url;\n        }\n\n        Object.defineProperties(node, {\n          usedBytes: {\n            get: function () {\n              return this.contents.length;\n            }\n          }\n        });\n        var stream_ops = {};\n        var keys = Object.keys(node.stream_ops);\n        keys.forEach(function (key) {\n          var fn = node.stream_ops[key];\n\n          stream_ops[key] = function forceLoadLazyFile() {\n            if (!FS.forceLoadFile(node)) {\n              throw new FS.ErrnoError(5);\n            }\n\n            return fn.apply(null, arguments);\n          };\n        });\n\n        stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) {\n          if (!FS.forceLoadFile(node)) {\n            throw new FS.ErrnoError(5);\n          }\n\n          var contents = stream.node.contents;\n          if (position >= contents.length) return 0;\n          var size = Math.min(contents.length - position, length);\n\n          if (contents.slice) {\n            for (var i = 0; i < size; i++) {\n              buffer[offset + i] = contents[position + i];\n            }\n          } else {\n            for (var i = 0; i < size; i++) {\n              buffer[offset + i] = contents.get(position + i);\n            }\n          }\n\n          return size;\n        };\n\n        node.stream_ops = stream_ops;\n        return node;\n      },\n      createPreloadedFile: function (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {\n        Browser.init();\n        var fullname = name ? PATH.resolve(PATH.join2(parent, name)) : parent;\n        var dep = getUniqueRunDependency(\"cp \" + fullname);\n\n        function processData(byteArray) {\n          function finish(byteArray) {\n            if (preFinish) preFinish();\n\n            if (!dontCreateFile) {\n              FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);\n            }\n\n            if (onload) onload();\n            removeRunDependency(dep);\n          }\n\n          var handled = false;\n          Module[\"preloadPlugins\"].forEach(function (plugin) {\n            if (handled) return;\n\n            if (plugin[\"canHandle\"](fullname)) {\n              plugin[\"handle\"](byteArray, fullname, finish, function () {\n                if (onerror) onerror();\n                removeRunDependency(dep);\n              });\n              handled = true;\n            }\n          });\n          if (!handled) finish(byteArray);\n        }\n\n        addRunDependency(dep);\n\n        if (typeof url == \"string\") {\n          Browser.asyncLoad(url, function (byteArray) {\n            processData(byteArray);\n          }, onerror);\n        } else {\n          processData(url);\n        }\n      },\n      indexedDB: function () {\n        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\n      },\n      DB_NAME: function () {\n        return \"EM_FS_\" + window.location.pathname;\n      },\n      DB_VERSION: 20,\n      DB_STORE_NAME: \"FILE_DATA\",\n      saveFilesToDB: function (paths, onload, onerror) {\n        onload = onload || function () {};\n\n        onerror = onerror || function () {};\n\n        var indexedDB = FS.indexedDB();\n\n        try {\n          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);\n        } catch (e) {\n          return onerror(e);\n        }\n\n        openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {\n          console.log(\"creating db\");\n          var db = openRequest.result;\n          db.createObjectStore(FS.DB_STORE_NAME);\n        };\n\n        openRequest.onsuccess = function openRequest_onsuccess() {\n          var db = openRequest.result;\n          var transaction = db.transaction([FS.DB_STORE_NAME], \"readwrite\");\n          var files = transaction.objectStore(FS.DB_STORE_NAME);\n          var ok = 0,\n              fail = 0,\n              total = paths.length;\n\n          function finish() {\n            if (fail == 0) onload();else onerror();\n          }\n\n          paths.forEach(function (path) {\n            var putRequest = files.put(FS.analyzePath(path).object.contents, path);\n\n            putRequest.onsuccess = function putRequest_onsuccess() {\n              ok++;\n              if (ok + fail == total) finish();\n            };\n\n            putRequest.onerror = function putRequest_onerror() {\n              fail++;\n              if (ok + fail == total) finish();\n            };\n          });\n          transaction.onerror = onerror;\n        };\n\n        openRequest.onerror = onerror;\n      },\n      loadFilesFromDB: function (paths, onload, onerror) {\n        onload = onload || function () {};\n\n        onerror = onerror || function () {};\n\n        var indexedDB = FS.indexedDB();\n\n        try {\n          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);\n        } catch (e) {\n          return onerror(e);\n        }\n\n        openRequest.onupgradeneeded = onerror;\n\n        openRequest.onsuccess = function openRequest_onsuccess() {\n          var db = openRequest.result;\n\n          try {\n            var transaction = db.transaction([FS.DB_STORE_NAME], \"readonly\");\n          } catch (e) {\n            onerror(e);\n            return;\n          }\n\n          var files = transaction.objectStore(FS.DB_STORE_NAME);\n          var ok = 0,\n              fail = 0,\n              total = paths.length;\n\n          function finish() {\n            if (fail == 0) onload();else onerror();\n          }\n\n          paths.forEach(function (path) {\n            var getRequest = files.get(path);\n\n            getRequest.onsuccess = function getRequest_onsuccess() {\n              if (FS.analyzePath(path).exists) {\n                FS.unlink(path);\n              }\n\n              FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);\n              ok++;\n              if (ok + fail == total) finish();\n            };\n\n            getRequest.onerror = function getRequest_onerror() {\n              fail++;\n              if (ok + fail == total) finish();\n            };\n          });\n          transaction.onerror = onerror;\n        };\n\n        openRequest.onerror = onerror;\n      }\n    };\n    var ERRNO_CODES = {\n      EPERM: 1,\n      ENOENT: 2,\n      ESRCH: 3,\n      EINTR: 4,\n      EIO: 5,\n      ENXIO: 6,\n      E2BIG: 7,\n      ENOEXEC: 8,\n      EBADF: 9,\n      ECHILD: 10,\n      EAGAIN: 11,\n      EWOULDBLOCK: 11,\n      ENOMEM: 12,\n      EACCES: 13,\n      EFAULT: 14,\n      ENOTBLK: 15,\n      EBUSY: 16,\n      EEXIST: 17,\n      EXDEV: 18,\n      ENODEV: 19,\n      ENOTDIR: 20,\n      EISDIR: 21,\n      EINVAL: 22,\n      ENFILE: 23,\n      EMFILE: 24,\n      ENOTTY: 25,\n      ETXTBSY: 26,\n      EFBIG: 27,\n      ENOSPC: 28,\n      ESPIPE: 29,\n      EROFS: 30,\n      EMLINK: 31,\n      EPIPE: 32,\n      EDOM: 33,\n      ERANGE: 34,\n      ENOMSG: 42,\n      EIDRM: 43,\n      ECHRNG: 44,\n      EL2NSYNC: 45,\n      EL3HLT: 46,\n      EL3RST: 47,\n      ELNRNG: 48,\n      EUNATCH: 49,\n      ENOCSI: 50,\n      EL2HLT: 51,\n      EDEADLK: 35,\n      ENOLCK: 37,\n      EBADE: 52,\n      EBADR: 53,\n      EXFULL: 54,\n      ENOANO: 55,\n      EBADRQC: 56,\n      EBADSLT: 57,\n      EDEADLOCK: 35,\n      EBFONT: 59,\n      ENOSTR: 60,\n      ENODATA: 61,\n      ETIME: 62,\n      ENOSR: 63,\n      ENONET: 64,\n      ENOPKG: 65,\n      EREMOTE: 66,\n      ENOLINK: 67,\n      EADV: 68,\n      ESRMNT: 69,\n      ECOMM: 70,\n      EPROTO: 71,\n      EMULTIHOP: 72,\n      EDOTDOT: 73,\n      EBADMSG: 74,\n      ENOTUNIQ: 76,\n      EBADFD: 77,\n      EREMCHG: 78,\n      ELIBACC: 79,\n      ELIBBAD: 80,\n      ELIBSCN: 81,\n      ELIBMAX: 82,\n      ELIBEXEC: 83,\n      ENOSYS: 38,\n      ENOTEMPTY: 39,\n      ENAMETOOLONG: 36,\n      ELOOP: 40,\n      EOPNOTSUPP: 95,\n      EPFNOSUPPORT: 96,\n      ECONNRESET: 104,\n      ENOBUFS: 105,\n      EAFNOSUPPORT: 97,\n      EPROTOTYPE: 91,\n      ENOTSOCK: 88,\n      ENOPROTOOPT: 92,\n      ESHUTDOWN: 108,\n      ECONNREFUSED: 111,\n      EADDRINUSE: 98,\n      ECONNABORTED: 103,\n      ENETUNREACH: 101,\n      ENETDOWN: 100,\n      ETIMEDOUT: 110,\n      EHOSTDOWN: 112,\n      EHOSTUNREACH: 113,\n      EINPROGRESS: 115,\n      EALREADY: 114,\n      EDESTADDRREQ: 89,\n      EMSGSIZE: 90,\n      EPROTONOSUPPORT: 93,\n      ESOCKTNOSUPPORT: 94,\n      EADDRNOTAVAIL: 99,\n      ENETRESET: 102,\n      EISCONN: 106,\n      ENOTCONN: 107,\n      ETOOMANYREFS: 109,\n      EUSERS: 87,\n      EDQUOT: 122,\n      ESTALE: 116,\n      ENOTSUP: 95,\n      ENOMEDIUM: 123,\n      EILSEQ: 84,\n      EOVERFLOW: 75,\n      ECANCELED: 125,\n      ENOTRECOVERABLE: 131,\n      EOWNERDEAD: 130,\n      ESTRPIPE: 86\n    };\n    var SYSCALLS = {\n      DEFAULT_POLLMASK: 5,\n      mappings: {},\n      umask: 511,\n      calculateAt: function (dirfd, path) {\n        if (path[0] !== \"/\") {\n          var dir;\n\n          if (dirfd === -100) {\n            dir = FS.cwd();\n          } else {\n            var dirstream = FS.getStream(dirfd);\n            if (!dirstream) throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n            dir = dirstream.path;\n          }\n\n          path = PATH.join2(dir, path);\n        }\n\n        return path;\n      },\n      doStat: function (func, path, buf) {\n        try {\n          var stat = func(path);\n        } catch (e) {\n          if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {\n            return -ERRNO_CODES.ENOTDIR;\n          }\n\n          throw e;\n        }\n\n        HEAP32[buf >> 2] = stat.dev;\n        HEAP32[buf + 4 >> 2] = 0;\n        HEAP32[buf + 8 >> 2] = stat.ino;\n        HEAP32[buf + 12 >> 2] = stat.mode;\n        HEAP32[buf + 16 >> 2] = stat.nlink;\n        HEAP32[buf + 20 >> 2] = stat.uid;\n        HEAP32[buf + 24 >> 2] = stat.gid;\n        HEAP32[buf + 28 >> 2] = stat.rdev;\n        HEAP32[buf + 32 >> 2] = 0;\n        HEAP32[buf + 36 >> 2] = stat.size;\n        HEAP32[buf + 40 >> 2] = 4096;\n        HEAP32[buf + 44 >> 2] = stat.blocks;\n        HEAP32[buf + 48 >> 2] = stat.atime.getTime() / 1e3 | 0;\n        HEAP32[buf + 52 >> 2] = 0;\n        HEAP32[buf + 56 >> 2] = stat.mtime.getTime() / 1e3 | 0;\n        HEAP32[buf + 60 >> 2] = 0;\n        HEAP32[buf + 64 >> 2] = stat.ctime.getTime() / 1e3 | 0;\n        HEAP32[buf + 68 >> 2] = 0;\n        HEAP32[buf + 72 >> 2] = stat.ino;\n        return 0;\n      },\n      doMsync: function (addr, stream, len, flags) {\n        var buffer = new Uint8Array(HEAPU8.subarray(addr, addr + len));\n        FS.msync(stream, buffer, 0, len, flags);\n      },\n      doMkdir: function (path, mode) {\n        path = PATH.normalize(path);\n        if (path[path.length - 1] === \"/\") path = path.substr(0, path.length - 1);\n        FS.mkdir(path, mode, 0);\n        return 0;\n      },\n      doMknod: function (path, mode, dev) {\n        switch (mode & 61440) {\n          case 32768:\n          case 8192:\n          case 24576:\n          case 4096:\n          case 49152:\n            break;\n\n          default:\n            return -ERRNO_CODES.EINVAL;\n        }\n\n        FS.mknod(path, mode, dev);\n        return 0;\n      },\n      doReadlink: function (path, buf, bufsize) {\n        if (bufsize <= 0) return -ERRNO_CODES.EINVAL;\n        var ret = FS.readlink(path);\n        var len = Math.min(bufsize, lengthBytesUTF8(ret));\n        var endChar = HEAP8[buf + len];\n        stringToUTF8(ret, buf, bufsize + 1);\n        HEAP8[buf + len] = endChar;\n        return len;\n      },\n      doAccess: function (path, amode) {\n        if (amode & ~7) {\n          return -ERRNO_CODES.EINVAL;\n        }\n\n        var node;\n        var lookup = FS.lookupPath(path, {\n          follow: true\n        });\n        node = lookup.node;\n        var perms = \"\";\n        if (amode & 4) perms += \"r\";\n        if (amode & 2) perms += \"w\";\n        if (amode & 1) perms += \"x\";\n\n        if (perms && FS.nodePermissions(node, perms)) {\n          return -ERRNO_CODES.EACCES;\n        }\n\n        return 0;\n      },\n      doDup: function (path, flags, suggestFD) {\n        var suggest = FS.getStream(suggestFD);\n        if (suggest) FS.close(suggest);\n        return FS.open(path, flags, 0, suggestFD, suggestFD).fd;\n      },\n      doReadv: function (stream, iov, iovcnt, offset) {\n        var ret = 0;\n\n        for (var i = 0; i < iovcnt; i++) {\n          var ptr = HEAP32[iov + i * 8 >> 2];\n          var len = HEAP32[iov + (i * 8 + 4) >> 2];\n          var curr = FS.read(stream, HEAP8, ptr, len, offset);\n          if (curr < 0) return -1;\n          ret += curr;\n          if (curr < len) break;\n        }\n\n        return ret;\n      },\n      doWritev: function (stream, iov, iovcnt, offset) {\n        var ret = 0;\n\n        for (var i = 0; i < iovcnt; i++) {\n          var ptr = HEAP32[iov + i * 8 >> 2];\n          var len = HEAP32[iov + (i * 8 + 4) >> 2];\n          var curr = FS.write(stream, HEAP8, ptr, len, offset);\n          if (curr < 0) return -1;\n          ret += curr;\n        }\n\n        return ret;\n      },\n      varargs: 0,\n      get: function (varargs) {\n        SYSCALLS.varargs += 4;\n        var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];\n        return ret;\n      },\n      getStr: function () {\n        var ret = UTF8ToString(SYSCALLS.get());\n        return ret;\n      },\n      getStreamFromFD: function () {\n        var stream = FS.getStream(SYSCALLS.get());\n        if (!stream) throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n        return stream;\n      },\n      getSocketFromFD: function () {\n        var socket = SOCKFS.getSocket(SYSCALLS.get());\n        if (!socket) throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n        return socket;\n      },\n      getSocketAddress: function (allowNull) {\n        var addrp = SYSCALLS.get(),\n            addrlen = SYSCALLS.get();\n        if (allowNull && addrp === 0) return null;\n\n        var info = __read_sockaddr(addrp, addrlen);\n\n        if (info.errno) throw new FS.ErrnoError(info.errno);\n        info.addr = DNS.lookup_addr(info.addr) || info.addr;\n        return info;\n      },\n      get64: function () {\n        var low = SYSCALLS.get(),\n            high = SYSCALLS.get();\n        return low;\n      },\n      getZero: function () {\n        SYSCALLS.get();\n      }\n    };\n\n    function ___syscall140(which, varargs) {\n      SYSCALLS.varargs = varargs;\n\n      try {\n        var stream = SYSCALLS.getStreamFromFD(),\n            offset_high = SYSCALLS.get(),\n            offset_low = SYSCALLS.get(),\n            result = SYSCALLS.get(),\n            whence = SYSCALLS.get();\n        var offset = offset_low;\n        FS.llseek(stream, offset, whence);\n        HEAP32[result >> 2] = stream.position;\n        if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null;\n        return 0;\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\n        return -e.errno;\n      }\n    }\n\n    function ___syscall145(which, varargs) {\n      SYSCALLS.varargs = varargs;\n\n      try {\n        var stream = SYSCALLS.getStreamFromFD(),\n            iov = SYSCALLS.get(),\n            iovcnt = SYSCALLS.get();\n        return SYSCALLS.doReadv(stream, iov, iovcnt);\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\n        return -e.errno;\n      }\n    }\n\n    function ___syscall146(which, varargs) {\n      SYSCALLS.varargs = varargs;\n\n      try {\n        var stream = SYSCALLS.getStreamFromFD(),\n            iov = SYSCALLS.get(),\n            iovcnt = SYSCALLS.get();\n        return SYSCALLS.doWritev(stream, iov, iovcnt);\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\n        return -e.errno;\n      }\n    }\n\n    function ___syscall221(which, varargs) {\n      SYSCALLS.varargs = varargs;\n\n      try {\n        var stream = SYSCALLS.getStreamFromFD(),\n            cmd = SYSCALLS.get();\n\n        switch (cmd) {\n          case 0:\n            {\n              var arg = SYSCALLS.get();\n\n              if (arg < 0) {\n                return -ERRNO_CODES.EINVAL;\n              }\n\n              var newStream;\n              newStream = FS.open(stream.path, stream.flags, 0, arg);\n              return newStream.fd;\n            }\n\n          case 1:\n          case 2:\n            return 0;\n\n          case 3:\n            return stream.flags;\n\n          case 4:\n            {\n              var arg = SYSCALLS.get();\n              stream.flags |= arg;\n              return 0;\n            }\n\n          case 12:\n            {\n              var arg = SYSCALLS.get();\n              var offset = 0;\n              HEAP16[arg + offset >> 1] = 2;\n              return 0;\n            }\n\n          case 13:\n          case 14:\n            return 0;\n\n          case 16:\n          case 8:\n            return -ERRNO_CODES.EINVAL;\n\n          case 9:\n            ___setErrNo(ERRNO_CODES.EINVAL);\n\n            return -1;\n\n          default:\n            {\n              return -ERRNO_CODES.EINVAL;\n            }\n        }\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\n        return -e.errno;\n      }\n    }\n\n    function ___syscall5(which, varargs) {\n      SYSCALLS.varargs = varargs;\n\n      try {\n        var pathname = SYSCALLS.getStr(),\n            flags = SYSCALLS.get(),\n            mode = SYSCALLS.get();\n        var stream = FS.open(pathname, flags, mode);\n        return stream.fd;\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\n        return -e.errno;\n      }\n    }\n\n    function ___syscall54(which, varargs) {\n      SYSCALLS.varargs = varargs;\n\n      try {\n        var stream = SYSCALLS.getStreamFromFD(),\n            op = SYSCALLS.get();\n\n        switch (op) {\n          case 21509:\n          case 21505:\n            {\n              if (!stream.tty) return -ERRNO_CODES.ENOTTY;\n              return 0;\n            }\n\n          case 21510:\n          case 21511:\n          case 21512:\n          case 21506:\n          case 21507:\n          case 21508:\n            {\n              if (!stream.tty) return -ERRNO_CODES.ENOTTY;\n              return 0;\n            }\n\n          case 21519:\n            {\n              if (!stream.tty) return -ERRNO_CODES.ENOTTY;\n              var argp = SYSCALLS.get();\n              HEAP32[argp >> 2] = 0;\n              return 0;\n            }\n\n          case 21520:\n            {\n              if (!stream.tty) return -ERRNO_CODES.ENOTTY;\n              return -ERRNO_CODES.EINVAL;\n            }\n\n          case 21531:\n            {\n              var argp = SYSCALLS.get();\n              return FS.ioctl(stream, op, argp);\n            }\n\n          case 21523:\n            {\n              if (!stream.tty) return -ERRNO_CODES.ENOTTY;\n              return 0;\n            }\n\n          case 21524:\n            {\n              if (!stream.tty) return -ERRNO_CODES.ENOTTY;\n              return 0;\n            }\n\n          default:\n            abort(\"bad ioctl syscall \" + op);\n        }\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\n        return -e.errno;\n      }\n    }\n\n    function ___syscall6(which, varargs) {\n      SYSCALLS.varargs = varargs;\n\n      try {\n        var stream = SYSCALLS.getStreamFromFD();\n        FS.close(stream);\n        return 0;\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\n        return -e.errno;\n      }\n    }\n\n    function ___unlock() {}\n\n    function _abort() {\n      Module[\"abort\"]();\n    }\n\n    function _clock() {\n      if (_clock.start === undefined) _clock.start = Date.now();\n      return (Date.now() - _clock.start) * (1e6 / 1e3) | 0;\n    }\n\n    function _emscripten_get_heap_size() {\n      return TOTAL_MEMORY;\n    }\n\n    function abortOnCannotGrowMemory(requestedSize) {\n      abort(\"OOM\");\n    }\n\n    function emscripten_realloc_buffer(size) {\n      var PAGE_MULTIPLE = 65536;\n      size = alignUp(size, PAGE_MULTIPLE);\n      var old = Module[\"buffer\"];\n      var oldSize = old.byteLength;\n\n      try {\n        var result = wasmMemory.grow((size - oldSize) / 65536);\n\n        if (result !== (-1 | 0)) {\n          return Module[\"buffer\"] = wasmMemory.buffer;\n        } else {\n          return null;\n        }\n      } catch (e) {\n        return null;\n      }\n    }\n\n    function _emscripten_resize_heap(requestedSize) {\n      var oldSize = _emscripten_get_heap_size();\n\n      var PAGE_MULTIPLE = 65536;\n      var LIMIT = 2147483648 - PAGE_MULTIPLE;\n\n      if (requestedSize > LIMIT) {\n        return false;\n      }\n\n      var MIN_TOTAL_MEMORY = 16777216;\n      var newSize = Math.max(oldSize, MIN_TOTAL_MEMORY);\n\n      while (newSize < requestedSize) {\n        if (newSize <= 536870912) {\n          newSize = alignUp(2 * newSize, PAGE_MULTIPLE);\n        } else {\n          newSize = Math.min(alignUp((3 * newSize + 2147483648) / 4, PAGE_MULTIPLE), LIMIT);\n        }\n      }\n\n      var replacement = emscripten_realloc_buffer(newSize);\n\n      if (!replacement || replacement.byteLength != newSize) {\n        return false;\n      }\n\n      updateGlobalBuffer(replacement);\n      updateGlobalBufferViews();\n      TOTAL_MEMORY = newSize;\n      return true;\n    }\n\n    var _llvm_cos_f32 = Math_cos;\n    var _llvm_cos_f64 = Math_cos;\n    var _llvm_sin_f32 = Math_sin;\n    var _llvm_sin_f64 = Math_sin;\n\n    function _llvm_trap() {\n      abort(\"trap!\");\n    }\n\n    function _emscripten_memcpy_big(dest, src, num) {\n      HEAPU8.set(HEAPU8.subarray(src, src + num), dest);\n    }\n\n    FS.staticInit();\n\n    if (ENVIRONMENT_IS_NODE) {\n      var fs = require(\"fs\");\n\n      var NODEJS_PATH = require(\"path\");\n\n      NODEFS.staticInit();\n    }\n\n    function intArrayFromString(stringy, dontAddNull, length) {\n      var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\n      var u8array = new Array(len);\n      var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n      if (dontAddNull) u8array.length = numBytesWritten;\n      return u8array;\n    }\n\n    var asmGlobalArg = {};\n    var asmLibraryArg = {\n      \"b\": abort,\n      \"c\": ___assert_fail,\n      \"h\": ___cxa_allocate_exception,\n      \"s\": ___cxa_pure_virtual,\n      \"g\": ___cxa_throw,\n      \"r\": ___lock,\n      \"j\": ___setErrNo,\n      \"A\": ___syscall140,\n      \"z\": ___syscall145,\n      \"q\": ___syscall146,\n      \"f\": ___syscall221,\n      \"y\": ___syscall5,\n      \"p\": ___syscall54,\n      \"o\": ___syscall6,\n      \"i\": ___unlock,\n      \"d\": _abort,\n      \"e\": _clock,\n      \"x\": _emscripten_get_heap_size,\n      \"w\": _emscripten_memcpy_big,\n      \"v\": _emscripten_resize_heap,\n      \"n\": _llvm_cos_f32,\n      \"m\": _llvm_cos_f64,\n      \"l\": _llvm_sin_f32,\n      \"k\": _llvm_sin_f64,\n      \"u\": _llvm_trap,\n      \"t\": abortOnCannotGrowMemory,\n      \"a\": DYNAMICTOP_PTR\n    };\n    var asm = Module[\"asm\"](asmGlobalArg, asmLibraryArg, buffer);\n    Module[\"asm\"] = asm;\n\n    var __GLOBAL__sub_I_CubicSolver_cpp = Module[\"__GLOBAL__sub_I_CubicSolver_cpp\"] = function () {\n      return Module[\"asm\"][\"B\"].apply(null, arguments);\n    };\n\n    var ___errno_location = Module[\"___errno_location\"] = function () {\n      return Module[\"asm\"][\"C\"].apply(null, arguments);\n    };\n\n    var _emscripten_bind_Path___destroy___0 = Module[\"_emscripten_bind_Path___destroy___0\"] = function () {\n      return Module[\"asm\"][\"D\"].apply(null, arguments);\n    };\n\n    var _emscripten_bind_Path_get_bIsCurve_0 = Module[\"_emscripten_bind_Path_get_bIsCurve_0\"] = function () {\n      return Module[\"asm\"][\"E\"].apply(null, arguments);\n    };\n\n    var _emscripten_bind_Path_get_nPoints_0 = Module[\"_emscripten_bind_Path_get_nPoints_0\"] = function () {\n      return Module[\"asm\"][\"F\"].apply(null, arguments);\n    };\n\n    var _emscripten_bind_Path_get_pPoints_1 = Module[\"_emscripten_bind_Path_get_pPoints_1\"] = function () {\n      return Module[\"asm\"][\"G\"].apply(null, arguments);\n    };\n\n    var _emscripten_bind_Point___destroy___0 = Module[\"_emscripten_bind_Point___destroy___0\"] = function () {\n      return Module[\"asm\"][\"H\"].apply(null, arguments);\n    };\n\n    var _emscripten_bind_Point_get_x_0 = Module[\"_emscripten_bind_Point_get_x_0\"] = function () {\n      return Module[\"asm\"][\"I\"].apply(null, arguments);\n    };\n\n    var _emscripten_bind_Point_get_y_0 = Module[\"_emscripten_bind_Point_get_y_0\"] = function () {\n      return Module[\"asm\"][\"J\"].apply(null, arguments);\n    };\n\n    var _emscripten_bind_VectorPath_GetPath_1 = Module[\"_emscripten_bind_VectorPath_GetPath_1\"] = function () {\n      return Module[\"asm\"][\"K\"].apply(null, arguments);\n    };\n\n    var _emscripten_bind_VectorPath_PathCount_0 = Module[\"_emscripten_bind_VectorPath_PathCount_0\"] = function () {\n      return Module[\"asm\"][\"L\"].apply(null, arguments);\n    };\n\n    var _emscripten_bind_VectorPath___destroy___0 = Module[\"_emscripten_bind_VectorPath___destroy___0\"] = function () {\n      return Module[\"asm\"][\"M\"].apply(null, arguments);\n    };\n\n    var _emscripten_bind_VectorizeExport_GetVector_1 = Module[\"_emscripten_bind_VectorizeExport_GetVector_1\"] = function () {\n      return Module[\"asm\"][\"N\"].apply(null, arguments);\n    };\n\n    var _emscripten_bind_VectorizeExport_VectorCount_0 = Module[\"_emscripten_bind_VectorizeExport_VectorCount_0\"] = function () {\n      return Module[\"asm\"][\"O\"].apply(null, arguments);\n    };\n\n    var _emscripten_bind_VectorizeExport_VectorizeExport_0 = Module[\"_emscripten_bind_VectorizeExport_VectorizeExport_0\"] = function () {\n      return Module[\"asm\"][\"P\"].apply(null, arguments);\n    };\n\n    var _emscripten_bind_VectorizeExport_VectorizeToData_4 = Module[\"_emscripten_bind_VectorizeExport_VectorizeToData_4\"] = function () {\n      return Module[\"asm\"][\"Q\"].apply(null, arguments);\n    };\n\n    var _emscripten_bind_VectorizeExport___destroy___0 = Module[\"_emscripten_bind_VectorizeExport___destroy___0\"] = function () {\n      return Module[\"asm\"][\"R\"].apply(null, arguments);\n    };\n\n    var _emscripten_bind_VoidPtr___destroy___0 = Module[\"_emscripten_bind_VoidPtr___destroy___0\"] = function () {\n      return Module[\"asm\"][\"S\"].apply(null, arguments);\n    };\n\n    var _free = Module[\"_free\"] = function () {\n      return Module[\"asm\"][\"T\"].apply(null, arguments);\n    };\n\n    var _malloc = Module[\"_malloc\"] = function () {\n      return Module[\"asm\"][\"U\"].apply(null, arguments);\n    };\n\n    var stackAlloc = Module[\"stackAlloc\"] = function () {\n      return Module[\"asm\"][\"X\"].apply(null, arguments);\n    };\n\n    var dynCall_v = Module[\"dynCall_v\"] = function () {\n      return Module[\"asm\"][\"V\"].apply(null, arguments);\n    };\n\n    var dynCall_vi = Module[\"dynCall_vi\"] = function () {\n      return Module[\"asm\"][\"W\"].apply(null, arguments);\n    };\n\n    Module[\"asm\"] = asm;\n    Module[\"setValue\"] = setValue;\n    Module[\"getValue\"] = getValue;\n\n    Module[\"then\"] = function (func) {\n      if (Module[\"calledRun\"]) {\n        func(Module);\n      } else {\n        var old = Module[\"onRuntimeInitialized\"];\n\n        Module[\"onRuntimeInitialized\"] = function () {\n          if (old) old();\n          func(Module);\n        };\n      }\n\n      return Module;\n    };\n\n    function ExitStatus(status) {\n      this.name = \"ExitStatus\";\n      this.message = \"Program terminated with exit(\" + status + \")\";\n      this.status = status;\n    }\n\n    ExitStatus.prototype = new Error();\n    ExitStatus.prototype.constructor = ExitStatus;\n\n    dependenciesFulfilled = function runCaller() {\n      if (!Module[\"calledRun\"]) run();\n      if (!Module[\"calledRun\"]) dependenciesFulfilled = runCaller;\n    };\n\n    function run(args) {\n      args = args || Module[\"arguments\"];\n\n      if (runDependencies > 0) {\n        return;\n      }\n\n      preRun();\n      if (runDependencies > 0) return;\n      if (Module[\"calledRun\"]) return;\n\n      function doRun() {\n        if (Module[\"calledRun\"]) return;\n        Module[\"calledRun\"] = true;\n        if (ABORT) return;\n        ensureInitRuntime();\n        preMain();\n        if (Module[\"onRuntimeInitialized\"]) Module[\"onRuntimeInitialized\"]();\n        postRun();\n      }\n\n      if (Module[\"setStatus\"]) {\n        Module[\"setStatus\"](\"Running...\");\n        setTimeout(function () {\n          setTimeout(function () {\n            Module[\"setStatus\"](\"\");\n          }, 1);\n          doRun();\n        }, 1);\n      } else {\n        doRun();\n      }\n    }\n\n    Module[\"run\"] = run;\n\n    function abort(what) {\n      if (Module[\"onAbort\"]) {\n        Module[\"onAbort\"](what);\n      }\n\n      if (what !== undefined) {\n        out(what);\n        err(what);\n        what = JSON.stringify(what);\n      } else {\n        what = \"\";\n      }\n\n      ABORT = true;\n      EXITSTATUS = 1;\n      throw \"abort(\" + what + \"). Build with -s ASSERTIONS=1 for more info.\";\n    }\n\n    Module[\"abort\"] = abort;\n\n    if (Module[\"preInit\"]) {\n      if (typeof Module[\"preInit\"] == \"function\") Module[\"preInit\"] = [Module[\"preInit\"]];\n\n      while (Module[\"preInit\"].length > 0) {\n        Module[\"preInit\"].pop()();\n      }\n    }\n\n    Module[\"noExitRuntime\"] = true;\n    run();\n\n    function WrapperObject() {}\n\n    WrapperObject.prototype = Object.create(WrapperObject.prototype);\n    WrapperObject.prototype.constructor = WrapperObject;\n    WrapperObject.prototype.__class__ = WrapperObject;\n    WrapperObject.__cache__ = {};\n    Module[\"WrapperObject\"] = WrapperObject;\n\n    function getCache(__class__) {\n      return (__class__ || WrapperObject).__cache__;\n    }\n\n    Module[\"getCache\"] = getCache;\n\n    function wrapPointer(ptr, __class__) {\n      var cache = getCache(__class__);\n      var ret = cache[ptr];\n      if (ret) return ret;\n      ret = Object.create((__class__ || WrapperObject).prototype);\n      ret.ptr = ptr;\n      return cache[ptr] = ret;\n    }\n\n    Module[\"wrapPointer\"] = wrapPointer;\n\n    function castObject(obj, __class__) {\n      return wrapPointer(obj.ptr, __class__);\n    }\n\n    Module[\"castObject\"] = castObject;\n    Module[\"NULL\"] = wrapPointer(0);\n\n    function destroy(obj) {\n      if (!obj[\"__destroy__\"]) throw \"Error: Cannot destroy object. (Did you create it yourself?)\";\n      obj[\"__destroy__\"]();\n      delete getCache(obj.__class__)[obj.ptr];\n    }\n\n    Module[\"destroy\"] = destroy;\n\n    function compare(obj1, obj2) {\n      return obj1.ptr === obj2.ptr;\n    }\n\n    Module[\"compare\"] = compare;\n\n    function getPointer(obj) {\n      return obj.ptr;\n    }\n\n    Module[\"getPointer\"] = getPointer;\n\n    function getClass(obj) {\n      return obj.__class__;\n    }\n\n    Module[\"getClass\"] = getClass;\n    var ensureCache = {\n      buffer: 0,\n      size: 0,\n      pos: 0,\n      temps: [],\n      needed: 0,\n      prepare: function () {\n        if (ensureCache.needed) {\n          for (var i = 0; i < ensureCache.temps.length; i++) {\n            Module[\"_free\"](ensureCache.temps[i]);\n          }\n\n          ensureCache.temps.length = 0;\n          Module[\"_free\"](ensureCache.buffer);\n          ensureCache.buffer = 0;\n          ensureCache.size += ensureCache.needed;\n          ensureCache.needed = 0;\n        }\n\n        if (!ensureCache.buffer) {\n          ensureCache.size += 128;\n          ensureCache.buffer = Module[\"_malloc\"](ensureCache.size);\n          assert(ensureCache.buffer);\n        }\n\n        ensureCache.pos = 0;\n      },\n      alloc: function (array, view) {\n        assert(ensureCache.buffer);\n        var bytes = view.BYTES_PER_ELEMENT;\n        var len = array.length * bytes;\n        len = len + 7 & -8;\n        var ret;\n\n        if (ensureCache.pos + len >= ensureCache.size) {\n          assert(len > 0);\n          ensureCache.needed += len;\n          ret = Module[\"_malloc\"](len);\n          ensureCache.temps.push(ret);\n        } else {\n          ret = ensureCache.buffer + ensureCache.pos;\n          ensureCache.pos += len;\n        }\n\n        return ret;\n      },\n      copy: function (array, view, offset) {\n        var offsetShifted = offset;\n        var bytes = view.BYTES_PER_ELEMENT;\n\n        switch (bytes) {\n          case 2:\n            offsetShifted >>= 1;\n            break;\n\n          case 4:\n            offsetShifted >>= 2;\n            break;\n\n          case 8:\n            offsetShifted >>= 3;\n            break;\n        }\n\n        for (var i = 0; i < array.length; i++) {\n          view[offsetShifted + i] = array[i];\n        }\n      }\n    };\n\n    function ensureInt8(value) {\n      if (typeof value === \"object\") {\n        var offset = ensureCache.alloc(value, HEAP8);\n        ensureCache.copy(value, HEAP8, offset);\n        return offset;\n      }\n\n      return value;\n    }\n\n    function VectorizeExport() {\n      this.ptr = _emscripten_bind_VectorizeExport_VectorizeExport_0();\n      getCache(VectorizeExport)[this.ptr] = this;\n    }\n\n    VectorizeExport.prototype = Object.create(WrapperObject.prototype);\n    VectorizeExport.prototype.constructor = VectorizeExport;\n    VectorizeExport.prototype.__class__ = VectorizeExport;\n    VectorizeExport.__cache__ = {};\n    Module[\"VectorizeExport\"] = VectorizeExport;\n\n    VectorizeExport.prototype[\"VectorizeToData\"] = VectorizeExport.prototype.VectorizeToData = function (arg0, arg1, arg2, arg3) {\n      var self = this.ptr;\n      ensureCache.prepare();\n\n      if (typeof arg0 == \"object\") {\n        arg0 = ensureInt8(arg0);\n      }\n\n      if (arg1 && typeof arg1 === \"object\") arg1 = arg1.ptr;\n      if (arg2 && typeof arg2 === \"object\") arg2 = arg2.ptr;\n      if (arg3 && typeof arg3 === \"object\") arg3 = arg3.ptr;\n\n      _emscripten_bind_VectorizeExport_VectorizeToData_4(self, arg0, arg1, arg2, arg3);\n    };\n\n    VectorizeExport.prototype[\"VectorCount\"] = VectorizeExport.prototype.VectorCount = function () {\n      var self = this.ptr;\n      return _emscripten_bind_VectorizeExport_VectorCount_0(self);\n    };\n\n    VectorizeExport.prototype[\"GetVector\"] = VectorizeExport.prototype.GetVector = function (arg0) {\n      var self = this.ptr;\n      if (arg0 && typeof arg0 === \"object\") arg0 = arg0.ptr;\n      return wrapPointer(_emscripten_bind_VectorizeExport_GetVector_1(self, arg0), VectorPath);\n    };\n\n    VectorizeExport.prototype[\"__destroy__\"] = VectorizeExport.prototype.__destroy__ = function () {\n      var self = this.ptr;\n\n      _emscripten_bind_VectorizeExport___destroy___0(self);\n    };\n\n    function Path() {\n      throw \"cannot construct a Path, no constructor in IDL\";\n    }\n\n    Path.prototype = Object.create(WrapperObject.prototype);\n    Path.prototype.constructor = Path;\n    Path.prototype.__class__ = Path;\n    Path.__cache__ = {};\n    Module[\"Path\"] = Path;\n\n    Path.prototype[\"get_pPoints\"] = Path.prototype.get_pPoints = function (arg0) {\n      var self = this.ptr;\n      if (arg0 && typeof arg0 === \"object\") arg0 = arg0.ptr;\n      return wrapPointer(_emscripten_bind_Path_get_pPoints_1(self, arg0), Point);\n    };\n\n    Object.defineProperty(Path.prototype, \"pPoints\", {\n      get: Path.prototype.get_pPoints\n    });\n\n    Path.prototype[\"get_nPoints\"] = Path.prototype.get_nPoints = function () {\n      var self = this.ptr;\n      return _emscripten_bind_Path_get_nPoints_0(self);\n    };\n\n    Object.defineProperty(Path.prototype, \"nPoints\", {\n      get: Path.prototype.get_nPoints\n    });\n\n    Path.prototype[\"get_bIsCurve\"] = Path.prototype.get_bIsCurve = function () {\n      var self = this.ptr;\n      return !!_emscripten_bind_Path_get_bIsCurve_0(self);\n    };\n\n    Object.defineProperty(Path.prototype, \"bIsCurve\", {\n      get: Path.prototype.get_bIsCurve\n    });\n\n    Path.prototype[\"__destroy__\"] = Path.prototype.__destroy__ = function () {\n      var self = this.ptr;\n\n      _emscripten_bind_Path___destroy___0(self);\n    };\n\n    function VectorPath() {\n      throw \"cannot construct a VectorPath, no constructor in IDL\";\n    }\n\n    VectorPath.prototype = Object.create(WrapperObject.prototype);\n    VectorPath.prototype.constructor = VectorPath;\n    VectorPath.prototype.__class__ = VectorPath;\n    VectorPath.__cache__ = {};\n    Module[\"VectorPath\"] = VectorPath;\n\n    VectorPath.prototype[\"PathCount\"] = VectorPath.prototype.PathCount = function () {\n      var self = this.ptr;\n      return _emscripten_bind_VectorPath_PathCount_0(self);\n    };\n\n    VectorPath.prototype[\"GetPath\"] = VectorPath.prototype.GetPath = function (arg0) {\n      var self = this.ptr;\n      if (arg0 && typeof arg0 === \"object\") arg0 = arg0.ptr;\n      return wrapPointer(_emscripten_bind_VectorPath_GetPath_1(self, arg0), Path);\n    };\n\n    VectorPath.prototype[\"__destroy__\"] = VectorPath.prototype.__destroy__ = function () {\n      var self = this.ptr;\n\n      _emscripten_bind_VectorPath___destroy___0(self);\n    };\n\n    function VoidPtr() {\n      throw \"cannot construct a VoidPtr, no constructor in IDL\";\n    }\n\n    VoidPtr.prototype = Object.create(WrapperObject.prototype);\n    VoidPtr.prototype.constructor = VoidPtr;\n    VoidPtr.prototype.__class__ = VoidPtr;\n    VoidPtr.__cache__ = {};\n    Module[\"VoidPtr\"] = VoidPtr;\n\n    VoidPtr.prototype[\"__destroy__\"] = VoidPtr.prototype.__destroy__ = function () {\n      var self = this.ptr;\n\n      _emscripten_bind_VoidPtr___destroy___0(self);\n    };\n\n    function Point() {\n      throw \"cannot construct a Point, no constructor in IDL\";\n    }\n\n    Point.prototype = Object.create(WrapperObject.prototype);\n    Point.prototype.constructor = Point;\n    Point.prototype.__class__ = Point;\n    Point.__cache__ = {};\n    Module[\"Point\"] = Point;\n\n    Point.prototype[\"get_x\"] = Point.prototype.get_x = function () {\n      var self = this.ptr;\n      return _emscripten_bind_Point_get_x_0(self);\n    };\n\n    Object.defineProperty(Point.prototype, \"x\", {\n      get: Point.prototype.get_x\n    });\n\n    Point.prototype[\"get_y\"] = Point.prototype.get_y = function () {\n      var self = this.ptr;\n      return _emscripten_bind_Point_get_y_0(self);\n    };\n\n    Object.defineProperty(Point.prototype, \"y\", {\n      get: Point.prototype.get_y\n    });\n\n    Point.prototype[\"__destroy__\"] = Point.prototype.__destroy__ = function () {\n      var self = this.ptr;\n\n      _emscripten_bind_Point___destroy___0(self);\n    };\n\n    (function () {\n      function setupEnums() {}\n\n      if (runtimeInitialized) setupEnums();else addOnPreMain(setupEnums);\n    })();\n\n    return Module;\n  };\n}();\n\nif (true) module.exports = Module;else {}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../process/browser.js */ \"./node_modules/process/browser.js\"), \"/\", __webpack_require__(/*! ./../../../../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/@capture/shape-core/src/vectorize/VectorizeCore.js?");

/***/ }),

/***/ "./node_modules/@capture/shape-core/src/vectorize/VectorizeCore.wasm":
/*!***************************************************************************!*\
  !*** ./node_modules/@capture/shape-core/src/vectorize/VectorizeCore.wasm ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"resources/VectorizeCore.wasm\";\n\n//# sourceURL=webpack:///./node_modules/@capture/shape-core/src/vectorize/VectorizeCore.wasm?");

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n//# sourceURL=webpack:///./node_modules/base64-js/index.js?");

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n//# sourceURL=webpack:///./node_modules/ieee754/index.js?");

/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/buffer/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/buffer/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/node-libs-browser/node_modules/isarray/index.js\")\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/node-libs-browser/node_modules/buffer/index.js?");

/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/isarray/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/isarray/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n//# sourceURL=webpack:///./node_modules/node-libs-browser/node_modules/isarray/index.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ })

/******/ });